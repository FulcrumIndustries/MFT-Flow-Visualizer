<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MFT Flow Visualizer</title>
    <style>
        /* ============================================
           CSS VARIABLES & THEMES
           ============================================ */
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            --transition-speed: 0.2s;
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Light Theme */
        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --node-source: #dbeafe;
            --node-source-border: #3b82f6;
            --node-intermediate: #f1f5f9;
            --node-intermediate-border: #64748b;
            --node-target: #dcfce7;
            --node-target-border: #10b981;
            --edge-color: #64748b;
            --canvas-bg: #fafafa;
            --gradient-start: #f0f4ff;
            --gradient-end: #faf5ff;
            --annotation-bg: #fffbeb;
            --annotation-border: #fcd34d;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --accent-primary: #60a5fa;
            --accent-secondary: #34d399;
            --accent-warning: #fbbf24;
            --accent-danger: #f87171;
            --node-source: #1e3a5f;
            --node-source-border: #60a5fa;
            --node-intermediate: #334155;
            --node-intermediate-border: #94a3b8;
            --node-target: #14532d;
            --node-target-border: #34d399;
            --edge-color: #94a3b8;
            --canvas-bg: #0f172a;
            --gradient-start: #1e1b4b;
            --gradient-end: #1e293b;
            --annotation-bg: #422006;
            --annotation-border: #b45309;
        }

        /* ============================================
           BASE STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: var(--text-primary);
            transition: background var(--transition-speed), color var(--transition-speed);
        }

        /* Grainy texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* ============================================
           LAYOUT
           ============================================ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* ============================================
           HEADER
           ============================================ */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        /* Animated Noisy Gradient with Organic Waves */
        .header-gradient {
            position: absolute;
            top: 0;
            right: 0;
            width: 70%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            mask-image: linear-gradient(to left, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.5) 50%, rgba(0,0,0,0.2) 75%, transparent 100%);
            -webkit-mask-image: linear-gradient(to left, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.5) 50%, rgba(0,0,0,0.2) 75%, transparent 100%);
        }

        .header-gradient-inner {
            position: absolute;
            top: -100%;
            left: -100%;
            width: 400%;
            height: 400%;
            background: 
                radial-gradient(ellipse 80% 60% at 15% 40%, rgba(96, 180, 172, 0.7) 0%, transparent 50%),
                radial-gradient(ellipse 70% 80% at 70% 30%, rgba(230, 160, 130, 0.65) 0%, transparent 45%),
                radial-gradient(ellipse 60% 70% at 40% 70%, rgba(40, 60, 80, 0.6) 0%, transparent 50%),
                radial-gradient(ellipse 90% 50% at 85% 60%, rgba(200, 140, 120, 0.55) 0%, transparent 55%),
                radial-gradient(ellipse 50% 60% at 25% 80%, rgba(80, 150, 160, 0.5) 0%, transparent 45%);
            animation: organicFlow 20s ease-in-out infinite;
            filter: blur(40px);
        }

        .header-gradient-wave1 {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(ellipse 100% 40% at 30% 50%, rgba(96, 180, 172, 0.4) 0%, transparent 60%),
                radial-gradient(ellipse 80% 50% at 70% 60%, rgba(40, 50, 70, 0.35) 0%, transparent 55%);
            animation: waveFlow1 15s ease-in-out infinite;
            filter: blur(30px);
        }

        .header-gradient-wave2 {
            position: absolute;
            top: -30%;
            left: -30%;
            width: 160%;
            height: 160%;
            background: 
                radial-gradient(ellipse 70% 60% at 60% 40%, rgba(220, 150, 120, 0.45) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 70%, rgba(100, 170, 170, 0.35) 0%, transparent 55%);
            animation: waveFlow2 18s ease-in-out infinite reverse;
            filter: blur(35px);
        }

        .header-gradient-noise {
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            opacity: 0.35;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
            animation: noiseShift 0.5s steps(3) infinite;
        }

        .header-gradient-grain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.2;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grain'%3E%3CfeTurbulence type='turbulence' baseFrequency='0.85' numOctaves='4' result='noise'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grain)'/%3E%3C/svg%3E");
            mix-blend-mode: soft-light;
        }

        @keyframes organicFlow {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg) scale(1);
            }
            20% {
                transform: translate(5%, 3%) rotate(2deg) scale(1.05);
            }
            40% {
                transform: translate(-3%, 5%) rotate(-1deg) scale(0.98);
            }
            60% {
                transform: translate(4%, -2%) rotate(1.5deg) scale(1.02);
            }
            80% {
                transform: translate(-2%, -3%) rotate(-0.5deg) scale(1.03);
            }
        }

        @keyframes waveFlow1 {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            33% {
                transform: translate(8%, -5%) rotate(3deg);
            }
            66% {
                transform: translate(-5%, 8%) rotate(-2deg);
            }
        }

        @keyframes waveFlow2 {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            50% {
                transform: translate(-6%, 6%) rotate(-4deg);
            }
        }

        @keyframes noiseShift {
            0% { transform: translate(0, 0); }
            33% { transform: translate(-1px, 1px); }
            66% { transform: translate(1px, -1px); }
            100% { transform: translate(0, 0); }
        }

        [data-theme="dark"] .header-gradient-inner {
            background: 
                radial-gradient(ellipse 80% 60% at 15% 40%, rgba(80, 160, 155, 0.75) 0%, transparent 50%),
                radial-gradient(ellipse 70% 80% at 70% 30%, rgba(210, 140, 110, 0.7) 0%, transparent 45%),
                radial-gradient(ellipse 60% 70% at 40% 70%, rgba(30, 45, 65, 0.65) 0%, transparent 50%),
                radial-gradient(ellipse 90% 50% at 85% 60%, rgba(190, 130, 100, 0.6) 0%, transparent 55%),
                radial-gradient(ellipse 50% 60% at 25% 80%, rgba(70, 140, 150, 0.55) 0%, transparent 45%);
        }

        [data-theme="dark"] .header-gradient-wave1 {
            background: 
                radial-gradient(ellipse 100% 40% at 30% 50%, rgba(80, 160, 155, 0.5) 0%, transparent 60%),
                radial-gradient(ellipse 80% 50% at 70% 60%, rgba(30, 40, 60, 0.45) 0%, transparent 55%);
        }

        [data-theme="dark"] .header-gradient-wave2 {
            background: 
                radial-gradient(ellipse 70% 60% at 60% 40%, rgba(200, 130, 100, 0.5) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 70%, rgba(90, 155, 160, 0.4) 0%, transparent 55%);
        }

        [data-theme="dark"] .header-gradient-noise {
            opacity: 0.4;
        }

        [data-theme="dark"] .header-gradient-grain {
            opacity: 0.25;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .workspace-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-divider {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 4px;
        }

        .workspace-select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            min-width: 180px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .workspace-select:hover {
            border-color: var(--accent-primary);
        }

        .workspace-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
        }

        .btn-danger {
            color: var(--accent-danger);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--accent-danger);
        }

        /* ============================================
           EDITOR SECTION
           ============================================ */
        .editor-section {
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .editor-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .save-indicator {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .save-indicator.saving {
            color: var(--accent-warning);
        }

        .save-indicator.saved {
            color: var(--accent-secondary);
        }

        .pattern-editor-wrapper {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            overflow: hidden;
            transition: all var(--transition-speed);
            height: 120px;
            max-height: 200px;
            resize: vertical;
        }

        .pattern-editor-wrapper:focus-within {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .line-numbers {
            padding: 14px 8px 14px 12px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 22.4px;
            color: var(--text-muted);
            text-align: right;
            user-select: none;
            min-width: 44px;
            overflow-y: hidden;
            overflow-x: hidden;
            flex-shrink: 0;
        }

        .line-numbers span {
            display: block;
            height: 22.4px;
        }

        .pattern-editor {
            flex: 1;
            height: 100%;
            padding: 14px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 22.4px;
            resize: none;
            overflow-y: auto;
        }

        .pattern-editor:focus {
            outline: none;
        }

        .pattern-editor::placeholder {
            color: var(--text-muted);
        }

        .error-message {
            margin-top: 8px;
            padding: 10px 14px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-danger);
            border-radius: var(--border-radius);
            color: var(--accent-danger);
            font-size: 13px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        .error-line {
            margin-bottom: 4px;
        }

        .error-line:last-child {
            margin-bottom: 0;
        }

        /* ============================================
           CANVAS SECTION
           ============================================ */
        .canvas-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .canvas-section {
            flex: 1;
            position: relative;
            overflow: auto;
            background: var(--canvas-bg);
        }

        .canvas-container {
            min-width: 100%;
            min-height: 100%;
            padding: 20px;
            display: inline-block;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .empty-state-description {
            font-size: 14px;
            max-width: 300px;
        }

        /* ============================================
           FLOW ROW STYLES
           ============================================ */
        .flow-row {
            display: inline-flex;
            align-items: center;
            margin-bottom: 40px;
            padding: 20px;
            padding-right: 30px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            position: relative;
            cursor: pointer;
            transition: all var(--transition-speed);
            min-width: calc(100% - 40px);
            white-space: nowrap;
        }

        .flow-row:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-md);
        }

        .flow-row.selected {
            border-color: var(--accent-primary);
            border-width: 2px;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .flow-row:last-child {
            margin-bottom: 0;
        }

        .flow-row-number {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--accent-primary);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .flow-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
            flex-shrink: 0;
        }

        .node-box {
            padding: 12px 20px;
            border-radius: var(--border-radius);
            border: 2px solid;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            min-width: 100px;
            transition: all var(--transition-speed);
        }

        .node-box.source {
            background: var(--node-source);
            border-color: var(--node-source-border);
            color: var(--node-source-border);
        }

        .node-box.intermediate {
            background: var(--node-intermediate);
            border-color: var(--node-intermediate-border);
            color: var(--text-primary);
        }

        .node-box.target {
            background: var(--node-target);
            border-color: var(--node-target-border);
            color: var(--node-target-border);
        }

        .node-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 6px;
            color: var(--text-muted);
        }

        /* ============================================
           EDGE / CONNECTION STYLES
           ============================================ */
        .flow-edge {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
            min-width: 160px;
            position: relative;
        }

        .edge-line-container {
            display: flex;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .edge-line {
            flex: 1;
            height: 2px;
            position: relative;
            background-image: repeating-linear-gradient(90deg,
                    var(--edge-color) 0,
                    var(--edge-color) 6px,
                    transparent 6px,
                    transparent 10px);
            background-size: 10px 2px;
            animation: flowDash 0.4s linear infinite;
        }

        @keyframes flowDash {
            from {
                background-position: 0 0;
            }
            to {
                background-position: 10px 0;
            }
        }

        .edge-arrow {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid var(--edge-color);
            flex-shrink: 0;
        }

        .edge-arrow.reverse {
            border-left: none;
            border-right: 10px solid var(--edge-color);
        }

        .edge-protocol {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .edge-protocol.invalid {
            font-style: italic;
            border-color: var(--accent-warning, #ff9800);
            background: var(--bg-warning, rgba(255, 152, 0, 0.1));
        }

        .edge-protocol.invalid::before {
            content: '⚠ ';
            margin-right: 2px;
        }

        .edge-protocol-select {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-warning, #ff9800);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            cursor: pointer;
            min-width: 150px;
            font-style: italic;
        }

        .edge-protocol-select:focus {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        /* ============================================
           ANNOTATION INPUT STYLES
           ============================================ */
        .edge-annotations {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            width: 100%;
        }

        .annotation-input {
            width: 100%;
            padding: 6px 8px;
            font-size: 11px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            text-align: center;
            transition: all var(--transition-speed);
        }

        .annotation-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .annotation-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        .annotation-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        /* ============================================
           SOURCE/TARGET DESCRIPTION FIELDS
           ============================================ */
        .flow-description-field {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            min-width: 120px;
            max-width: 180px;
        }

        .flow-description-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .flow-description-input {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            font-size: 11px;
            border: 1px dashed var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            text-align: center;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .flow-description-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .flow-description-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .flow-description-field.before-source .flow-description-input {
            border-color: var(--node-source);
        }

        .flow-description-field.after-target .flow-description-input {
            border-color: var(--node-target);
        }

        .flow-description-field.before-source .flow-description-input:focus {
            border-color: var(--node-source);
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
        }

        .flow-description-field.after-target .flow-description-input:focus {
            border-color: var(--node-target);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }

        /* ============================================
           MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 24px;
            min-width: 360px;
            max-width: 90%;
            box-shadow: var(--shadow-lg);
            transform: scale(0.95);
            transition: transform var(--transition-speed);
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* ============================================
           LOADING OVERLAY
           ============================================ */
        .loading-overlay {
            position: fixed;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: #ffffff;
            font-size: 16px;
            margin-top: 20px;
            font-weight: 500;
        }

        .loading-subtext {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            margin-top: 8px;
        }

        /* ============================================
           HELP PANEL
           ============================================ */
        .help-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: right var(--transition-speed);
            overflow-y: auto;
        }

        .help-panel.visible {
            right: 0;
        }

        .help-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .help-panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .help-panel-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .help-section p {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .help-example {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            color: var(--text-primary);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* ============================================
           PATTERN INFO PANEL
           ============================================ */
        .pattern-info-panel {
            width: 350px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
        }

        .pattern-info-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .pattern-info-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flow-selector {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .flow-selector:hover {
            border-color: var(--accent-primary);
        }

        .flow-selector:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .pattern-info-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .info-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .info-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .general-notes-field {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: var(--font-family);
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .general-notes-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .general-notes-field::placeholder {
            color: var(--text-muted);
        }

        .required-products-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .product-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            transition: all var(--transition-speed);
        }

        .product-item:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-sm);
        }

        .product-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .product-capabilities {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .capability-badge {
            padding: 4px 8px;
            background: var(--accent-primary);
            color: white;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .no-products-message {
            padding: 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 13px;
            font-style: italic;
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                gap: 12px;
            }

            .header-left {
                width: 100%;
                justify-content: space-between;
            }

            .workspace-controls {
                width: 100%;
            }

            .workspace-select {
                flex: 1;
            }

            .help-panel {
                width: 100%;
                right: -100%;
            }

            .flow-row {
                overflow-x: auto;
            }

            .canvas-wrapper {
                flex-direction: column;
            }

            .pattern-info-panel {
                width: 100%;
                max-height: 300px;
            }
        }
    </style>
</head>

<body data-theme="light">
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <!-- Animated Organic Wavy Gradient with Grain -->
            <div class="header-gradient">
                <div class="header-gradient-inner"></div>
                <div class="header-gradient-wave1"></div>
                <div class="header-gradient-wave2"></div>
                <div class="header-gradient-noise"></div>
                <div class="header-gradient-grain"></div>
            </div>
            
            <div class="header-left">
                <div class="logo">
                    <div class="logo-icon">⇌</div>
                    <span>MFT Flow Visualizer</span>
                </div>
                <div class="workspace-controls">
                    <select id="workspaceSelect" class="workspace-select">
                        <option value="">Loading...</option>
                    </select>
                    <button id="newWorkspaceBtn" class="btn btn-primary btn-icon" title="New Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <button id="renameWorkspaceBtn" class="btn btn-icon" title="Rename Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                        </svg>
                    </button>
                    <button id="duplicateWorkspaceBtn" class="btn btn-icon" title="Duplicate Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button id="deleteWorkspaceBtn" class="btn btn-icon btn-danger" title="Delete Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                            </path>
                        </svg>
                    </button>
                    <span class="workspace-divider"></span>
                    <button id="exportWorkspaceBtn" class="btn btn-icon" title="Export Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                    </button>
                    <button id="importWorkspaceBtn" class="btn btn-icon" title="Import Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                    </button>
                    <button id="exportPdfBtn" class="btn btn-icon" title="Export PDF Report">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;">
                </div>
            </div>
            <div class="header-right">
                <button id="themeToggleBtn" class="btn btn-icon" title="Toggle Theme">
                    <svg id="themeIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <button id="helpBtn" class="btn btn-icon" title="Help">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Editor Section -->
        <section class="editor-section">
            <div class="editor-header">
                <span class="editor-title">Flow Patterns (one per line)</span>
                <span id="saveIndicator" class="save-indicator saved">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    <span id="saveText">Saved</span>
                </span>
            </div>
            <div class="pattern-editor-wrapper">
                <div id="lineNumbers" class="line-numbers"><span>1</span></div>
                <textarea id="patternEditor" class="pattern-editor" placeholder="Enter your MFT flow patterns here (one per line)...

Examples:
TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF" spellcheck="false"></textarea>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </section>

        <!-- Canvas Section -->
        <div class="canvas-wrapper">
            <section class="canvas-section">
                <div id="canvasContainer" class="canvas-container">
                    <!-- Flow rows will be rendered here -->
                </div>

                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">⇌</div>
                    <div class="empty-state-title">No Flows Defined</div>
                    <div class="empty-state-description">
                        Enter flow patterns in the editor above to visualize your MFT flows.
                    </div>
                </div>
            </section>

            <!-- Pattern Info Panel -->
            <div id="patternInfoPanel" class="pattern-info-panel">
                <div class="pattern-info-header">
                    <span class="pattern-info-title">Flow Information</span>
                </div>
                <div class="pattern-info-content">
                    <div class="info-section">
                        <label class="info-label">Select Flow</label>
                        <select id="flowSelector" class="flow-selector">
                            <option value="">-- Select a flow --</option>
                        </select>
                    </div>
                    <div class="info-section">
                        <label class="info-label">General Notes</label>
                        <textarea id="generalNotesField" class="general-notes-field" placeholder="Add general notes about this flow..."></textarea>
                    </div>
                    <div class="info-section">
                        <label class="info-label">Potential Products</label>
                        <div id="requiredProductsList" class="required-products-list">
                            <div class="no-products-message">Select a flow to see potential products</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- Help Panel -->
    <div id="helpPanel" class="help-panel">
        <div class="help-panel-header">
            <span class="help-panel-title">Help & Syntax Guide</span>
            <button id="closeHelpBtn" class="btn btn-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="help-panel-content">
            <div class="help-section">
                <h3 class="help-section-title">Pattern Syntax</h3>
                <p>Define MFT flows using a simple text-based syntax. Enter one pattern per line.</p>
                <div class="help-example">SOURCE -> PROTOCOL DIRECTION -> MIDDLE -> PROTOCOL DIRECTION -> TARGET</div>
            </div>
            <div class="help-section">
                <h3 class="help-section-title">Examples</h3>
                <div class="help-example">TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
                    TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
                    TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF
                        TESTZ -> PeSIT PUSH -> ST -> JMS PUSH -> SFC -> EBICS PUSH -> BANK1</div>
            </div>
            <div class="help-section">
                <h3 class="help-section-title">Components</h3>
                <p><strong>Entities:</strong> Names like TESTA, ST, CFT (alphanumeric + underscores)</p>
                <p><strong>Protocols:</strong> SFTP, PeSIT, HTTPS, FTP, AS2, SSH, JMS, EBICS, etc.</p>
                <p><strong>Directions:</strong> PULL (fetch data) or PUSH (send data)</p>
                <p><strong>Arrows:</strong> <- (left) and -> (right) indicate flow direction</p>
            </div>
            <div class="help-section">
                <h3 class="help-section-title">Annotations</h3>
                <p>Each connection has editable annotation fields for pre-processing and post-processing notes. Click on
                    the yellow dashed boxes to add annotations.</p>
            </div>
        </div>
    </div>

    <!-- Loading Overlay for PDF Generation -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Generating PDF Report</div>
        <div class="loading-subtext">Please wait...</div>
    </div>

    <!-- Modal for Rename/New Workspace -->
    <div id="modalOverlay" class="modal-overlay">
        <div class="modal">
            <h2 id="modalTitle" class="modal-title">New Workspace</h2>
            <input type="text" id="modalInput" class="modal-input" placeholder="Workspace name">
            <div class="modal-actions">
                <button id="modalCancelBtn" class="btn">Cancel</button>
                <button id="modalConfirmBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <script src="products_capabilities.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function generateId() {
            return 'ws_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ============================================
        // STATE MANAGER
        // ============================================
        const StateManager = {
            state: {
                workspaces: new Map(),
                activeWorkspaceId: null,
                theme: 'light'
            },
            listeners: [],

            subscribe(listener) {
                this.listeners.push(listener);
                return () => {
                    this.listeners = this.listeners.filter(l => l !== listener);
                };
            },

            notify(event) {
                this.listeners.forEach(listener => listener(event, this.state));
            },

            getActiveWorkspace() {
                return this.state.workspaces.get(this.state.activeWorkspaceId);
            },

            setActiveWorkspace(id) {
                if (this.state.workspaces.has(id)) {
                    this.state.activeWorkspaceId = id;
                    this.notify({ type: 'WORKSPACE_CHANGED', workspaceId: id });
                }
            },

            updatePattern(text) {
                const workspace = this.getActiveWorkspace();
                if (workspace) {
                    workspace.patternText = text;
                    workspace.metadata.updatedAt = Date.now();
                    this.notify({ type: 'PATTERN_UPDATED', workspaceId: workspace.id });
                }
            },

            updateFlowNotes(flowIndex, text) {
                const workspace = this.getActiveWorkspace();
                if (workspace) {
                    if (!workspace.flowNotes) {
                        workspace.flowNotes = {};
                    }
                    workspace.flowNotes[flowIndex] = text;
                    workspace.metadata.updatedAt = Date.now();
                    this.notify({ type: 'FLOW_NOTES_UPDATED', workspaceId: workspace.id, flowIndex });
                }
            },

            getFlowNotes(flowIndex) {
                const workspace = this.getActiveWorkspace();
                if (workspace && workspace.flowNotes) {
                    return workspace.flowNotes[flowIndex] || '';
                }
                return '';
            },

            updateFlowDescription(flowIndex, type, text) {
                // type is 'beforeSource' or 'afterTarget'
                const workspace = this.getActiveWorkspace();
                if (workspace) {
                    if (!workspace.flowDescriptions) {
                        workspace.flowDescriptions = {};
                    }
                    const key = `${flowIndex}-${type}`;
                    workspace.flowDescriptions[key] = text;
                    workspace.metadata.updatedAt = Date.now();
                    this.notify({ type: 'FLOW_DESCRIPTION_UPDATED', workspaceId: workspace.id, flowIndex, descType: type });
                }
            },

            getFlowDescription(flowIndex, type) {
                // type is 'beforeSource' or 'afterTarget'
                const workspace = this.getActiveWorkspace();
                if (workspace && workspace.flowDescriptions) {
                    const key = `${flowIndex}-${type}`;
                    return workspace.flowDescriptions[key] || '';
                }
                return '';
            },

            updateAnnotation(flowIndex, edgeIndex, field, value) {
                const workspace = this.getActiveWorkspace();
                if (workspace) {
                    if (!workspace.annotations) {
                        workspace.annotations = {};
                    }
                    const key = `${flowIndex}-${edgeIndex}-${field}`;
                    workspace.annotations[key] = value;
                    workspace.metadata.updatedAt = Date.now();
                    this.notify({ type: 'ANNOTATION_UPDATED', workspaceId: workspace.id });
                }
            },

            getAnnotation(flowIndex, edgeIndex, field) {
                const workspace = this.getActiveWorkspace();
                if (workspace && workspace.annotations) {
                    const key = `${flowIndex}-${edgeIndex}-${field}`;
                    return workspace.annotations[key] || '';
                }
                return '';
            },

            setTheme(theme) {
                this.state.theme = theme;
                this.notify({ type: 'THEME_CHANGED', theme });
            }
        };

        // ============================================
        // PERSISTENCE LAYER
        // ============================================
        const Persistence = {
            STORAGE_KEY: 'mft_flow_visualizer',
            VERSION: '1.1.0',

            save() {
                try {
                    const data = {
                        version: this.VERSION,
                        activeWorkspaceId: StateManager.state.activeWorkspaceId,
                        theme: StateManager.state.theme,
                        workspaces: Array.from(StateManager.state.workspaces.entries()).map(([id, ws]) => ({
                            id: ws.id,
                            name: ws.name,
                            patternText: ws.patternText,
                            flowNotes: ws.flowNotes || {},
                            flowDescriptions: ws.flowDescriptions || {},
                            annotations: ws.annotations || {},
                            metadata: ws.metadata
                        }))
                    };
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('Failed to save:', e);
                    return false;
                }
            },

            load() {
                try {
                    const raw = localStorage.getItem(this.STORAGE_KEY);
                    if (!raw) return null;

                    const data = JSON.parse(raw);

                    // Convert workspaces array back to Map
                    const workspaces = new Map();
                    if (data.workspaces) {
                    data.workspaces.forEach(ws => {
                        workspaces.set(ws.id, {
                            ...ws,
                            flowNotes: ws.flowNotes || {},
                            flowDescriptions: ws.flowDescriptions || {},
                            annotations: ws.annotations || {}
                        });
                    });
                    }

                    return {
                        ...data,
                        workspaces
                    };
                } catch (e) {
                    console.error('Failed to load:', e);
                    return null;
                }
            },

            clear() {
                localStorage.removeItem(this.STORAGE_KEY);
            }
        };

        // ============================================
        // WORKSPACE MANAGER
        // ============================================
        const WorkspaceManager = {
            createWorkspace(name = 'Untitled Workspace') {
                const id = generateId();
                const workspace = {
                    id,
                    name,
                    patternText: '',
                    flowNotes: {},
                    flowDescriptions: {},
                    annotations: {},
                    metadata: {
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        version: '1.0.0'
                    }
                };
                StateManager.state.workspaces.set(id, workspace);
                StateManager.setActiveWorkspace(id);
                Persistence.save();
                return workspace;
            },

            renameWorkspace(id, newName) {
                const workspace = StateManager.state.workspaces.get(id);
                if (workspace) {
                    workspace.name = newName;
                    workspace.metadata.updatedAt = Date.now();
                    StateManager.notify({ type: 'WORKSPACE_RENAMED', workspaceId: id });
                    Persistence.save();
                }
            },

            duplicateWorkspace(id) {
                const original = StateManager.state.workspaces.get(id);
                if (original) {
                    const newId = generateId();
                    const duplicate = {
                        ...JSON.parse(JSON.stringify(original)),
                        id: newId,
                        name: original.name + ' (Copy)',
                        metadata: {
                            createdAt: Date.now(),
                            updatedAt: Date.now(),
                            version: original.metadata.version
                        }
                    };
                    StateManager.state.workspaces.set(newId, duplicate);
                    StateManager.setActiveWorkspace(newId);
                    Persistence.save();
                    return duplicate;
                }
                return null;
            },

            deleteWorkspace(id) {
                if (StateManager.state.workspaces.size <= 1) {
                    alert('Cannot delete the last workspace');
                    return false;
                }

                StateManager.state.workspaces.delete(id);

                // Switch to another workspace
                const firstId = StateManager.state.workspaces.keys().next().value;
                StateManager.setActiveWorkspace(firstId);
                Persistence.save();
                return true;
            },

            initialize() {
                const saved = Persistence.load();

                if (saved && saved.workspaces.size > 0) {
                    StateManager.state.workspaces = saved.workspaces;
                    StateManager.state.theme = saved.theme || 'light';

                    // Set active workspace
                    if (saved.activeWorkspaceId && saved.workspaces.has(saved.activeWorkspaceId)) {
                        StateManager.setActiveWorkspace(saved.activeWorkspaceId);
                    } else {
                        const firstId = saved.workspaces.keys().next().value;
                        StateManager.setActiveWorkspace(firstId);
                    }
                } else {
                    // Create default workspace
                    this.createWorkspace('My First Flow');
                }
            }
        };

        // ============================================
        // PARSER ENGINE
        // ============================================
        const Parser = {
            parseMultiple(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const results = [];
                const errors = [];

                lines.forEach((line, index) => {
                    const result = this.parseLine(line.trim(), index + 1);
                    if (result.error) {
                        errors.push({ line: index + 1, message: result.error });
                    } else if (result.nodes.length > 0) {
                        results.push({
                            lineNumber: index + 1,
                            originalText: line.trim(),
                            nodes: result.nodes,
                            edges: result.edges
                        });
                    }
                });

                return { flows: results, errors };
            },

            parseLine(text, lineNumber) {
                const result = {
                    nodes: [],
                    edges: [],
                    error: null
                };

                if (!text || !text.trim()) {
                    return result;
                }

                const trimmed = text.trim();

                // Tokenize the pattern
                const tokens = this.tokenize(trimmed);

                if (tokens.error) {
                    result.error = tokens.error;
                    return result;
                }

                // Build nodes and edges from tokens
                const { nodes, edges, error } = this.buildGraph(tokens.segments);

                if (error) {
                    result.error = error;
                    return result;
                }

                result.nodes = nodes;
                result.edges = edges;

                return result;
            },

            tokenize(text) {
                const segments = [];

                // Split by arrows while keeping track of direction
                const arrowPattern = /(<-|->)/g;
                const parts = text.split(arrowPattern).map(p => p.trim()).filter(p => p);

                if (parts.length < 5) {
                    return { error: 'Invalid pattern. Expected: Entity -> PROTOCOL DIRECTION -> Entity' };
                }

                let currentIndex = 0;

                // First entity - accept any string (no validation)
                const firstEntity = parts[currentIndex];
                segments.push({ type: 'entity', value: firstEntity });
                currentIndex++;

                while (currentIndex < parts.length) {
                    // Expect arrow
                    const arrow1 = parts[currentIndex];
                    if (arrow1 !== '<-' && arrow1 !== '->') {
                        return { error: `Expected arrow (<- or ->), got: "${arrow1}"` };
                    }
                    currentIndex++;

                    // Expect PROTOCOL DIRECTION
                    if (currentIndex >= parts.length) {
                        return { error: 'Unexpected end of pattern after arrow' };
                    }
                    const protocolDir = parts[currentIndex];
                    // Match protocol (can contain spaces, letters, numbers, underscores) followed by PULL or PUSH
                    const pdMatch = protocolDir.match(/^(.+?)\s+(PULL|PUSH)$/i);
                    if (!pdMatch) {
                        return { error: `Invalid protocol/direction: "${protocolDir}". Expected: PROTOCOL PULL/PUSH` };
                    }
                    currentIndex++;

                    // Expect second arrow (should match the first in direction sense)
                    if (currentIndex >= parts.length) {
                        return { error: 'Unexpected end of pattern, expected arrow' };
                    }
                    const arrow2 = parts[currentIndex];
                    if (arrow2 !== '<-' && arrow2 !== '->') {
                        return { error: `Expected arrow (<- or ->), got: "${arrow2}"` };
                    }

                    // Validate arrow consistency
                    if (arrow1 !== arrow2) {
                        return { error: `Inconsistent arrows: ${arrow1} and ${arrow2}. Both should match.` };
                    }
                    currentIndex++;

                    // Expect entity - accept any string (no validation)
                    if (currentIndex >= parts.length) {
                        return { error: 'Unexpected end of pattern, expected entity' };
                    }
                    const entity = parts[currentIndex];

                    // Preserve original protocol name case for matching (e.g., "Amazon S3" not "AMAZON S3")
                    const protocolName = pdMatch[1].trim();
                    segments.push({
                        type: 'connection',
                        arrow: arrow1,
                        protocol: protocolName,
                        direction: pdMatch[2].toUpperCase(),
                        toEntity: entity
                    });

                    segments.push({ type: 'entity', value: entity });
                    currentIndex++;
                }

                return { segments };
            },


            buildGraph(segments) {
                const nodes = [];
                const edges = [];
                const nodeMap = new Map();

                let nodeIndex = 0;

                // First pass: collect all unique entities
                segments.forEach(seg => {
                    if (seg.type === 'entity' && !nodeMap.has(seg.value)) {
                        nodeMap.set(seg.value, nodeIndex++);
                    }
                });

                // Determine node types based on position
                const entityList = segments.filter(s => s.type === 'entity').map(s => s.value);

                entityList.forEach((entity, idx) => {
                    let type = 'intermediate';
                    if (idx === 0) type = 'source';
                    else if (idx === entityList.length - 1) type = 'target';

                    nodes.push({
                        id: 'node_' + idx,
                        label: entity,
                        type: type,
                        index: idx
                    });
                });

                // Second pass: build edges
                let lastEntity = null;
                let edgeIndex = 0;
                segments.forEach(seg => {
                    if (seg.type === 'entity') {
                        lastEntity = seg.value;
                    } else if (seg.type === 'connection' && lastEntity) {
                        const fromEntity = lastEntity;
                        const toEntity = seg.toEntity;

                        // Determine actual from/to based on arrow direction
                        let flowDirection = seg.arrow === '<-' ? 'reverse' : 'forward';

                        edges.push({
                            id: 'edge_' + edgeIndex,
                            fromLabel: fromEntity,
                            toLabel: toEntity,
                            protocol: seg.protocol,
                            direction: seg.direction,
                            flowDirection: flowDirection,
                            index: edgeIndex
                        });
                        edgeIndex++;
                    }
                });

                return { nodes, edges, error: null };
            }
        };

        // ============================================
        // DIAGRAM RENDERER
        // ============================================
        const DiagramRenderer = {
            selectedFlowIndex: null,
            flows: [],

            render(flows, container) {
                container.innerHTML = '';
                this.flows = flows;

                if (!flows || flows.length === 0) {
                    document.getElementById('emptyState').style.display = 'block';
                    this.updateFlowSelector([]);
                    this.updateRequiredProducts(null);
                    this.updateNotesField(null);
                    return;
                }

                document.getElementById('emptyState').style.display = 'none';

                flows.forEach((flow, flowIndex) => {
                    const rowElement = this.createFlowRow(flow, flowIndex);
                    container.appendChild(rowElement);
                });

                // Update flow selector
                this.updateFlowSelector(flows);
                
                // If no flow selected, select first one
                if (this.selectedFlowIndex === null && flows.length > 0) {
                    this.selectFlow(0);
                } else if (this.selectedFlowIndex !== null) {
                    this.selectFlow(this.selectedFlowIndex);
                }
            },

            updateFlowSelector(flows) {
                const selector = document.getElementById('flowSelector');
                if (!selector) return;

                selector.innerHTML = '<option value="">-- Select a flow --</option>';
                flows.forEach((flow, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Flow ${index + 1}: ${flow.originalText.substring(0, 50)}${flow.originalText.length > 50 ? '...' : ''}`;
                    selector.appendChild(option);
                });

                if (this.selectedFlowIndex !== null) {
                    selector.value = this.selectedFlowIndex;
                }
            },

            selectFlow(flowIndex) {
                this.selectedFlowIndex = flowIndex;
                
                // Update UI
                const rows = document.querySelectorAll('.flow-row');
                rows.forEach((row, index) => {
                    if (index === flowIndex) {
                        row.classList.add('selected');
                    } else {
                        row.classList.remove('selected');
                    }
                });

                const selector = document.getElementById('flowSelector');
                if (selector) {
                    selector.value = flowIndex;
                }

                // Update notes and products for selected flow
                if (flowIndex !== null && this.flows[flowIndex]) {
                    this.updateNotesField(flowIndex);
                    this.updateRequiredProducts(flowIndex);
                } else {
                    this.updateNotesField(null);
                    this.updateRequiredProducts(null);
                }
            },

            updateRequiredProducts(flowIndex) {
                const productsList = document.getElementById('requiredProductsList');
                if (!productsList) return;

                if (flowIndex === null || !this.flows[flowIndex]) {
                    productsList.innerHTML = '<div class="no-products-message">Select a flow to see potential products</div>';
                    return;
                }

                const flow = this.flows[flowIndex];
                const requiredProducts = getRequiredProducts([flow]);

                if (requiredProducts.length === 0) {
                    productsList.innerHTML = '<div class="no-products-message">No matching products found for the protocols used</div>';
                    return;
                }

                productsList.innerHTML = requiredProducts.map(product => {
                    const capabilitiesHtml = product.supportedCapabilities
                        .map(cap => `<span class="capability-badge">${cap}</span>`)
                        .join('');
                    return `
                        <div class="product-item">
                            <div class="product-name">${product.name}</div>
                            <div class="product-capabilities">${capabilitiesHtml}</div>
                        </div>
                    `;
                }).join('');
            },

            updateNotesField(flowIndex) {
                const notesField = document.getElementById('generalNotesField');
                if (!notesField) return;

                if (flowIndex === null) {
                    notesField.value = '';
                    notesField.disabled = true;
                } else {
                    notesField.value = StateManager.getFlowNotes(flowIndex);
                    notesField.disabled = false;
                }
            },

            createFlowRow(flow, flowIndex) {
                const row = document.createElement('div');
                row.className = 'flow-row';
                if (flowIndex === this.selectedFlowIndex) {
                    row.classList.add('selected');
                }

                // Make row clickable
                row.addEventListener('click', () => {
                    this.selectFlow(flowIndex);
                });

                // Row number indicator
                const rowNumber = document.createElement('div');
                rowNumber.className = 'flow-row-number';
                rowNumber.textContent = `Flow ${flowIndex + 1}`;
                row.appendChild(rowNumber);

                // Render nodes and edges
                flow.nodes.forEach((node, nodeIndex) => {
                    // Add "Before Source" description field before the first node (source)
                    if (nodeIndex === 0 && node.type === 'source') {
                        const beforeSourceField = this.createDescriptionField(flowIndex, 'beforeSource', 'Before Source');
                        row.appendChild(beforeSourceField);
                    }

                    // Add node
                    const nodeElement = this.createNodeElement(node);
                    row.appendChild(nodeElement);

                    // Add edge after node (except for last node)
                    if (nodeIndex < flow.edges.length) {
                        const edge = flow.edges[nodeIndex];
                        const edgeElement = this.createEdgeElement(edge, flowIndex, nodeIndex);
                        row.appendChild(edgeElement);
                    }

                    // Add "After Target" description field after the last node (target)
                    if (nodeIndex === flow.nodes.length - 1 && node.type === 'target') {
                        const afterTargetField = this.createDescriptionField(flowIndex, 'afterTarget', 'After Target');
                        row.appendChild(afterTargetField);
                    }
                });

                return row;
            },

            createDescriptionField(flowIndex, type, label) {
                const container = document.createElement('div');
                container.className = `flow-description-field ${type === 'beforeSource' ? 'before-source' : 'after-target'}`;

                const labelElement = document.createElement('div');
                labelElement.className = 'flow-description-label';
                labelElement.textContent = label;

                const textarea = document.createElement('textarea');
                textarea.className = 'flow-description-input';
                textarea.placeholder = type === 'beforeSource' 
                    ? 'Describe pre-source steps...' 
                    : 'Describe post-target steps...';
                textarea.value = StateManager.getFlowDescription(flowIndex, type);

                // Debounced save
                let saveTimeout;
                textarea.addEventListener('input', () => {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                        StateManager.updateFlowDescription(flowIndex, type, textarea.value);
                        Persistence.save();
                    }, 300);
                });

                // Stop propagation to prevent row selection when typing
                textarea.addEventListener('click', (e) => e.stopPropagation());

                container.appendChild(labelElement);
                container.appendChild(textarea);

                return container;
            },

            createNodeElement(node) {
                const container = document.createElement('div');
                container.className = 'flow-node';

                const box = document.createElement('div');
                box.className = `node-box ${node.type}`;
                box.textContent = node.label;

                const typeLabel = document.createElement('div');
                typeLabel.className = 'node-type';
                typeLabel.textContent = node.type;

                container.appendChild(box);
                container.appendChild(typeLabel);

                return container;
            },

            createEdgeElement(edge, flowIndex, edgeIndex) {
                const container = document.createElement('div');
                container.className = 'flow-edge';

                // Check if protocol+direction is valid
                const currentCapability = `${edge.protocol} ${edge.direction}`;
                // Ensure functions are available (defensive check)
                // If function doesn't exist, default to invalid (show dropdown) to be safe
                let isValid = false;
                if (typeof isValidCapability === 'function') {
                    try {
                        isValid = isValidCapability(edge.protocol, edge.direction);
                    } catch (e) {
                        console.error('Error checking capability validity:', e);
                        isValid = false; // Default to invalid on error
                    }
                } else {
                    console.warn('isValidCapability function not found - treating all as potentially invalid');
                    // Default to showing dropdown if function not available
                    isValid = false;
                }

                // Protocol label or select dropdown
                let protocolElement;
                if (!isValid) {
                    // Create select dropdown for invalid capabilities
                    protocolElement = document.createElement('select');
                    protocolElement.className = 'edge-protocol-select';
                    protocolElement.title = 'Unknown capability - select a valid one';
                    
                    // Get all available capabilities
                    const allCapabilities = getAllAvailableCapabilities();
                    
                    // Add current (invalid) value as first option
                    const currentOption = document.createElement('option');
                    currentOption.value = currentCapability;
                    currentOption.textContent = `${edge.protocol} ${edge.direction} ⚠`;
                    currentOption.selected = true;
                    protocolElement.appendChild(currentOption);
                    
                    // Add separator
                    const separator = document.createElement('option');
                    separator.disabled = true;
                    separator.textContent = '──────────';
                    protocolElement.appendChild(separator);
                    
                    // Add all valid capabilities
                    allCapabilities.forEach(cap => {
                        const option = document.createElement('option');
                        option.value = cap;
                        option.textContent = cap;
                        protocolElement.appendChild(option);
                    });
                    
                    // Handle change event
                    protocolElement.addEventListener('change', (e) => {
                        const newCapability = e.target.value;
                        if (newCapability && newCapability !== currentCapability) {
                            this.updateProtocolInPattern(flowIndex, edgeIndex, edge.protocol, edge.direction, newCapability);
                        }
                    });
                } else {
                    // Create regular div for valid capabilities
                    protocolElement = document.createElement('div');
                    protocolElement.className = 'edge-protocol';
                    protocolElement.textContent = currentCapability;
                }

                // Line container
                const lineContainer = document.createElement('div');
                lineContainer.className = 'edge-line-container';

                // Arrow at start if reverse
                if (edge.flowDirection === 'reverse') {
                    const arrowStart = document.createElement('div');
                    arrowStart.className = 'edge-arrow reverse';
                    lineContainer.appendChild(arrowStart);
                }

                // Line
                const line = document.createElement('div');
                line.className = 'edge-line';
                lineContainer.appendChild(line);

                // Arrow at end if forward
                if (edge.flowDirection === 'forward') {
                    const arrowEnd = document.createElement('div');
                    arrowEnd.className = 'edge-arrow';
                    lineContainer.appendChild(arrowEnd);
                }

                // Annotations container
                const annotations = document.createElement('div');
                annotations.className = 'edge-annotations';

                // Pre-processing annotation
                const preLabel = document.createElement('div');
                preLabel.className = 'annotation-label';
                preLabel.textContent = 'Pre-Processing';

                const preInput = document.createElement('input');
                preInput.type = 'text';
                preInput.className = 'annotation-input';
                preInput.placeholder = 'Add notes...';
                preInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre');
                preInput.addEventListener('input', debounce((e) => {
                    StateManager.updateAnnotation(flowIndex, edgeIndex, 'pre', e.target.value);
                    this.triggerSave();
                }, 300));

                // Post-processing annotation
                const postLabel = document.createElement('div');
                postLabel.className = 'annotation-label';
                postLabel.textContent = 'Post-Processing';

                const postInput = document.createElement('input');
                postInput.type = 'text';
                postInput.className = 'annotation-input';
                postInput.placeholder = 'Add notes...';
                postInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'post');
                postInput.addEventListener('input', debounce((e) => {
                    StateManager.updateAnnotation(flowIndex, edgeIndex, 'post', e.target.value);
                    this.triggerSave();
                }, 300));

                annotations.appendChild(preLabel);
                annotations.appendChild(preInput);
                annotations.appendChild(postLabel);
                annotations.appendChild(postInput);

                container.appendChild(protocolElement);
                container.appendChild(lineContainer);
                container.appendChild(annotations);

                return container;
            },

            updateProtocolInPattern(flowIndex, edgeIndex, oldProtocol, oldDirection, newCapability) {
                // Parse new capability to get protocol and direction
                const parts = newCapability.split(' ');
                if (parts.length < 2) return;
                
                const newDirection = parts[parts.length - 1];
                const newProtocol = parts.slice(0, -1).join(' ');
                
                // Get current pattern text
                const patternText = UIController.elements.patternEditor.value;
                const lines = patternText.split('\n');
                
                // Find the flow's line
                const result = Parser.parseMultiple(patternText);
                if (!result.flows || flowIndex >= result.flows.length) return;
                
                // Find which line contains this flow
                let flowLineIndex = -1;
                let currentFlowIndex = 0;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line || line.startsWith('//')) continue;
                    
                    const lineResult = Parser.parseMultiple(line);
                    if (lineResult.flows && lineResult.flows.length > 0) {
                        if (currentFlowIndex === flowIndex) {
                            flowLineIndex = i;
                            break;
                        }
                        currentFlowIndex++;
                    }
                }
                
                if (flowLineIndex === -1) return;
                
                // Parse the line to get segments
                const line = lines[flowLineIndex];
                const parseResult = Parser.parseMultiple(line);
                if (!parseResult.flows || parseResult.flows.length === 0) return;
                
                const flow = parseResult.flows[0];
                if (!flow.edges || edgeIndex >= flow.edges.length) return;
                
                // Rebuild the line by replacing the specific edge's protocol+direction
                const entities = flow.nodes.map(n => n.label);
                const edges = flow.edges;
                
                // Rebuild the line string: Entity -> Protocol Direction -> Entity <- Protocol Direction <- Entity
                const newLineParts = [entities[0]];
                
                for (let i = 0; i < edges.length; i++) {
                    const edge = edges[i];
                    const arrow = edge.flowDirection === 'reverse' ? '<-' : '->';
                    const protocol = (i === edgeIndex) ? newProtocol : edge.protocol;
                    const direction = (i === edgeIndex) ? newDirection : edge.direction;
                    
                    newLineParts.push(arrow);
                    newLineParts.push(`${protocol} ${direction}`);
                    newLineParts.push(arrow);
                    newLineParts.push(entities[i + 1]);
                }
                
                const newLine = newLineParts.join(' ');
                
                // Update the pattern text
                lines[flowLineIndex] = newLine;
                const updatedPattern = lines.join('\n');
                
                // Update the editor and trigger re-render
                UIController.elements.patternEditor.value = updatedPattern;
                UIController.updatePattern();
                UIController.setSaveIndicator('saving');
                Persistence.save();
                setTimeout(() => UIController.setSaveIndicator('saved'), 500);
            },

            triggerSave() {
                UIController.setSaveIndicator('saving');
                Persistence.save();
                setTimeout(() => UIController.setSaveIndicator('saved'), 500);
            }
        };

        // Make debounce available to DiagramRenderer
        DiagramRenderer.debounce = debounce;

        // ============================================
        // UI CONTROLLER
        // ============================================
        const UIController = {
            elements: {},

            init() {
                // Cache DOM elements
                this.elements = {
                    workspaceSelect: document.getElementById('workspaceSelect'),
                    patternEditor: document.getElementById('patternEditor'),
                    lineNumbers: document.getElementById('lineNumbers'),
                    generalNotesField: document.getElementById('generalNotesField'),
                    flowSelector: document.getElementById('flowSelector'),
                    errorMessage: document.getElementById('errorMessage'),
                    saveIndicator: document.getElementById('saveIndicator'),
                    saveText: document.getElementById('saveText'),
                    canvasContainer: document.getElementById('canvasContainer'),
                    emptyState: document.getElementById('emptyState'),
                    modalOverlay: document.getElementById('modalOverlay'),
                    modalTitle: document.getElementById('modalTitle'),
                    modalInput: document.getElementById('modalInput'),
                    modalConfirmBtn: document.getElementById('modalConfirmBtn'),
                    helpPanel: document.getElementById('helpPanel')
                };

                this.bindEvents();
            },

            bindEvents() {
                // Workspace controls
                document.getElementById('newWorkspaceBtn').addEventListener('click', () => {
                    this.showModal('New Workspace', 'Untitled Workspace', 'Create', (name) => {
                        WorkspaceManager.createWorkspace(name);
                        this.updateWorkspaceSelect();
                        this.loadActiveWorkspace();
                    });
                });

                document.getElementById('renameWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        this.showModal('Rename Workspace', ws.name, 'Rename', (name) => {
                            WorkspaceManager.renameWorkspace(ws.id, name);
                            this.updateWorkspaceSelect();
                        });
                    }
                });

                document.getElementById('duplicateWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        WorkspaceManager.duplicateWorkspace(ws.id);
                        this.updateWorkspaceSelect();
                        this.loadActiveWorkspace();
                    }
                });

                document.getElementById('deleteWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws && confirm(`Delete workspace "${ws.name}"?`)) {
                        WorkspaceManager.deleteWorkspace(ws.id);
                        this.updateWorkspaceSelect();
                        this.loadActiveWorkspace();
                    }
                });

                // Export workspace
                document.getElementById('exportWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        const exportData = {
                            version: 1,
                            exportedAt: new Date().toISOString(),
                            workspace: {
                                name: ws.name,
                                patternText: ws.patternText || '',
                                flowNotes: ws.flowNotes || {},
                                flowDescriptions: ws.flowDescriptions || {},
                                annotations: ws.annotations || {}
                            }
                        };
                        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${ws.name.replace(/[^a-z0-9]/gi, '_')}_workspace.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }
                });

                // Import workspace
                const importFileInput = document.getElementById('importFileInput');
                document.getElementById('importWorkspaceBtn').addEventListener('click', () => {
                    importFileInput.click();
                });

                importFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            if (!data.workspace || !data.workspace.name) {
                                throw new Error('Invalid workspace file format');
                            }

                            // Create new workspace with imported data
                            const newWorkspace = WorkspaceManager.createWorkspace(data.workspace.name + ' (imported)');
                            // Update the workspace with imported content
                            newWorkspace.patternText = data.workspace.patternText || '';
                            newWorkspace.flowNotes = data.workspace.flowNotes || {};
                            newWorkspace.flowDescriptions = data.workspace.flowDescriptions || {};
                            newWorkspace.annotations = data.workspace.annotations || {};
                            Persistence.save();

                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                            alert(`Workspace "${data.workspace.name}" imported successfully!`);
                        } catch (err) {
                            alert('Failed to import workspace: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                    // Reset input so same file can be imported again
                    importFileInput.value = '';
                });

                // Export PDF Report
                document.getElementById('exportPdfBtn').addEventListener('click', async () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (!ws) {
                        alert('No workspace selected');
                        return;
                    }

                    // Show loading indicator
                    const originalTitle = document.title;
                    document.title = 'Generating PDF...';
                    this.setSaveIndicator('saving');

                    try {
                        await this.exportToPDF(ws);
                    } catch (err) {
                        console.error('PDF export error:', err);
                        alert('Failed to generate PDF: ' + err.message);
                    } finally {
                        document.title = originalTitle;
                        this.setSaveIndicator('saved');
                    }
                });

                this.elements.workspaceSelect.addEventListener('change', (e) => {
                    StateManager.setActiveWorkspace(e.target.value);
                    this.loadActiveWorkspace();
                });

                // Pattern editor
                const debouncedUpdate = debounce(() => {
                    this.updatePattern();
                    this.setSaveIndicator('saving');
                    Persistence.save();
                    setTimeout(() => this.setSaveIndicator('saved'), 500);
                }, 300);

                this.elements.patternEditor.addEventListener('input', () => {
                    this.updateLineNumbers();
                    debouncedUpdate();
                });

                // Sync line numbers scroll with textarea scroll
                this.elements.patternEditor.addEventListener('scroll', () => {
                    this.elements.lineNumbers.scrollTop = this.elements.patternEditor.scrollTop;
                });

                // Initial line numbers update
                this.updateLineNumbers();

                // Flow selector
                this.elements.flowSelector.addEventListener('change', (e) => {
                    const flowIndex = e.target.value === '' ? null : parseInt(e.target.value);
                    DiagramRenderer.selectFlow(flowIndex);
                });

                // General notes field
                const debouncedNotesUpdate = debounce(() => {
                    const flowIndex = DiagramRenderer.selectedFlowIndex;
                    if (flowIndex !== null) {
                        StateManager.updateFlowNotes(flowIndex, this.elements.generalNotesField.value);
                        this.setSaveIndicator('saving');
                        Persistence.save();
                        setTimeout(() => this.setSaveIndicator('saved'), 500);
                    }
                }, 300);

                this.elements.generalNotesField.addEventListener('input', debouncedNotesUpdate);

                // Theme toggle
                document.getElementById('themeToggleBtn').addEventListener('click', () => {
                    const newTheme = StateManager.state.theme === 'light' ? 'dark' : 'light';
                    StateManager.setTheme(newTheme);
                    document.body.setAttribute('data-theme', newTheme);
                    this.updateThemeIcon();
                    Persistence.save();
                });

                // Help panel
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.elements.helpPanel.classList.add('visible');
                });

                document.getElementById('closeHelpBtn').addEventListener('click', () => {
                    this.elements.helpPanel.classList.remove('visible');
                });

                // Modal
                document.getElementById('modalCancelBtn').addEventListener('click', () => {
                    this.hideModal();
                });

                this.elements.modalInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.elements.modalConfirmBtn.click();
                    } else if (e.key === 'Escape') {
                        this.hideModal();
                    }
                });

                // Click outside modal to close
                this.elements.modalOverlay.addEventListener('click', (e) => {
                    if (e.target === this.elements.modalOverlay) {
                        this.hideModal();
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                        e.preventDefault();
                        document.getElementById('themeToggleBtn').click();
                    } else if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        document.getElementById('newWorkspaceBtn').click();
                    }
                });
            },

            updateWorkspaceSelect() {
                const select = this.elements.workspaceSelect;
                select.innerHTML = '';

                StateManager.state.workspaces.forEach((ws, id) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = ws.name;
                    option.selected = id === StateManager.state.activeWorkspaceId;
                    select.appendChild(option);
                });
            },

            loadActiveWorkspace() {
                const ws = StateManager.getActiveWorkspace();
                if (ws) {
                    this.elements.patternEditor.value = ws.patternText || '';
                    DiagramRenderer.selectedFlowIndex = null;
                    this.updateLineNumbers();
                    this.updatePattern();
                }
            },

            updatePattern() {
                const text = this.elements.patternEditor.value;
                StateManager.updatePattern(text);

                const result = Parser.parseMultiple(text);

                if (result.errors.length > 0) {
                    this.showErrors(result.errors);
                } else {
                    this.hideError();
                }

                DiagramRenderer.render(result.flows, this.elements.canvasContainer);
            },

            showErrors(errors) {
                const errorHtml = errors.map(e =>
                    `<div class="error-line">Line ${e.line}: ${e.message}</div>`
                ).join('');
                this.elements.errorMessage.innerHTML = errorHtml;
                this.elements.errorMessage.classList.add('visible');
            },

            hideError() {
                this.elements.errorMessage.classList.remove('visible');
            },

            updateLineNumbers() {
                const text = this.elements.patternEditor.value;
                const lines = text.split('\n');
                const lineCount = lines.length || 1;
                
                // Generate line numbers HTML
                let lineNumbersHtml = '';
                for (let i = 1; i <= lineCount; i++) {
                    lineNumbersHtml += `<span>${i}</span>`;
                }
                
                this.elements.lineNumbers.innerHTML = lineNumbersHtml;
            },

            setSaveIndicator(status) {
                const indicator = this.elements.saveIndicator;
                indicator.classList.remove('saving', 'saved');
                indicator.classList.add(status);
                this.elements.saveText.textContent = status === 'saving' ? 'Saving...' : 'Saved';
            },

            async exportToPDF(workspace) {
                // Show loading overlay
                const loadingOverlay = document.getElementById('loadingOverlay');
                loadingOverlay.classList.add('visible');

                try {
                    await this._generatePDF(workspace);
                } catch (error) {
                    console.error('PDF generation failed:', error);
                    alert('Failed to generate PDF. Please try again.');
                } finally {
                    // Hide loading overlay
                    loadingOverlay.classList.remove('visible');
                }
            },

            async _generatePDF(workspace) {
                // Check if libraries are available
                if (typeof html2canvas === 'undefined' || typeof window.jspdf === 'undefined') {
                    alert('PDF libraries not loaded. Please refresh the page and try again.');
                    return;
                }

                // Parse flows to get current state
                const patternText = workspace.patternText || '';
                const result = Parser.parseMultiple(patternText);
                const flows = result.flows || [];

                // Create a temporary container for PDF content
                const pdfContainer = document.createElement('div');
                pdfContainer.id = 'pdf-export-container';
                // Position it absolutely off-screen but visible to html2canvas
                pdfContainer.style.position = 'absolute';
                pdfContainer.style.top = '0';
                pdfContainer.style.left = '-2000px'; // Off-screen but not too far
                pdfContainer.style.width = '794px'; // A4 width in pixels (210mm at 96 DPI)
                pdfContainer.style.padding = '40px';
                pdfContainer.style.backgroundColor = '#ffffff';
                pdfContainer.style.fontFamily = 'Arial, sans-serif';
                pdfContainer.style.color = '#333333';
                pdfContainer.style.zIndex = '99999';
                pdfContainer.style.boxSizing = 'border-box';
                pdfContainer.style.overflow = 'visible';
                pdfContainer.style.display = 'block';
                document.body.appendChild(pdfContainer);

                try {
                    // Cover page
                    const coverPage = document.createElement('div');
                    coverPage.className = 'pdf-cover-page';
                    coverPage.style.display = 'flex';
                    coverPage.style.flexDirection = 'column';
                    coverPage.style.alignItems = 'center';
                    coverPage.style.justifyContent = 'center';
                    coverPage.style.minHeight = '714px'; // A4 height minus padding in pixels (~270mm)
                    coverPage.style.height = '714px';
                    coverPage.style.textAlign = 'center';
                    coverPage.style.backgroundColor = '#ffffff';
                    coverPage.style.marginBottom = '20px';

                    // Logo (using SVG data URL for better PDF compatibility)
                    const logoContainer = document.createElement('div');
                    logoContainer.style.marginBottom = '40px';
                    const logoSvg = document.createElement('div');
                    logoSvg.innerHTML = `<svg width="200" height="68" viewBox="0 0 137 47" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M76.6496 46.9993L80.5925 37.9543L73.4876 22.7627H78.5529L83.0057 32.9377L87.1186 22.7627H91.9465L81.4423 46.9993H76.6496ZM69.4101 33.1143V32.3377L65.6372 32.9377C64.4811 33.1143 63.5639 33.7843 63.5639 35.1277C63.5639 36.1527 64.2774 37.1427 65.7382 37.1427C67.6431 37.1427 69.4101 36.1893 69.4101 33.1143ZM64.0401 30.1477L68.153 29.511C69.1038 29.3693 69.4101 28.8743 69.4101 28.2743C69.4101 27.0377 68.4929 26.0127 66.5896 26.0127C64.6174 26.0127 63.5286 27.3193 63.3923 28.8393L59.3805 27.956C59.6531 25.2343 62.0663 22.2327 66.5543 22.2327C71.8585 22.2327 73.8292 25.341 73.8292 28.8393V37.3893C73.8292 38.3077 73.9318 39.546 74.0328 40.146H69.8863C69.7853 39.686 69.7163 38.7327 69.7163 38.061C68.8665 39.4393 67.2679 40.641 64.7873 40.641C61.2181 40.641 59.0422 38.1327 59.0422 35.411C59.0422 32.3027 61.2517 30.571 64.0401 30.1477ZM48.2686 22.7627L51.8716 33.9627L54.9662 22.7627H59.4511L54.2174 40.146H49.6957L45.7865 28.2743L41.9446 40.146H37.3555L32.0193 22.7627H36.7783L39.8713 33.9277L43.5096 22.7627H48.2686ZM21.4157 31.4177L15.4653 22.7627H20.8368C21.4157 23.716 23.5899 26.966 24.1688 27.921L27.4655 22.7627H32.5981L26.7519 31.2777L32.8017 40.146H27.4991L23.9972 34.811C23.3863 35.7643 21.1431 39.1927 20.5642 40.146H15.4653L21.4157 31.4177ZM10.3679 33.1143V32.3377L6.59659 32.9377C5.4405 33.1143 4.52172 33.7843 4.52172 35.1277C4.52172 36.1527 5.23526 37.1427 6.696 37.1427C8.6009 37.1427 10.3679 36.1893 10.3679 33.1143ZM4.99635 30.1477L9.11079 29.511C10.0632 29.3693 10.3679 28.8743 10.3679 28.2743C10.3679 27.0377 9.45072 26.0127 7.54583 26.0127C5.57519 26.0127 4.48805 27.3193 4.35176 28.8393L0.339931 27.956C0.612517 25.2343 3.02571 22.2327 7.51376 22.2327C12.8148 22.2327 14.787 25.341 14.787 28.8393V37.3893C14.787 38.3077 14.888 39.546 14.9922 40.146H10.8441C10.7415 39.686 10.6742 38.7327 10.6742 38.061C9.82433 39.4393 8.22569 40.641 5.74516 40.641C2.17588 40.641 0 38.1327 0 35.411C0 32.3027 2.20955 30.571 4.99635 30.1477Z" fill="#4A4F54"/><path fill-rule="evenodd" clip-rule="evenodd" d="M132.708 26.3917L99.0455 10.7197V16.3933L125.843 28.8685L132.708 26.3917ZM103.04 21.0861V26.7581L109.161 29.5933L99.3136 39.7965H105.843L117.528 27.8269L103.04 21.0861ZM132.698 15.0525L132.71 23.5661L94.4803 5.75807V0.0844727L127.93 15.6749V7.15647L136.703 11.2413V16.9181L132.698 15.0525Z" fill="#E82C2A"/></svg>`;
                    logoContainer.appendChild(logoSvg);
                    coverPage.appendChild(logoContainer);

                    // Title
                    const title = document.createElement('h1');
                    title.textContent = 'MFT Flow Visualizer';
                    title.style.fontSize = '36px';
                    title.style.fontWeight = 'bold';
                    title.style.color = '#2c3e50';
                    title.style.marginBottom = '20px';
                    title.style.marginTop = '0';
                    coverPage.appendChild(title);

                    // Subtitle
                    const subtitle = document.createElement('h2');
                    subtitle.textContent = 'Flow Analysis Report';
                    subtitle.style.fontSize = '24px';
                    subtitle.style.fontWeight = 'normal';
                    subtitle.style.color = '#7f8c8d';
                    subtitle.style.marginBottom = '60px';
                    subtitle.style.marginTop = '0';
                    coverPage.appendChild(subtitle);

                    // Workspace name
                    const workspaceName = document.createElement('div');
                    workspaceName.style.fontSize = '28px';
                    workspaceName.style.fontWeight = '600';
                    workspaceName.style.color = '#34495e';
                    workspaceName.style.marginBottom = '40px';
                    workspaceName.textContent = workspace.name;
                    coverPage.appendChild(workspaceName);

                    // Date
                    const date = document.createElement('div');
                    date.style.fontSize = '14px';
                    date.style.color = '#95a5a6';
                    date.textContent = `Generated on ${new Date().toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    })}`;
                    coverPage.appendChild(date);

                    pdfContainer.appendChild(coverPage);

                    // Flow diagrams and notes
                    if (flows.length === 0) {
                        const noFlows = document.createElement('div');
                        noFlows.style.padding = '40px';
                        noFlows.style.textAlign = 'center';
                        noFlows.style.color = '#7f8c8d';
                        noFlows.textContent = 'No flows defined in this workspace.';
                        pdfContainer.appendChild(noFlows);
                    } else {
                        flows.forEach((flow, flowIndex) => {
                            const flowSection = document.createElement('div');
                            flowSection.className = 'pdf-flow-section';
                            flowSection.style.marginBottom = '40px';
                            flowSection.style.backgroundColor = '#ffffff';
                            flowSection.style.paddingBottom = '20px';

                            // Flow header
                            const flowHeader = document.createElement('h2');
                            flowHeader.textContent = `Flow ${flowIndex + 1}`;
                            flowHeader.style.fontSize = '20px';
                            flowHeader.style.fontWeight = 'bold';
                            flowHeader.style.color = '#2c3e50';
                            flowHeader.style.marginBottom = '15px';
                            flowHeader.style.borderBottom = '2px solid #3498db';
                            flowHeader.style.paddingBottom = '10px';
                            flowSection.appendChild(flowHeader);

                            // Flow diagram (clone the rendered flow - simplified version)
                            const canvasContainer = this.elements.canvasContainer;
                            const flowRow = canvasContainer.querySelector(`.flow-row:nth-child(${flowIndex + 1})`);
                            if (flowRow) {
                                const diagramClone = flowRow.cloneNode(true);
                                diagramClone.style.marginBottom = '20px';
                                diagramClone.style.display = 'inline-flex';
                                diagramClone.style.padding = '20px';
                                diagramClone.style.backgroundColor = '#ffffff';
                                diagramClone.style.transformOrigin = 'left top';
                                
                                // Remove all text fields - they are shown below as formatted text
                                // Remove before source / after target description fields
                                diagramClone.querySelectorAll('.flow-description-field').forEach(el => el.remove());
                                // Remove annotation sections (pre/post processing inputs)
                                diagramClone.querySelectorAll('.edge-annotations').forEach(el => el.remove());
                                // Remove "Flow X" row number indicator (already shown as section title)
                                diagramClone.querySelectorAll('.flow-row-number').forEach(el => el.remove());
                                
                                // Fix arrow lines - use solid dark color instead of CSS variable gradient
                                // The gradient with CSS variables doesn't render well in html2canvas
                                diagramClone.querySelectorAll('.edge-line').forEach(el => {
                                    el.style.backgroundImage = 'none';
                                    el.style.backgroundColor = '#2c3e50';
                                    el.style.animation = 'none';
                                });
                                
                                // Fix arrow heads - use solid dark color
                                diagramClone.querySelectorAll('.edge-arrow').forEach(el => {
                                    // Check if it's a reverse arrow
                                    if (el.classList.contains('reverse')) {
                                        el.style.borderRightColor = '#2c3e50';
                                    } else {
                                        el.style.borderLeftColor = '#2c3e50';
                                    }
                                });
                                
                                // Replace select dropdowns with simple text
                                diagramClone.querySelectorAll('select').forEach(el => {
                                    const text = document.createElement('span');
                                    text.textContent = el.value || el.options[0]?.textContent || '';
                                    text.style.fontStyle = 'italic';
                                    text.style.color = '#e74c3c';
                                    el.parentNode.replaceChild(text, el);
                                });
                                // Remove any remaining inputs and buttons
                                diagramClone.querySelectorAll('input').forEach(el => el.remove());
                                diagramClone.querySelectorAll('textarea').forEach(el => el.remove());
                                diagramClone.querySelectorAll('button').forEach(el => el.remove());
                                
                                // Create a wrapper to handle scaling for wide diagrams
                                const diagramWrapper = document.createElement('div');
                                diagramWrapper.style.width = '100%';
                                diagramWrapper.style.overflow = 'hidden';
                                diagramWrapper.style.marginBottom = '20px';
                                diagramWrapper.appendChild(diagramClone);
                                flowSection.appendChild(diagramWrapper);
                                
                                // After adding to DOM, check if we need to scale down
                                // We'll do this after all sections are added
                                diagramWrapper.dataset.needsScaling = 'true';
                            }

                            // Flow descriptions (before source / after target)
                            const beforeSource = workspace.flowDescriptions?.[`${flowIndex}-beforeSource`];
                            const afterTarget = workspace.flowDescriptions?.[`${flowIndex}-afterTarget`];
                            
                            if (beforeSource || afterTarget) {
                                const descSection = document.createElement('div');
                                descSection.style.marginTop = '20px';
                                descSection.style.marginBottom = '20px';
                                descSection.style.display = 'flex';
                                descSection.style.gap = '20px';
                                descSection.style.flexWrap = 'wrap';

                                if (beforeSource) {
                                    const beforeDiv = document.createElement('div');
                                    beforeDiv.style.flex = '1';
                                    beforeDiv.style.minWidth = '200px';
                                    
                                    const beforeLabel = document.createElement('div');
                                    beforeLabel.textContent = 'Before Source:';
                                    beforeLabel.style.fontWeight = 'bold';
                                    beforeLabel.style.marginBottom = '8px';
                                    beforeLabel.style.color = '#27ae60';
                                    beforeDiv.appendChild(beforeLabel);

                                    const beforeContent = document.createElement('div');
                                    beforeContent.textContent = beforeSource;
                                    beforeContent.style.padding = '12px';
                                    beforeContent.style.backgroundColor = '#f0fff4';
                                    beforeContent.style.borderLeft = '4px solid #27ae60';
                                    beforeContent.style.whiteSpace = 'pre-wrap';
                                    beforeContent.style.lineHeight = '1.6';
                                    beforeDiv.appendChild(beforeContent);

                                    descSection.appendChild(beforeDiv);
                                }

                                if (afterTarget) {
                                    const afterDiv = document.createElement('div');
                                    afterDiv.style.flex = '1';
                                    afterDiv.style.minWidth = '200px';
                                    
                                    const afterLabel = document.createElement('div');
                                    afterLabel.textContent = 'After Target:';
                                    afterLabel.style.fontWeight = 'bold';
                                    afterLabel.style.marginBottom = '8px';
                                    afterLabel.style.color = '#e74c3c';
                                    afterDiv.appendChild(afterLabel);

                                    const afterContent = document.createElement('div');
                                    afterContent.textContent = afterTarget;
                                    afterContent.style.padding = '12px';
                                    afterContent.style.backgroundColor = '#fff5f5';
                                    afterContent.style.borderLeft = '4px solid #e74c3c';
                                    afterContent.style.whiteSpace = 'pre-wrap';
                                    afterContent.style.lineHeight = '1.6';
                                    afterDiv.appendChild(afterContent);

                                    descSection.appendChild(afterDiv);
                                }

                                flowSection.appendChild(descSection);
                            }

                            // Flow notes
                            const flowNotes = workspace.flowNotes?.[flowIndex];
                            if (flowNotes) {
                                const notesSection = document.createElement('div');
                                notesSection.style.marginTop = '20px';
                                notesSection.style.marginBottom = '20px';
                                
                                const notesLabel = document.createElement('div');
                                notesLabel.textContent = 'General Notes:';
                                notesLabel.style.fontWeight = 'bold';
                                notesLabel.style.marginBottom = '8px';
                                notesLabel.style.color = '#34495e';
                                notesSection.appendChild(notesLabel);

                                const notesContent = document.createElement('div');
                                notesContent.textContent = flowNotes || '';
                                notesContent.style.padding = '12px';
                                notesContent.style.backgroundColor = '#f8f9fa';
                                notesContent.style.borderLeft = '4px solid #3498db';
                                notesContent.style.whiteSpace = 'pre-wrap';
                                notesContent.style.lineHeight = '1.6';
                                notesContent.style.wordWrap = 'break-word';
                                notesSection.appendChild(notesContent);

                                flowSection.appendChild(notesSection);
                            }

                            // Annotations for each edge
                            if (flow.edges) {
                                flow.edges.forEach((edge, edgeIndex) => {
                                    const preAnnotation = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre');
                                    const postAnnotation = StateManager.getAnnotation(flowIndex, edgeIndex, 'post');
                                    
                                    if (preAnnotation || postAnnotation) {
                                        const annotationSection = document.createElement('div');
                                        annotationSection.style.marginTop = '15px';
                                        annotationSection.style.marginBottom = '15px';

                                        const annotationLabel = document.createElement('div');
                                        annotationLabel.textContent = `Edge ${edgeIndex + 1}: ${edge.protocol} ${edge.direction}`;
                                        annotationLabel.style.fontWeight = '600';
                                        annotationLabel.style.marginBottom = '8px';
                                        annotationLabel.style.color = '#34495e';
                                        annotationSection.appendChild(annotationLabel);

                                        if (preAnnotation) {
                                            const preDiv = document.createElement('div');
                                            preDiv.style.marginBottom = '8px';
                                            const preLabel = document.createElement('strong');
                                            preLabel.textContent = 'Pre-Processing: ';
                                            const preText = document.createElement('span');
                                            preText.style.color = '#555';
                                            preText.textContent = preAnnotation;
                                            preDiv.appendChild(preLabel);
                                            preDiv.appendChild(preText);
                                            annotationSection.appendChild(preDiv);
                                        }

                                        if (postAnnotation) {
                                            const postDiv = document.createElement('div');
                                            const postLabel = document.createElement('strong');
                                            postLabel.textContent = 'Post-Processing: ';
                                            const postText = document.createElement('span');
                                            postText.style.color = '#555';
                                            postText.textContent = postAnnotation;
                                            postDiv.appendChild(postLabel);
                                            postDiv.appendChild(postText);
                                            annotationSection.appendChild(postDiv);
                                        }

                                        flowSection.appendChild(annotationSection);
                                    }
                                });
                            }

                            pdfContainer.appendChild(flowSection);
                        });
                    }

                    // Debug: Check if content was added
                    console.log('PDF container children:', pdfContainer.children.length);
                    console.log('PDF container HTML length:', pdfContainer.innerHTML.length);
                    
                    // Force a reflow to ensure content is rendered
                    pdfContainer.style.display = 'block';
                    
                    // Scale down wide diagrams to fit PDF page width (with more margin for safety)
                    const maxDiagramWidth = 700;
                    pdfContainer.querySelectorAll('[data-needs-scaling="true"]').forEach(wrapper => {
                        const diagram = wrapper.querySelector('.flow-row');
                        if (diagram) {
                            // Temporarily set to auto width to measure natural size
                            diagram.style.width = 'auto';
                            const naturalWidth = diagram.scrollWidth;
                            
                            if (naturalWidth > maxDiagramWidth) {
                                const scale = maxDiagramWidth / naturalWidth;
                                diagram.style.transform = `scale(${scale})`;
                                diagram.style.transformOrigin = 'left top';
                                // Adjust wrapper height to account for scaled content
                                wrapper.style.height = `${diagram.scrollHeight * scale}px`;
                                console.log(`Scaled diagram from ${naturalWidth}px to fit ${maxDiagramWidth}px (scale: ${scale.toFixed(2)})`);
                            }
                        }
                    });
                    
                    const height = pdfContainer.offsetHeight || pdfContainer.scrollHeight;
                    const width = pdfContainer.offsetWidth || pdfContainer.scrollWidth;
                    console.log('Container dimensions:', width, 'x', height);
                    console.log('First child:', pdfContainer.firstElementChild?.tagName, pdfContainer.firstElementChild?.textContent?.substring(0, 50));

                    // Ensure container has content
                    if (pdfContainer.children.length === 0) {
                        throw new Error('No content to export. PDF container is empty.');
                    }

                    if (height === 0) {
                        console.warn('Container height is 0, but content exists. Trying to fix...');
                        pdfContainer.style.height = 'auto';
                        pdfContainer.style.minHeight = '100px';
                    }

                    // Wait for rendering and images to load
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Re-check dimensions after wait
                    const finalHeight = pdfContainer.offsetHeight || pdfContainer.scrollHeight;
                    const finalWidth = pdfContainer.offsetWidth || pdfContainer.scrollWidth;
                    console.log('Final container dimensions:', finalWidth, 'x', finalHeight);

                    // Generate PDF
                    // Calculate actual content dimensions after rendering
                    const contentHeight = Math.max(pdfContainer.scrollHeight, pdfContainer.offsetHeight);
                    const contentWidth = Math.max(pdfContainer.scrollWidth, pdfContainer.offsetWidth);
                    
                    console.log('Content dimensions:', contentWidth, 'x', contentHeight);
                    console.log('Container innerHTML length:', pdfContainer.innerHTML.length);
                    
                    // Verify content exists
                    if (contentHeight === 0) {
                        throw new Error('No content to export. Container height is 0.');
                    }
                    
                    // Temporarily move container into viewport for html2canvas to capture it
                    // Store original position
                    const originalLeft = pdfContainer.style.left;
                    const originalTop = pdfContainer.style.top;
                    const originalZIndex = pdfContainer.style.zIndex;
                    const originalPosition = pdfContainer.style.position;
                    
                    // Move to top-left of viewport - keep it visible but off to the side
                    pdfContainer.style.position = 'fixed';
                    pdfContainer.style.left = '0';
                    pdfContainer.style.top = '0';
                    pdfContainer.style.zIndex = '999999';
                    pdfContainer.style.opacity = '1';
                    pdfContainer.style.visibility = 'visible';
                    pdfContainer.style.display = 'block';
                    pdfContainer.style.pointerEvents = 'none';
                    pdfContainer.style.overflow = 'visible';
                    pdfContainer.style.maxHeight = 'none';
                    pdfContainer.style.height = 'auto';
                    pdfContainer.style.width = '794px';
                    
                    // Ensure all text and elements are visible and have proper colors
                    const allElements = pdfContainer.querySelectorAll('*');
                    allElements.forEach(el => {
                        const computed = window.getComputedStyle(el);
                        // Force visibility
                        if (computed.display === 'none') {
                            el.style.display = 'block';
                        }
                        if (computed.visibility === 'hidden') {
                            el.style.visibility = 'visible';
                        }
                        if (computed.opacity === '0') {
                            el.style.opacity = '1';
                        }
                        // Ensure text is visible
                        if (el.tagName && ['H1', 'H2', 'H3', 'P', 'DIV', 'SPAN'].includes(el.tagName)) {
                            if (!el.style.color || el.style.color === 'transparent') {
                                el.style.color = '#333333';
                            }
                        }
                    });
                    
                    // Force multiple reflows to ensure rendering
                    pdfContainer.offsetHeight;
                    pdfContainer.scrollHeight;
                    pdfContainer.offsetWidth;
                    pdfContainer.scrollWidth;
                    
                    // Wait longer for browser to fully render everything
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Verify content is actually visible and rendered
                    const testElement = pdfContainer.querySelector('h1');
                    if (testElement) {
                        const rect = testElement.getBoundingClientRect();
                        const computed = window.getComputedStyle(testElement);
                        console.log('Test element rect:', rect.width, 'x', rect.height);
                        console.log('Test element computed color:', computed.color);
                        console.log('Test element computed display:', computed.display);
                        console.log('Test element computed visibility:', computed.visibility);
                        console.log('Test element text:', testElement.textContent?.substring(0, 50));
                        
                        if (rect.width === 0 || rect.height === 0) {
                            console.error('Content elements have zero dimensions!');
                            throw new Error('Content is not rendering properly');
                        }
                    }
                    
                    try {
                        console.log('Starting PDF generation with direct html2canvas + jsPDF...');
                        console.log('Container position:', pdfContainer.style.left, pdfContainer.style.top);
                        console.log('Container dimensions:', pdfContainer.offsetWidth, 'x', pdfContainer.offsetHeight);
                        
                        // Create PDF using jsPDF
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: 'portrait',
                            unit: 'mm',
                            format: 'a4'
                        });
                        
                        // A4 dimensions
                        const pageWidth = 210;
                        const pageHeight = 297;
                        const margin = 15;
                        const contentWidth = pageWidth - (margin * 2);
                        
                        // Get all sections to render separately (cover page + flow sections)
                        const sections = pdfContainer.querySelectorAll('.pdf-cover-page, .pdf-flow-section');
                        console.log('Found sections to render:', sections.length);
                        
                        if (sections.length === 0) {
                            // Fallback: render entire container but with scale limit
                            const maxHeight = 5000; // Limit height to avoid memory issues
                            const canvas = await html2canvas(pdfContainer, {
                                scale: 1,
                                useCORS: true,
                                logging: false,
                                backgroundColor: '#ffffff',
                                height: Math.min(pdfContainer.scrollHeight, maxHeight)
                            });
                            
                            const imgData = canvas.toDataURL('image/jpeg', 0.9);
                            const imgWidth = contentWidth;
                            const imgHeight = (canvas.height * imgWidth) / canvas.width;
                            pdf.addImage(imgData, 'JPEG', margin, margin, imgWidth, imgHeight);
                        } else {
                            // Render each section separately
                            let isFirstPage = true;
                            
                            for (let i = 0; i < sections.length; i++) {
                                const section = sections[i];
                                console.log(`Rendering section ${i + 1}/${sections.length}:`, section.className);
                                
                                // Capture this section
                                const canvas = await html2canvas(section, {
                                    scale: 1.5,
                                    useCORS: true,
                                    logging: false,
                                    backgroundColor: '#ffffff'
                                });
                                
                                console.log(`Section ${i + 1} canvas:`, canvas.width, 'x', canvas.height);
                                
                                if (canvas.width === 0 || canvas.height === 0) {
                                    console.warn(`Section ${i + 1} has zero dimensions, skipping`);
                                    continue;
                                }
                                
                                const imgData = canvas.toDataURL('image/jpeg', 0.9);
                                
                                if (imgData.length < 100) {
                                    console.warn(`Section ${i + 1} image data too small, skipping`);
                                    continue;
                                }
                                
                                // Calculate dimensions
                                const imgWidth = contentWidth;
                                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                                
                                // Add new page if not first
                                if (!isFirstPage) {
                                    pdf.addPage();
                                }
                                isFirstPage = false;
                                
                                // Add image, handling multi-page sections
                                let yPosition = margin;
                                let remainingHeight = imgHeight;
                                const availableHeight = pageHeight - (margin * 2);
                                
                                if (imgHeight <= availableHeight) {
                                    // Fits on one page
                                    pdf.addImage(imgData, 'JPEG', margin, yPosition, imgWidth, imgHeight);
                                } else {
                                    // Need to split across pages
                                    const ratio = canvas.width / imgWidth;
                                    let sourceY = 0;
                                    
                                    while (remainingHeight > 0) {
                                        const sliceHeight = Math.min(remainingHeight, availableHeight);
                                        const sourceSliceHeight = sliceHeight * ratio;
                                        
                                        // Create a slice canvas
                                        const sliceCanvas = document.createElement('canvas');
                                        sliceCanvas.width = canvas.width;
                                        sliceCanvas.height = sourceSliceHeight;
                                        const sliceCtx = sliceCanvas.getContext('2d');
                                        sliceCtx.fillStyle = '#ffffff';
                                        sliceCtx.fillRect(0, 0, sliceCanvas.width, sliceCanvas.height);
                                        sliceCtx.drawImage(canvas, 0, sourceY, canvas.width, sourceSliceHeight, 0, 0, canvas.width, sourceSliceHeight);
                                        
                                        const sliceImgData = sliceCanvas.toDataURL('image/jpeg', 0.9);
                                        pdf.addImage(sliceImgData, 'JPEG', margin, margin, imgWidth, sliceHeight);
                                        
                                        sourceY += sourceSliceHeight;
                                        remainingHeight -= sliceHeight;
                                        
                                        if (remainingHeight > 0) {
                                            pdf.addPage();
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Save the PDF
                        const filename = `${workspace.name.replace(/[^a-z0-9]/gi, '_')}_report.pdf`;
                        pdf.save(filename);
                        console.log('PDF saved:', filename);
                        
                    } catch (error) {
                        console.error('PDF generation error:', error);
                        console.error('Error stack:', error.stack);
                        alert('Failed to generate PDF: ' + error.message + '\n\nCheck browser console for details.');
                        throw error;
                    } finally {
                        // Restore original position
                        pdfContainer.style.left = originalLeft;
                        pdfContainer.style.top = originalTop;
                        pdfContainer.style.zIndex = originalZIndex;
                        pdfContainer.style.position = originalPosition;
                        pdfContainer.style.opacity = '1';
                        pdfContainer.style.pointerEvents = 'auto';
                    }
                } finally {
                    // Clean up
                    setTimeout(() => {
                        const container = document.getElementById('pdf-export-container');
                        if (container && container.parentNode) {
                            document.body.removeChild(container);
                        }
                    }, 1000);
                }
            },

            showModal(title, defaultValue, confirmText, onConfirm) {
                this.elements.modalTitle.textContent = title;
                this.elements.modalInput.value = defaultValue;
                this.elements.modalConfirmBtn.textContent = confirmText;
                this.elements.modalOverlay.classList.add('visible');
                this.elements.modalInput.focus();
                this.elements.modalInput.select();

                const confirmHandler = () => {
                    const value = this.elements.modalInput.value.trim();
                    if (value) {
                        onConfirm(value);
                        this.hideModal();
                    }
                };

                this.elements.modalConfirmBtn.onclick = confirmHandler;
            },

            hideModal() {
                this.elements.modalOverlay.classList.remove('visible');
            },

            updateThemeIcon() {
                const icon = document.getElementById('themeIcon');
                if (StateManager.state.theme === 'dark') {
                    icon.innerHTML = `
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    `;
                } else {
                    icon.innerHTML = `
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    `;
                }
            }
        };

        // ============================================
        // ============================================
        // APPLICATION INITIALIZATION
        // ============================================
        function initApp() {
            // Initialize workspace manager (loads from storage or creates default)
            WorkspaceManager.initialize();

            // Apply saved theme
            document.body.setAttribute('data-theme', StateManager.state.theme);

            // Initialize UI
            UIController.init();
            UIController.updateWorkspaceSelect();
            UIController.loadActiveWorkspace();
            UIController.updateThemeIcon();
        }

        // Start the application when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>

</html>