<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MFT Flow Visualizer</title>
    <style>
        /* ============================================
           CSS VARIABLES & THEMES
           ============================================ */
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            --transition-speed: 0.2s;
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Light Theme */
        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --node-source: #dbeafe;
            --node-source-border: #3b82f6;
            --node-intermediate: #f1f5f9;
            --node-intermediate-border: #64748b;
            --node-target: #dcfce7;
            --node-target-border: #10b981;
            --edge-color: #64748b;
            --canvas-bg: #fafafa;
            --gradient-start: #f0f4ff;
            --gradient-end: #faf5ff;
            --annotation-bg: #fffbeb;
            --annotation-border: #fcd34d;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --accent-primary: #60a5fa;
            --accent-secondary: #34d399;
            --accent-warning: #fbbf24;
            --accent-danger: #f87171;
            --node-source: #1e3a5f;
            --node-source-border: #60a5fa;
            --node-intermediate: #334155;
            --node-intermediate-border: #94a3b8;
            --node-target: #14532d;
            --node-target-border: #34d399;
            --edge-color: #94a3b8;
            --canvas-bg: #0f172a;
            --gradient-start: #1e1b4b;
            --gradient-end: #1e293b;
            --annotation-bg: #422006;
            --annotation-border: #b45309;
        }

        /* ============================================
           BASE STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: var(--text-primary);
            transition: background var(--transition-speed), color var(--transition-speed);
        }

        /* Grainy texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* ============================================
           LAYOUT
           ============================================ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* ============================================
           HEADER
           ============================================ */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        /* Grayscale Interlacing Waves - Soft Surreal Art */
        .header-gradient {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            mask-image: linear-gradient(to left, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 80%, rgba(0, 0, 0, 0.4) 95%, transparent 100%);
            -webkit-mask-image: linear-gradient(to left, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 80%, rgba(0, 0, 0, 0.4) 95%, transparent 100%);
        }

        /* Soft grayscale gradient background */
        .header-gradient-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(165deg, #e8e8e8 0%, #d4d4d4 30%, #a8a8a8 70%, #888888 100%);
        }

        /* SVG Sine Waves Container */
        .header-sine-waves {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .header-sine-waves svg {
            position: absolute;
            width: 250%;
            height: 100%;
            left: -75%;
        }

        /* Wave 1 - Light gray, soft */
        .sine-wave-1 {
            animation: sineMove1 20s ease-in-out infinite;
        }

        .sine-wave-1 path {
            fill: none;
            stroke: url(#waveGradient1);
            stroke-width: 6;
            filter: blur(2px);
            opacity: 0.8;
        }

        /* Wave 2 - Mid gray */
        .sine-wave-2 {
            animation: sineMove2 25s ease-in-out infinite;
        }

        .sine-wave-2 path {
            fill: none;
            stroke: url(#waveGradient2);
            stroke-width: 5;
            filter: blur(1.5px);
            opacity: 0.7;
        }

        /* Wave 3 - Darker gray */
        .sine-wave-3 {
            animation: sineMove3 30s ease-in-out infinite;
        }

        .sine-wave-3 path {
            fill: none;
            stroke: url(#waveGradient3);
            stroke-width: 4;
            filter: blur(1px);
            opacity: 0.6;
        }

        /* Wave 4 - Soft white highlight */
        .sine-wave-4 {
            animation: sineMove4 18s ease-in-out infinite;
        }

        .sine-wave-4 path {
            fill: none;
            stroke: url(#waveGradient4);
            stroke-width: 3;
            filter: blur(3px);
            opacity: 0.5;
        }

        /* Soft ambient glow - grayscale only */
        .header-gradient-wave1 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse 90% 60% at 60% 20%, rgba(255, 255, 255, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse 70% 50% at 30% 80%, rgba(120, 120, 120, 0.3) 0%, transparent 45%);
            animation: softGlow1 15s ease-in-out infinite;
        }

        .header-gradient-wave2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse 80% 55% at 75% 60%, rgba(200, 200, 200, 0.35) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 40%, rgba(180, 180, 180, 0.25) 0%, transparent 45%);
            animation: softGlow2 18s ease-in-out infinite;
        }

        /* Heavy film grain - primary layer */
        .header-gradient-grain {
            position: absolute;
            top: -40%;
            left: -40%;
            width: 180%;
            height: 180%;
            opacity: 0.55;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            mix-blend-mode: multiply;
            animation: grainDrift 0.8s steps(4) infinite;
        }

        /* Secondary fine grain layer */
        .header-gradient-grain2 {
            position: absolute;
            top: -20%;
            left: -20%;
            width: 140%;
            height: 140%;
            opacity: 0.4;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grain2'%3E%3CfeTurbulence type='turbulence' baseFrequency='1.0' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grain2)'/%3E%3C/svg%3E");
            mix-blend-mode: soft-light;
            animation: grainDrift2 1.2s steps(3) infinite reverse;
        }

        /* Remove unused elements */
        .header-gradient-wave3,
        .header-gradient-noise,
        .header-gradient-inner {
            display: none;
        }

        /* Slow, relaxing wave animations */
        @keyframes sineMove1 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(20%) translateY(2px);
            }
        }

        @keyframes sineMove2 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(-15%) translateY(-1px);
            }
        }

        @keyframes sineMove3 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(12%) translateY(3px);
            }
        }

        @keyframes sineMove4 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(-25%) translateY(-2px);
            }
        }

        @keyframes softGlow1 {

            0%,
            100% {
                opacity: 0.4;
                transform: scale(1) translateX(0);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.03) translateX(3%);
            }
        }

        @keyframes softGlow2 {

            0%,
            100% {
                opacity: 0.35;
                transform: scale(1.02) translateX(0);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.98) translateX(-2%);
            }
        }

        /* Slower grain animation for relaxing feel */
        @keyframes grainDrift {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, 0);
            }

            75% {
                transform: translate(0, -1px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        @keyframes grainDrift2 {
            0% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(1px, 0) scale(1.01);
            }

            66% {
                transform: translate(-1px, 1px) scale(0.99);
            }

            100% {
                transform: translate(0, 0) scale(1);
            }
        }

        /* Light theme - soft ethereal feel */
        [data-theme="light"] .header-gradient-bg {
            background: linear-gradient(165deg, #f5f5f5 0%, #e0e0e0 30%, #c0c0c0 70%, #a0a0a0 100%);
        }

        [data-theme="light"] .header-gradient-wave1 {
            background:
                radial-gradient(ellipse 90% 60% at 60% 20%, rgba(255, 255, 255, 0.5) 0%, transparent 50%),
                radial-gradient(ellipse 70% 50% at 30% 80%, rgba(140, 140, 140, 0.25) 0%, transparent 45%);
        }

        [data-theme="light"] .header-gradient-wave2 {
            background:
                radial-gradient(ellipse 80% 55% at 75% 60%, rgba(220, 220, 220, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 40%, rgba(200, 200, 200, 0.2) 0%, transparent 45%);
        }

        [data-theme="light"] .header-gradient-grain {
            opacity: 0.45;
            mix-blend-mode: multiply;
        }

        [data-theme="light"] .header-gradient-grain2 {
            opacity: 0.35;
        }

        /* Dark theme - moody grayscale */
        [data-theme="dark"] .header-gradient-bg {
            background: linear-gradient(165deg, #4a4a4a 0%, #3a3a3a 30%, #2a2a2a 70%, #1a1a1a 100%);
        }

        [data-theme="dark"] .header-gradient-wave1 {
            background:
                radial-gradient(ellipse 90% 60% at 60% 20%, rgba(200, 200, 200, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse 70% 50% at 30% 80%, rgba(100, 100, 100, 0.25) 0%, transparent 45%);
        }

        [data-theme="dark"] .header-gradient-wave2 {
            background:
                radial-gradient(ellipse 80% 55% at 75% 60%, rgba(150, 150, 150, 0.25) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 40%, rgba(120, 120, 120, 0.2) 0%, transparent 45%);
        }

        [data-theme="dark"] .header-gradient-grain {
            opacity: 0.6;
            mix-blend-mode: overlay;
        }

        [data-theme="dark"] .header-gradient-grain2 {
            opacity: 0.45;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            position: relative;
            z-index: 2;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .workspace-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-divider {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 4px;
        }

        .workspace-select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            min-width: 180px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .workspace-select:hover {
            border-color: var(--accent-primary);
        }

        .workspace-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            z-index: 2;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
        }

        .btn-danger {
            color: var(--accent-danger);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--accent-danger);
        }

        /* ============================================
           EDITOR SECTION
           ============================================ */
        .editor-section {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        /* Flow Analysis Panel - Left Side */
        .flow-analysis-panel {
            width: 350px;
            padding: 12px 16px;
            border-right: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
            overflow-y: auto;
            max-height: 200px;
        }

        .analysis-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .analysis-header svg {
            color: var(--accent-primary);
        }

        .analysis-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 10px;
            text-align: center;
            transition: all var(--transition-speed);
        }

        .stat-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent-primary);
            line-height: 1.2;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 2px;
        }

        .protocol-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .protocol-tag {
            font-size: 11px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .protocol-tag:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .protocol-tag .tag-count {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            padding: 1px 5px;
            border-radius: 8px;
            font-size: 10px;
            margin-left: 4px;
        }

        .protocol-tag:hover .tag-count {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .flow-nav-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 12px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            cursor: pointer;
            transition: all var(--transition-speed);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 32px;
        }

        .flow-nav-select:hover {
            border-color: var(--accent-primary);
        }

        .flow-nav-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .flow-nav-select option {
            padding: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .flow-nav-select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        }

        /* Pattern Editor - Right Side */
        .pattern-editor-section {
            flex: 1;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
        }

        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .editor-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .save-indicator {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .save-indicator.saving {
            color: var(--accent-warning);
        }

        .save-indicator.saved {
            color: var(--accent-secondary);
        }

        .pattern-editor-wrapper {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            overflow: hidden;
            transition: all var(--transition-speed);
            height: 150px;
            max-height: 200px;
            resize: vertical;
        }

        .pattern-editor-wrapper:focus-within {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .line-numbers {
            padding: 14px 8px 14px 12px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 22.4px;
            color: var(--text-muted);
            text-align: right;
            user-select: none;
            min-width: 44px;
            overflow-y: hidden;
            overflow-x: hidden;
            flex-shrink: 0;
        }

        .line-numbers span {
            display: block;
            height: 22.4px;
        }

        .pattern-editor {
            flex: 1;
            height: 100%;
            padding: 14px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 22.4px;
            resize: none;
            overflow-y: auto;
        }

        .pattern-editor:focus {
            outline: none;
        }

        .pattern-editor::placeholder {
            color: var(--text-muted);
        }

        .error-message {
            margin-top: 8px;
            padding: 10px 14px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-danger);
            border-radius: var(--border-radius);
            color: var(--accent-danger);
            font-size: 13px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        .error-line {
            margin-bottom: 4px;
        }

        .error-line:last-child {
            margin-bottom: 0;
        }

        /* ============================================
           CANVAS SECTION
           ============================================ */
        .canvas-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .canvas-section {
            flex: 1;
            position: relative;
            overflow: auto;
            background: var(--canvas-bg);
        }

        .canvas-container {
            min-width: 100%;
            min-height: 100%;
            padding: 20px;
            display: inline-block;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .empty-state-description {
            font-size: 14px;
            max-width: 300px;
        }

        /* ============================================
           FLOW ROW STYLES
           ============================================ */
        .flow-row {
            display: inline-flex;
            align-items: center;
            margin-bottom: 40px;
            padding: 20px;
            padding-right: 30px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            position: relative;
            cursor: pointer;
            transition: all var(--transition-speed);
            min-width: calc(100% - 40px);
            white-space: nowrap;
        }

        .flow-row:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-md);
        }

        .flow-row.selected {
            border-color: var(--accent-primary);
            border-width: 2px;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .flow-row:last-child {
            margin-bottom: 0;
        }

        .flow-row-header {
            position: absolute;
            top: -10px;
            left: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .flow-row-number {
            background: var(--accent-primary);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .flow-copy-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 3px 6px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-speed);
        }

        .flow-copy-btn:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .flow-copy-btn.copied {
            background: var(--accent-success, #22c55e);
            border-color: var(--accent-success, #22c55e);
            color: white;
        }

        .flow-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
            flex-shrink: 0;
        }

        .node-box {
            padding: 12px 20px;
            border-radius: var(--border-radius);
            border: 2px solid;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            min-width: 100px;
            transition: all var(--transition-speed);
        }

        .node-box.source {
            background: var(--node-source);
            border-color: var(--node-source-border);
            color: var(--node-source-border);
        }

        .node-box.intermediate {
            background: var(--node-intermediate);
            border-color: var(--node-intermediate-border);
            color: var(--text-primary);
        }

        .node-box.target {
            background: var(--node-target);
            border-color: var(--node-target-border);
            color: var(--node-target-border);
        }

        .node-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 6px;
            color: var(--text-muted);
        }

        /* ============================================
           EDGE / CONNECTION STYLES
           ============================================ */
        .flow-edge {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
            min-width: 160px;
            position: relative;
        }

        .edge-line-container {
            display: flex;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .edge-line {
            flex: 1;
            height: 2px;
            position: relative;
            background-image: repeating-linear-gradient(90deg,
                    var(--edge-color) 0,
                    var(--edge-color) 6px,
                    transparent 6px,
                    transparent 10px);
            background-size: 10px 2px;
            animation: flowDash 0.4s linear infinite;
        }

        @keyframes flowDash {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 10px 0;
            }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spinning {
            animation: spin 1s linear infinite;
        }

        .edge-arrow {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid var(--edge-color);
            flex-shrink: 0;
        }

        .edge-arrow.reverse {
            border-left: none;
            border-right: 10px solid var(--edge-color);
        }

        .edge-protocol {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(var(--accent-primary-rgb, 59, 130, 246), 0.1) 100%);
            border: 1px solid var(--accent-primary);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-primary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .edge-protocol.invalid {
            font-style: italic;
            border-color: var(--accent-warning, #ff9800);
            background: var(--bg-warning, rgba(255, 152, 0, 0.1));
        }

        .edge-protocol.invalid::before {
            content: 'âš  ';
            margin-right: 2px;
        }

        /* Parallel steps styling */
        .flow-edge.parallel-edges {
            min-width: 180px;
            padding: 8px 10px;
            gap: 8px;
        }

        .parallel-arrows-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .parallel-step-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
        }

        .parallel-step-row .edge-protocol {
            position: relative;
            top: auto;
            left: auto;
            transform: none;
            font-size: 10px;
            padding: 3px 10px;
            margin: 0;
        }


        .parallel-step-row .edge-line-container {
            width: 100%;
        }

        .parallel-step-text-fields {
            display: flex;
            gap: 8px;
            width: 100%;
            margin-top: 4px;
        }

        .parallel-step-text-fields .edge-notes-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .parallel-step-text-fields .edge-notes-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .parallel-step-text-fields .edge-notes-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            font-size: 11px;
            outline: none;
            text-align: center;
            transition: all var(--transition-speed);
        }

        .parallel-step-text-fields .edge-notes-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .parallel-step-text-fields .edge-notes-input:focus {
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        .parallel-text-fields {
            display: flex;
            flex-direction: column;
            gap: 4px;
            width: 100%;
            margin-top: 4px;
        }

        .parallel-text-fields .edge-notes-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .parallel-text-fields .edge-notes-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            font-size: 11px;
            outline: none;
            text-align: center;
            transition: all var(--transition-speed);
        }

        .parallel-text-fields .edge-notes-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .parallel-text-fields .edge-notes-input:focus {
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        /* Parallel outputs styling (branching to multiple targets) */
        .parallel-outputs-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px 0;
        }

        .parallel-output-branch {
            display: flex;
            align-items: center;
            gap: 0;
        }

        .parallel-output-branch .flow-edge {
            min-width: 140px;
        }

        .parallel-output-branch .flow-node {
            min-width: 100px;
        }

        .parallel-output-branch .edge-protocol.parallel-step {
            position: relative;
            top: auto;
            left: auto;
            transform: none;
            font-size: 10px;
            padding: 3px 10px;
            margin-bottom: 4px;
            /* Inherits blue gradient styling from .edge-protocol */
        }

        .parallel-output-branch .flow-edge {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 160px;
        }

        .parallel-output-branch .edge-text-fields {
            display: flex;
            flex-direction: column;
            gap: 4px;
            width: 100%;
            margin-top: 4px;
        }

        .parallel-output-branch .edge-notes-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .parallel-output-branch .edge-notes-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .parallel-output-branch .edge-notes-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            font-size: 11px;
            outline: none;
            text-align: center;
            transition: all var(--transition-speed);
        }

        .parallel-output-branch .edge-notes-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .parallel-output-branch .edge-notes-input:focus {
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        .parallel-output-branch .flow-description-field {
            min-width: 120px;
        }

        .edge-protocol-select {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-warning, #ff9800);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            cursor: pointer;
            min-width: 150px;
            font-style: italic;
        }

        .edge-protocol-select:focus {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        /* ============================================
           ANNOTATION INPUT STYLES
           ============================================ */
        .edge-annotations {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            width: 100%;
        }

        .annotation-input {
            width: 100%;
            padding: 6px 8px;
            font-size: 11px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            text-align: center;
            transition: all var(--transition-speed);
        }

        .annotation-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .annotation-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        .annotation-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        /* ============================================
           SOURCE/TARGET DESCRIPTION FIELDS
           ============================================ */
        .flow-description-field {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            min-width: 120px;
            max-width: 180px;
        }

        .flow-description-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .flow-description-input {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            font-size: 11px;
            border: 1px dashed var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            text-align: center;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .flow-description-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .flow-description-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .flow-description-field.before-source .flow-description-input {
            border-color: var(--node-source);
        }

        .flow-description-field.after-target .flow-description-input {
            border-color: var(--node-target);
        }

        .flow-description-field.before-source .flow-description-input:focus {
            border-color: var(--node-source);
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
        }

        .flow-description-field.after-target .flow-description-input:focus {
            border-color: var(--node-target);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }

        /* ============================================
           MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 24px;
            min-width: 360px;
            max-width: 90%;
            box-shadow: var(--shadow-lg);
            transform: scale(0.95);
            transition: transform var(--transition-speed);
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* ============================================
           ARCHITECTURE MODAL
           ============================================ */
        .architecture-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed);
        }

        .architecture-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .architecture-modal-content {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
            transform: scale(0.95);
            transition: transform var(--transition-speed);
            overflow: hidden;
        }

        .architecture-modal.visible .architecture-modal-content {
            transform: scale(1);
        }

        .architecture-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .architecture-modal-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .architecture-modal-title svg {
            color: var(--accent-primary);
        }

        .architecture-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 8px;
            border-radius: var(--border-radius);
            transition: all var(--transition-speed);
        }

        .architecture-modal-close:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .architecture-modal-body {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: var(--canvas-bg);
        }

        .architecture-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .architecture-canvas-container:active {
            cursor: grabbing;
        }

        .architecture-canvas {
            position: absolute;
            min-width: 100%;
            min-height: 100%;
            padding: 40px;
        }

        .architecture-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px 16px;
            font-size: 12px;
            display: flex;
            gap: 20px;
            box-shadow: var(--shadow-md);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
        }

        .legend-dot.source {
            background: var(--node-source);
            border-color: var(--node-source-border);
        }

        .legend-dot.intermediate {
            background: var(--node-intermediate);
            border-color: var(--node-intermediate-border);
        }

        .legend-dot.target {
            background: var(--node-target);
            border-color: var(--node-target-border);
        }

        .architecture-stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px 16px;
            font-size: 12px;
            box-shadow: var(--shadow-md);
        }

        .arch-stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 4px;
        }

        .arch-stat-row:last-child {
            margin-bottom: 0;
        }

        .arch-stat-label {
            color: var(--text-secondary);
        }

        .arch-stat-value {
            font-weight: 600;
            color: var(--accent-primary);
        }

        /* Architecture diagram nodes */
        .arch-node {
            position: absolute;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            box-shadow: var(--shadow-sm);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            cursor: default;
            white-space: nowrap;
        }

        .arch-node:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .arch-node.source {
            background: var(--node-source);
            border: 2px solid var(--node-source-border);
            color: var(--node-source-border);
        }

        .arch-node.intermediate {
            background: var(--node-intermediate);
            border: 2px solid var(--node-intermediate-border);
            color: var(--text-primary);
        }

        .arch-node.target {
            background: var(--node-target);
            border: 2px solid var(--node-target-border);
            color: var(--node-target-border);
        }

        /* Architecture diagram edges */
        .arch-edge-label {
            position: absolute;
            font-size: 10px;
            padding: 3px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
            pointer-events: none;
        }

        /* ============================================
           KROKI MODAL STYLES
           ============================================ */
        .kroki-modal-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kroki-modal-actions .btn-sm {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .kroki-modal-actions .btn-sm:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .kroki-modal-actions .btn-icon-only {
            padding: 6px 8px;
        }

        .kroki-zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            padding: 2px;
        }

        .kroki-zoom-level {
            min-width: 50px;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            padding: 0 4px;
        }

        .kroki-actions-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 4px;
        }

        .kroki-modal-body {
            display: flex;
            flex-direction: column;
        }

        .kroki-canvas-container {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--canvas-bg);
            overflow: auto;
        }

        .kroki-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: var(--text-secondary);
        }

        .kroki-loading.hidden {
            display: none;
        }

        .kroki-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .kroki-image {
            display: none;
            cursor: grab;
        }

        .kroki-image.visible {
            display: block;
        }

        .kroki-image.dragging {
            cursor: grabbing;
        }

        .kroki-canvas-container {
            overflow: auto;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .kroki-image-wrapper {
            display: block;
            /* Extra padding to allow scrolling beyond image edges on all sides */
            padding: 200px;
        }

        .kroki-legend {
            flex-direction: column;
            gap: 8px;
        }

        .kroki-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: var(--error-color, #e74c3c);
            padding: 20px;
            text-align: center;
        }

        .kroki-error.hidden {
            display: none;
        }

        /* ============================================
           LOADING OVERLAY
           ============================================ */
        .loading-overlay {
            position: fixed;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: #ffffff;
            font-size: 16px;
            margin-top: 20px;
            font-weight: 500;
        }

        .loading-subtext {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            margin-top: 8px;
        }

        /* ============================================
           HELP PANEL
           ============================================ */
        .help-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: right var(--transition-speed);
            overflow-y: auto;
        }

        .help-panel.visible {
            right: 0;
        }

        .help-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .help-panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .help-panel-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .help-section p {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .help-example {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            color: var(--text-primary);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* ============================================
           PATTERN INFO PANEL
           ============================================ */
        .pattern-info-panel {
            width: 350px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
        }

        .pattern-info-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .pattern-info-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flow-selector {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .flow-selector:hover {
            border-color: var(--accent-primary);
        }

        .flow-selector:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .pattern-info-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .info-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .info-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .general-notes-field {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: var(--font-family);
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .general-notes-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .general-notes-field::placeholder {
            color: var(--text-muted);
        }

        .required-products-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .product-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            transition: all var(--transition-speed);
        }

        .product-item:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-sm);
        }

        .product-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .product-capabilities {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .capability-badge {
            padding: 4px 8px;
            background: var(--accent-primary);
            color: white;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .no-products-message {
            padding: 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 13px;
            font-style: italic;
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 1024px) {
            .flow-analysis-panel {
                width: 280px;
            }

            .analysis-stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                gap: 12px;
            }

            .header-left {
                width: 100%;
                justify-content: space-between;
            }

            .workspace-controls {
                width: 100%;
            }

            .workspace-select {
                flex: 1;
            }

            .help-panel {
                width: 100%;
                right: -100%;
            }

            .flow-row {
                overflow-x: auto;
            }

            .editor-section {
                flex-direction: column;
            }

            .flow-analysis-panel {
                width: 100%;
                max-height: 150px;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .analysis-stats {
                grid-template-columns: repeat(3, 1fr);
            }

            .canvas-wrapper {
                flex-direction: column;
            }

            .pattern-info-panel {
                width: 100%;
                max-height: 300px;
            }
        }
    </style>
</head>

<body data-theme="light">
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <!-- Animated Sine Wave with Subtle Colors -->
            <div class="header-gradient">
                <div class="header-gradient-bg"></div>
                <div class="header-gradient-wave1"></div>
                <div class="header-gradient-wave2"></div>

                <!-- SVG Sine Waves - Grayscale -->
                <div class="header-sine-waves">
                    <svg viewBox="0 0 1200 60" preserveAspectRatio="none">
                        <defs>
                            <!-- Light gray gradient -->
                            <linearGradient id="waveGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.9" />
                                <stop offset="50%" style="stop-color:#e0e0e0;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#f5f5f5;stop-opacity:0.7" />
                            </linearGradient>
                            <!-- Mid gray gradient -->
                            <linearGradient id="waveGradient2" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#b0b0b0;stop-opacity:0.8" />
                                <stop offset="50%" style="stop-color:#909090;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#c0c0c0;stop-opacity:0.6" />
                            </linearGradient>
                            <!-- Dark gray gradient -->
                            <linearGradient id="waveGradient3" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#707070;stop-opacity:0.7" />
                                <stop offset="50%" style="stop-color:#505050;stop-opacity:0.9" />
                                <stop offset="100%" style="stop-color:#606060;stop-opacity:0.5" />
                            </linearGradient>
                            <!-- Soft white highlight -->
                            <linearGradient id="waveGradient4" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.6" />
                                <stop offset="50%" style="stop-color:#f8f8f8;stop-opacity:0.8" />
                                <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0.4" />
                            </linearGradient>
                        </defs>

                        <!-- Wave 1 - Light, wide amplitude, slow -->
                        <g class="sine-wave-1">
                            <path
                                d="M0,30 C75,15 150,15 225,30 C300,45 375,45 450,30 C525,15 600,15 675,30 C750,45 825,45 900,30 C975,15 1050,15 1125,30 C1200,45 1275,45 1350,30 C1425,15 1500,15 1575,30" />
                        </g>

                        <!-- Wave 2 - Mid gray, different frequency -->
                        <g class="sine-wave-2">
                            <path
                                d="M0,35 C60,22 120,22 180,35 C240,48 300,48 360,35 C420,22 480,22 540,35 C600,48 660,48 720,35 C780,22 840,22 900,35 C960,48 1020,48 1080,35 C1140,22 1200,22 1260,35 C1320,48 1380,48 1440,35" />
                        </g>

                        <!-- Wave 3 - Dark, tighter frequency -->
                        <g class="sine-wave-3">
                            <path
                                d="M0,28 C45,38 90,38 135,28 C180,18 225,18 270,28 C315,38 360,38 405,28 C450,18 495,18 540,28 C585,38 630,38 675,28 C720,18 765,18 810,28 C855,38 900,38 945,28 C990,18 1035,18 1080,28 C1125,38 1170,38 1215,28" />
                        </g>

                        <!-- Wave 4 - White highlight, very soft -->
                        <g class="sine-wave-4">
                            <path
                                d="M0,32 C90,20 180,20 270,32 C360,44 450,44 540,32 C630,20 720,20 810,32 C900,44 990,44 1080,32 C1170,20 1260,20 1350,32 C1440,44 1530,44 1620,32" />
                        </g>
                    </svg>
                </div>

                <div class="header-gradient-grain"></div>
                <div class="header-gradient-grain2"></div>
            </div>

            <div class="header-left">
                <div class="logo">
                    <div class="logo-icon">â‡Œ</div>
                    <span>MFT Flow Visualizer</span>
                </div>
                <div class="workspace-controls">
                    <select id="workspaceSelect" class="workspace-select">
                        <option value="">Loading...</option>
                    </select>
                    <button id="newWorkspaceBtn" class="btn btn-primary btn-icon" title="New Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <button id="renameWorkspaceBtn" class="btn btn-icon" title="Rename Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                        </svg>
                    </button>
                    <button id="duplicateWorkspaceBtn" class="btn btn-icon" title="Duplicate Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button id="deleteWorkspaceBtn" class="btn btn-icon btn-danger" title="Delete Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                            </path>
                        </svg>
                    </button>
                    <span class="workspace-divider"></span>
                    <button id="exportWorkspaceBtn" class="btn btn-icon" title="Export Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                    </button>
                    <button id="importWorkspaceBtn" class="btn btn-icon" title="Import Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;">
                </div>
            </div>
            <div class="header-right">
                <button id="architectureBtn" class="btn btn-icon" title="View Full Architecture">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"></rect>
                        <rect x="14" y="3" width="7" height="7" rx="1"></rect>
                        <rect x="14" y="14" width="7" height="7" rx="1"></rect>
                        <rect x="3" y="14" width="7" height="7" rx="1"></rect>
                        <path d="M10 6.5h4"></path>
                        <path d="M17.5 10v4"></path>
                        <path d="M10 17.5h4"></path>
                        <path d="M6.5 10v4"></path>
                    </svg>
                </button>
                <button id="krokiBtn" class="btn btn-icon" title="Generate Kroki Diagram (D2)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                        <path d="M2 17l10 5 10-5"></path>
                        <path d="M2 12l10 5 10-5"></path>
                    </svg>
                </button>
                <button id="themeToggleBtn" class="btn btn-icon" title="Toggle Theme">
                    <svg id="themeIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <button id="helpBtn" class="btn btn-icon" title="Help">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Editor Section -->
        <section class="editor-section">
            <!-- Flow Analysis Panel - Left Side -->
            <div class="flow-analysis-panel">
                <div class="analysis-header">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path
                            d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
                        </path>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                        <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                    Flow Analysis
                </div>
                <div class="analysis-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="statFlowCount">0</div>
                        <div class="stat-label">Flows</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statNodeCount">0</div>
                        <div class="stat-label">Nodes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statProtocolCount">0</div>
                        <div class="stat-label">Protocols</div>
                    </div>
                </div>
                <div class="protocol-tags" id="protocolTags">
                    <!-- Protocol tags will be populated dynamically -->
                </div>
                <select class="flow-nav-select" id="flowNavSelect">
                    <option value="">-- Select a flow --</option>
                </select>
            </div>

            <!-- Pattern Editor - Right Side -->
            <div class="pattern-editor-section">
                <div class="editor-header">
                    <span class="editor-title">Flow Patterns (one per line)</span>
                    <span id="saveIndicator" class="save-indicator saved">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                        <span id="saveText">Saved</span>
                    </span>
                </div>
                <div class="pattern-editor-wrapper">
                    <div id="lineNumbers" class="line-numbers"><span>1</span></div>
                    <textarea id="patternEditor" class="pattern-editor" placeholder="Enter your MFT flow patterns here (one per line)...

Examples:
TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF" spellcheck="false"></textarea>
                </div>
                <div id="errorMessage" class="error-message"></div>
            </div>
        </section>

        <!-- Canvas Section -->
        <div class="canvas-wrapper">
            <section class="canvas-section">
                <div id="canvasContainer" class="canvas-container">
                    <!-- Flow rows will be rendered here -->
                </div>

                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">â‡Œ</div>
                    <div class="empty-state-title">No Flows Defined</div>
                    <div class="empty-state-description">
                        Enter flow patterns in the editor above to visualize your MFT flows.
                    </div>
                </div>
            </section>

            <!-- Pattern Info Panel -->
            <div id="patternInfoPanel" class="pattern-info-panel">
                <div class="pattern-info-header">
                    <span class="pattern-info-title">Flow Information</span>
                </div>
                <div class="pattern-info-content">
                    <div class="info-section">
                        <label class="info-label">Select Flow</label>
                        <select id="flowSelector" class="flow-selector">
                            <option value="">-- Select a flow --</option>
                        </select>
                    </div>
                    <div class="info-section">
                        <label class="info-label">General Notes</label>
                        <textarea id="generalNotesField" class="general-notes-field"
                            placeholder="Add general notes about this flow..."></textarea>
                    </div>
                    <div class="info-section">
                        <label class="info-label">Potential Products</label>
                        <div id="requiredProductsList" class="required-products-list">
                            <div class="no-products-message">Select a flow to see potential products</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Help Panel -->
        <div id="helpPanel" class="help-panel">
            <div class="help-panel-header">
                <span class="help-panel-title">Help & Syntax Guide</span>
                <button id="closeHelpBtn" class="btn btn-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="help-panel-content">
                <div class="help-section">
                    <h3 class="help-section-title">Pattern Syntax</h3>
                    <p>Define MFT flows using a simple text-based syntax. Enter one pattern per line.</p>
                    <div class="help-example">SOURCE -> PROTOCOL DIRECTION -> MIDDLE -> PROTOCOL DIRECTION -> TARGET
                    </div>
                </div>
                <div class="help-section">
                    <h3 class="help-section-title">Examples</h3>
                    <div class="help-example">TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
                        TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
                        TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF
                            TESTZ -> PeSIT PUSH -> ST -> JMS PUSH -> SFC -> EBICS PUSH -> BANK1</div>
                </div>
                <div class="help-section">
                    <h3 class="help-section-title">Components</h3>
                    <p><strong>Entities:</strong> Names like TESTA, ST, CFT (alphanumeric + underscores)</p>
                    <p><strong>Protocols:</strong> SFTP, PeSIT, HTTPS, FTP, AS2, SSH, JMS, EBICS, etc.</p>
                    <p><strong>Directions:</strong> PULL (fetch data) or PUSH (send data)</p>
                    <p><strong>Arrows:</strong> <- (left) and -> (right) indicate flow direction</p>
                </div>
                <div class="help-section">
                    <h3 class="help-section-title">Annotations</h3>
                    <p>Each connection has editable annotation fields for pre-processing and post-processing notes.
                        Click on
                        the yellow dashed boxes to add annotations.</p>
                </div>
            </div>
        </div>

        <!-- Modal for Rename/New Workspace -->
        <div id="modalOverlay" class="modal-overlay">
            <div class="modal">
                <h2 id="modalTitle" class="modal-title">New Workspace</h2>
                <input type="text" id="modalInput" class="modal-input" placeholder="Workspace name">
                <div class="modal-actions">
                    <button id="modalCancelBtn" class="btn">Cancel</button>
                    <button id="modalConfirmBtn" class="btn btn-primary">Create</button>
                </div>
            </div>
        </div>

        <!-- Architecture Diagram Modal -->
        <div id="architectureModal" class="architecture-modal">
            <div class="architecture-modal-content">
                <div class="architecture-modal-header">
                    <div class="architecture-modal-title">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="3" y="3" width="7" height="7" rx="1"></rect>
                            <rect x="14" y="3" width="7" height="7" rx="1"></rect>
                            <rect x="14" y="14" width="7" height="7" rx="1"></rect>
                            <rect x="3" y="14" width="7" height="7" rx="1"></rect>
                            <path d="M10 6.5h4"></path>
                            <path d="M17.5 10v4"></path>
                            <path d="M10 17.5h4"></path>
                            <path d="M6.5 10v4"></path>
                        </svg>
                        Full Architecture Diagram
                    </div>
                    <button id="closeArchitectureBtn" class="architecture-modal-close" title="Close">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="architecture-modal-body">
                    <div id="architectureCanvasContainer" class="architecture-canvas-container">
                        <svg id="architectureCanvas" class="architecture-canvas"></svg>
                    </div>
                    <div class="architecture-legend">
                        <div class="legend-item">
                            <div class="legend-dot source"></div>
                            <span>Source</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot intermediate"></div>
                            <span>Intermediate</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot target"></div>
                            <span>Target</span>
                        </div>
                    </div>
                    <div id="architectureStats" class="architecture-stats">
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Unique Nodes:</span>
                            <span class="arch-stat-value" id="archStatNodes">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Connections:</span>
                            <span class="arch-stat-value" id="archStatConnections">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Protocols:</span>
                            <span class="arch-stat-value" id="archStatProtocols">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Kroki Diagram Modal -->
        <div id="krokiModal" class="architecture-modal">
            <div class="architecture-modal-content">
                <div class="architecture-modal-header">
                    <div class="architecture-modal-title">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                            <path d="M2 17l10 5 10-5"></path>
                            <path d="M2 12l10 5 10-5"></path>
                        </svg>
                        Kroki Diagram (D2)
                    </div>
                    <div class="kroki-modal-actions">
                        <div class="kroki-zoom-controls">
                            <button id="krokiZoomOutBtn" class="btn btn-sm btn-icon-only" title="Zoom Out (-)">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                    <line x1="8" y1="11" x2="14" y2="11"></line>
                                </svg>
                            </button>
                            <span id="krokiZoomLevel" class="kroki-zoom-level">100%</span>
                            <button id="krokiZoomInBtn" class="btn btn-sm btn-icon-only" title="Zoom In (+)">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                    <line x1="11" y1="8" x2="11" y2="14"></line>
                                    <line x1="8" y1="11" x2="14" y2="11"></line>
                                </svg>
                            </button>
                            <button id="krokiZoomResetBtn" class="btn btn-sm" title="Reset Zoom">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                                    <path d="M3 3v5h5"></path>
                                </svg>
                                Fit
                            </button>
                        </div>
                        <div class="kroki-actions-divider"></div>
                        <button id="krokiCopyCodeBtn" class="btn btn-sm" title="Copy D2 Code">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            Copy Code
                        </button>
                        <button id="krokiOpenExternalBtn" class="btn btn-sm" title="Open in Kroki">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                                <polyline points="15 3 21 3 21 9"></polyline>
                                <line x1="10" y1="14" x2="21" y2="3"></line>
                            </svg>
                            Open External
                        </button>
                        <button id="closeKrokiBtn" class="architecture-modal-close" title="Close">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="architecture-modal-body kroki-modal-body">
                    <div id="krokiCanvasContainer" class="architecture-canvas-container kroki-canvas-container">
                        <div id="krokiLoading" class="kroki-loading">
                            <div class="kroki-spinner"></div>
                            <span>Generating diagram...</span>
                        </div>
                        <div id="krokiImageWrapper" class="kroki-image-wrapper">
                            <img id="krokiImage" class="kroki-image" alt="Kroki D2 Diagram" />
                        </div>
                    </div>
                    <div class="architecture-legend kroki-legend">
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Nodes:</span>
                            <span class="arch-stat-value" id="krokiStatNodes">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Connections:</span>
                            <span class="arch-stat-value" id="krokiStatConnections">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Format:</span>
                            <span class="arch-stat-value">D2</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script src="products_capabilities.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
        <script>
            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            function generateId() {
                return 'ws_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
            }

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // ============================================
            // STATE MANAGER
            // ============================================
            const StateManager = {
                state: {
                    workspaces: new Map(),
                    activeWorkspaceId: null,
                    theme: 'light'
                },
                listeners: [],

                subscribe(listener) {
                    this.listeners.push(listener);
                    return () => {
                        this.listeners = this.listeners.filter(l => l !== listener);
                    };
                },

                notify(event) {
                    this.listeners.forEach(listener => listener(event, this.state));
                },

                getActiveWorkspace() {
                    return this.state.workspaces.get(this.state.activeWorkspaceId);
                },

                setActiveWorkspace(id) {
                    if (this.state.workspaces.has(id)) {
                        this.state.activeWorkspaceId = id;
                        this.notify({ type: 'WORKSPACE_CHANGED', workspaceId: id });
                    }
                },

                updatePattern(text) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        workspace.patternText = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'PATTERN_UPDATED', workspaceId: workspace.id });
                    }
                },

                updateFlowNotes(flowIndex, text) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.flowNotes) {
                            workspace.flowNotes = {};
                        }
                        workspace.flowNotes[flowIndex] = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'FLOW_NOTES_UPDATED', workspaceId: workspace.id, flowIndex });
                    }
                },

                getFlowNotes(flowIndex) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.flowNotes) {
                        return workspace.flowNotes[flowIndex] || '';
                    }
                    return '';
                },

                updateFlowDescription(flowIndex, type, text) {
                    // type is 'beforeSource' or 'afterTarget'
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.flowDescriptions) {
                            workspace.flowDescriptions = {};
                        }
                        const key = `${flowIndex}-${type}`;
                        workspace.flowDescriptions[key] = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'FLOW_DESCRIPTION_UPDATED', workspaceId: workspace.id, flowIndex, descType: type });
                    }
                },

                getFlowDescription(flowIndex, type) {
                    // type is 'beforeSource' or 'afterTarget'
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.flowDescriptions) {
                        const key = `${flowIndex}-${type}`;
                        return workspace.flowDescriptions[key] || '';
                    }
                    return '';
                },

                updateAnnotation(flowIndex, edgeIndex, field, value) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.annotations) {
                            workspace.annotations = {};
                        }
                        const key = `${flowIndex}-${edgeIndex}-${field}`;
                        workspace.annotations[key] = value;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'ANNOTATION_UPDATED', workspaceId: workspace.id });
                    }
                },

                getAnnotation(flowIndex, edgeIndex, field) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.annotations) {
                        const key = `${flowIndex}-${edgeIndex}-${field}`;
                        return workspace.annotations[key] || '';
                    }
                    return '';
                },

                updateEdgeNotes(flowIndex, edgeIndex, type, text) {
                    // type is 'pre' or 'post' for parallel steps
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.edgeNotes) {
                            workspace.edgeNotes = {};
                        }
                        const key = `${flowIndex}-${edgeIndex}-${type}`;
                        workspace.edgeNotes[key] = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'EDGE_NOTES_UPDATED', workspaceId: workspace.id, flowIndex, edgeIndex });
                    }
                },

                getEdgeNotes(flowIndex, edgeIndex, type) {
                    // type is 'pre' or 'post' for parallel steps
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.edgeNotes) {
                        const key = `${flowIndex}-${edgeIndex}-${type}`;
                        return workspace.edgeNotes[key] || '';
                    }
                    return '';
                },

                setTheme(theme) {
                    this.state.theme = theme;
                    this.notify({ type: 'THEME_CHANGED', theme });
                }
            };

            // ============================================
            // PERSISTENCE LAYER
            // ============================================
            const Persistence = {
                STORAGE_KEY: 'mft_flow_visualizer',
                VERSION: '1.1.0',

                save() {
                    try {
                        const data = {
                            version: this.VERSION,
                            activeWorkspaceId: StateManager.state.activeWorkspaceId,
                            theme: StateManager.state.theme,
                            workspaces: Array.from(StateManager.state.workspaces.entries()).map(([id, ws]) => ({
                                id: ws.id,
                                name: ws.name,
                                patternText: ws.patternText,
                                flowNotes: ws.flowNotes || {},
                                flowDescriptions: ws.flowDescriptions || {},
                                annotations: ws.annotations || {},
                                edgeNotes: ws.edgeNotes || {},
                                metadata: ws.metadata
                            }))
                        };
                        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                        return true;
                    } catch (e) {
                        console.error('Failed to save:', e);
                        return false;
                    }
                },

                load() {
                    try {
                        const raw = localStorage.getItem(this.STORAGE_KEY);
                        if (!raw) return null;

                        const data = JSON.parse(raw);

                        // Convert workspaces array back to Map
                        const workspaces = new Map();
                        if (data.workspaces) {
                            data.workspaces.forEach(ws => {
                                workspaces.set(ws.id, {
                                    ...ws,
                                    flowNotes: ws.flowNotes || {},
                                    flowDescriptions: ws.flowDescriptions || {},
                                    annotations: ws.annotations || {},
                                    edgeNotes: ws.edgeNotes || {}
                                });
                            });
                        }

                        return {
                            ...data,
                            workspaces
                        };
                    } catch (e) {
                        console.error('Failed to load:', e);
                        return null;
                    }
                },

                clear() {
                    localStorage.removeItem(this.STORAGE_KEY);
                }
            };

            // ============================================
            // WORKSPACE MANAGER
            // ============================================
            const WorkspaceManager = {
                createWorkspace(name = 'Untitled Workspace') {
                    const id = generateId();
                    const workspace = {
                        id,
                        name,
                        patternText: '',
                        flowNotes: {},
                        flowDescriptions: {},
                        annotations: {},
                        metadata: {
                            createdAt: Date.now(),
                            updatedAt: Date.now(),
                            version: '1.0.0'
                        }
                    };
                    StateManager.state.workspaces.set(id, workspace);
                    StateManager.setActiveWorkspace(id);
                    Persistence.save();
                    return workspace;
                },

                renameWorkspace(id, newName) {
                    const workspace = StateManager.state.workspaces.get(id);
                    if (workspace) {
                        workspace.name = newName;
                        workspace.metadata.updatedAt = Date.now();
                        StateManager.notify({ type: 'WORKSPACE_RENAMED', workspaceId: id });
                        Persistence.save();
                    }
                },

                duplicateWorkspace(id) {
                    const original = StateManager.state.workspaces.get(id);
                    if (original) {
                        const newId = generateId();
                        const duplicate = {
                            ...JSON.parse(JSON.stringify(original)),
                            id: newId,
                            name: original.name + ' (Copy)',
                            metadata: {
                                createdAt: Date.now(),
                                updatedAt: Date.now(),
                                version: original.metadata.version
                            }
                        };
                        StateManager.state.workspaces.set(newId, duplicate);
                        StateManager.setActiveWorkspace(newId);
                        Persistence.save();
                        return duplicate;
                    }
                    return null;
                },

                deleteWorkspace(id) {
                    if (StateManager.state.workspaces.size <= 1) {
                        alert('Cannot delete the last workspace');
                        return false;
                    }

                    StateManager.state.workspaces.delete(id);

                    // Switch to another workspace
                    const firstId = StateManager.state.workspaces.keys().next().value;
                    StateManager.setActiveWorkspace(firstId);
                    Persistence.save();
                    return true;
                },

                initialize() {
                    const saved = Persistence.load();

                    if (saved && saved.workspaces.size > 0) {
                        StateManager.state.workspaces = saved.workspaces;
                        StateManager.state.theme = saved.theme || 'light';

                        // Set active workspace
                        if (saved.activeWorkspaceId && saved.workspaces.has(saved.activeWorkspaceId)) {
                            StateManager.setActiveWorkspace(saved.activeWorkspaceId);
                        } else {
                            const firstId = saved.workspaces.keys().next().value;
                            StateManager.setActiveWorkspace(firstId);
                        }
                    } else {
                        // Create default workspace
                        this.createWorkspace('My First Flow');
                    }
                }
            };

            // ============================================
            // PARSER ENGINE
            // ============================================
            const Parser = {
                parseMultiple(text) {
                    const lines = text.split('\n').filter(line => line.trim());
                    const results = [];
                    const errors = [];

                    lines.forEach((line, index) => {
                        const result = this.parseLine(line.trim(), index + 1);
                        if (result.error) {
                            errors.push({ line: index + 1, message: result.error });
                        } else if (result.nodes.length > 0) {
                            results.push({
                                lineNumber: index + 1,
                                originalText: line.trim(),
                                nodes: result.nodes,
                                edges: result.edges
                            });
                        }
                    });

                    return { flows: results, errors };
                },

                parseLine(text, lineNumber) {
                    const result = {
                        nodes: [],
                        edges: [],
                        error: null
                    };

                    if (!text || !text.trim()) {
                        return result;
                    }

                    const trimmed = text.trim();

                    // Tokenize the pattern
                    const tokens = this.tokenize(trimmed);

                    if (tokens.error) {
                        result.error = tokens.error;
                        return result;
                    }

                    // Build nodes and edges from tokens
                    const { nodes, edges, error } = this.buildGraph(tokens.segments);

                    if (error) {
                        result.error = error;
                        return result;
                    }

                    result.nodes = nodes;
                    result.edges = edges;

                    return result;
                },

                tokenize(text) {
                    const segments = [];

                    // Protect content inside parentheses from arrow splitting
                    // Replace parenthesized content with placeholders
                    const placeholders = [];
                    let protectedText = text.replace(/\([^)]+\)/g, (match) => {
                        const idx = placeholders.length;
                        placeholders.push(match);
                        return `__PARALLEL_${idx}__`;
                    });

                    // Split by arrows while keeping track of direction
                    const arrowPattern = /(<-|->)/g;
                    const parts = protectedText.split(arrowPattern).map(p => p.trim()).filter(p => p);
                    
                    // Restore placeholders
                    const restoredParts = parts.map(p => {
                        return p.replace(/__PARALLEL_(\d+)__/g, (match, idx) => placeholders[parseInt(idx)]);
                    });

                    if (restoredParts.length < 5) {
                        return { error: 'Invalid pattern. Expected: Entity -> PROTOCOL DIRECTION -> Entity' };
                    }

                    let currentIndex = 0;

                    // First entity - accept any string (no validation)
                    const firstEntity = restoredParts[currentIndex];
                    segments.push({ type: 'entity', value: firstEntity });
                    currentIndex++;

                    while (currentIndex < restoredParts.length) {
                        // Expect arrow
                        const arrow1 = restoredParts[currentIndex];
                        if (arrow1 !== '<-' && arrow1 !== '->') {
                            return { error: `Expected arrow (<- or ->), got: "${arrow1}"` };
                        }
                        currentIndex++;

                        // Expect PROTOCOL DIRECTION or parallel syntax
                        if (currentIndex >= restoredParts.length) {
                            return { error: 'Unexpected end of pattern after arrow' };
                        }
                        const protocolDir = restoredParts[currentIndex];
                        
                        // Check for parallel syntax: (...)
                        const parallelMatch = protocolDir.match(/^\((.+)\)$/);
                        
                        if (parallelMatch) {
                            const innerContent = parallelMatch[1];
                            const steps = innerContent.split('&').map(s => s.trim());
                            
                            // Check if this is parallel OUTPUTS (contains ->) or parallel INPUTS (no ->)
                            const hasArrowInSteps = steps.some(s => s.includes('->') || s.includes('<-'));
                            
                            if (hasArrowInSteps) {
                                // PARALLEL OUTPUTS: (PROTO DIR -> TARGET & PROTO DIR -> TARGET)
                                // This is terminal - no more parsing after this
                                for (let i = 0; i < steps.length; i++) {
                                    // Parse: "SOAP PUSH -> E" or "EBICS PUSH -> F"
                                    const outputMatch = steps[i].match(/^(.+?)\s+(PULL|PUSH)\s*(->|<-)\s*(.+)$/i);
                                    if (!outputMatch) {
                                        return { error: `Invalid parallel output: "${steps[i]}". Expected: PROTOCOL DIRECTION -> TARGET` };
                                    }
                                    const protocol = outputMatch[1].trim();
                                    const direction = outputMatch[2].toUpperCase();
                                    const arrow = outputMatch[3];
                                    const target = outputMatch[4].trim();
                                    
                                    segments.push({
                                        type: 'connection',
                                        arrow: arrow,
                                        protocol: protocol,
                                        direction: direction,
                                        toEntity: target,
                                        stepNumber: i + 1,
                                        isParallelOutput: true
                                    });
                                    segments.push({ type: 'entity', value: target });
                                }
                                // Move past the parallel block - this ends the pattern
                                currentIndex++;
                                continue;
                            } else {
                                // PARALLEL INPUTS: (FTP PUSH & JMS PUSH) -> TARGET
                                let protocolSteps = [];
                                for (let i = 0; i < steps.length; i++) {
                                    const stepMatch = steps[i].match(/^(.+?)\s+(PULL|PUSH)$/i);
                                    if (!stepMatch) {
                                        return { error: `Invalid protocol in parallel steps: "${steps[i]}". Expected: PROTOCOL PULL/PUSH` };
                                    }
                                    protocolSteps.push({
                                        protocol: stepMatch[1].trim(),
                                        direction: stepMatch[2].toUpperCase(),
                                        stepNumber: i + 1
                                    });
                                }
                                currentIndex++;

                                // Expect second arrow
                                if (currentIndex >= restoredParts.length) {
                                    return { error: 'Unexpected end of pattern, expected arrow after parallel inputs' };
                                }
                                const arrow2 = restoredParts[currentIndex];
                                if (arrow2 !== '<-' && arrow2 !== '->') {
                                    return { error: `Expected arrow (<- or ->), got: "${arrow2}"` };
                                }
                                if (arrow1 !== arrow2) {
                                    return { error: `Inconsistent arrows: ${arrow1} and ${arrow2}. Both should match.` };
                                }
                                currentIndex++;

                                // Expect entity
                                if (currentIndex >= restoredParts.length) {
                                    return { error: 'Unexpected end of pattern, expected entity' };
                                }
                                const entity = restoredParts[currentIndex];

                                // Add connection segments for parallel inputs
                                protocolSteps.forEach(step => {
                                    segments.push({
                                        type: 'connection',
                                        arrow: arrow1,
                                        protocol: step.protocol,
                                        direction: step.direction,
                                        toEntity: entity,
                                        stepNumber: step.stepNumber,
                                        isParallelInput: true
                                    });
                                });

                                segments.push({ type: 'entity', value: entity });
                                currentIndex++;
                            }
                        } else {
                            // Single protocol direction
                            const pdMatch = protocolDir.match(/^(.+?)\s+(PULL|PUSH)$/i);
                            if (!pdMatch) {
                                return { error: `Invalid protocol/direction: "${protocolDir}". Expected: PROTOCOL PULL/PUSH` };
                            }
                            currentIndex++;

                            // Expect second arrow
                            if (currentIndex >= restoredParts.length) {
                                return { error: 'Unexpected end of pattern, expected arrow' };
                            }
                            const arrow2 = restoredParts[currentIndex];
                            if (arrow2 !== '<-' && arrow2 !== '->') {
                                return { error: `Expected arrow (<- or ->), got: "${arrow2}"` };
                            }
                            if (arrow1 !== arrow2) {
                                return { error: `Inconsistent arrows: ${arrow1} and ${arrow2}. Both should match.` };
                            }
                            currentIndex++;

                            // Expect entity
                            if (currentIndex >= restoredParts.length) {
                                return { error: 'Unexpected end of pattern, expected entity' };
                            }
                            const entity = restoredParts[currentIndex];

                            segments.push({
                                type: 'connection',
                                arrow: arrow1,
                                protocol: pdMatch[1].trim(),
                                direction: pdMatch[2].toUpperCase(),
                                toEntity: entity,
                                stepNumber: null
                            });

                            segments.push({ type: 'entity', value: entity });
                            currentIndex++;
                        }
                    }

                    return { segments };
                },


                buildGraph(segments) {
                    const nodes = [];
                    const edges = [];
                    const nodeMap = new Map();

                    let nodeIndex = 0;

                    // First pass: collect all unique entities
                    segments.forEach(seg => {
                        if (seg.type === 'entity' && !nodeMap.has(seg.value)) {
                            nodeMap.set(seg.value, nodeIndex++);
                        }
                    });

                    // Determine node types based on position
                    // Get unique entity list in order (filter duplicates but keep first occurrence)
                    const seenEntities = new Set();
                    const entityList = segments
                        .filter(s => s.type === 'entity')
                        .map(s => s.value)
                        .filter(entity => {
                            if (seenEntities.has(entity)) return false;
                            seenEntities.add(entity);
                            return true;
                        });

                    entityList.forEach((entity, idx) => {
                        let type = 'intermediate';
                        if (idx === 0) type = 'source';
                        else if (idx === entityList.length - 1) type = 'target';

                        nodes.push({
                            id: 'node_' + idx,
                            label: entity,
                            type: type,
                            index: idx
                        });
                    });

                    // Second pass: build edges
                    let lastEntity = null;
                    let parallelOutputSourceEntity = null; // Track the source for parallel outputs
                    let edgeIndex = 0;
                    segments.forEach(seg => {
                        if (seg.type === 'entity') {
                            // If this entity is a target of a parallel output, don't update lastEntity
                            // (parallel outputs all share the same source)
                            if (!seg.isParallelOutputTarget) {
                                lastEntity = seg.value;
                            }
                        } else if (seg.type === 'connection' && lastEntity) {
                            let fromEntity;
                            
                            if (seg.isParallelOutput) {
                                // For parallel outputs, use the source entity (set before first parallel output)
                                if (parallelOutputSourceEntity === null) {
                                    parallelOutputSourceEntity = lastEntity;
                                }
                                fromEntity = parallelOutputSourceEntity;
                            } else {
                                fromEntity = lastEntity;
                                parallelOutputSourceEntity = null; // Reset when we're not in parallel output mode
                            }
                            
                            const toEntity = seg.toEntity;

                            // Determine actual from/to based on arrow direction
                            let flowDirection = seg.arrow === '<-' ? 'reverse' : 'forward';

                            edges.push({
                                id: 'edge_' + edgeIndex,
                                fromLabel: fromEntity,
                                toLabel: toEntity,
                                protocol: seg.protocol,
                                direction: seg.direction,
                                flowDirection: flowDirection,
                                stepNumber: seg.stepNumber,
                                isParallelOutput: seg.isParallelOutput || false,
                                isParallelInput: seg.isParallelInput || false,
                                index: edgeIndex
                            });
                            edgeIndex++;
                        }
                    });

                    return { nodes, edges, error: null };
                }
            };

            // ============================================
            // DIAGRAM RENDERER
            // ============================================
            const DiagramRenderer = {
                selectedFlowIndex: null,
                flows: [],

                render(flows, container) {
                    container.innerHTML = '';
                    this.flows = flows;

                    if (!flows || flows.length === 0) {
                        document.getElementById('emptyState').style.display = 'block';
                        this.updateFlowSelector([]);
                        this.updateRequiredProducts(null);
                        this.updateNotesField(null);
                        return;
                    }

                    document.getElementById('emptyState').style.display = 'none';

                    flows.forEach((flow, flowIndex) => {
                        const rowElement = this.createFlowRow(flow, flowIndex);
                        container.appendChild(rowElement);
                    });

                    // Update flow selector
                    this.updateFlowSelector(flows);

                    // If no flow selected, select first one
                    if (this.selectedFlowIndex === null && flows.length > 0) {
                        this.selectFlow(0);
                    } else if (this.selectedFlowIndex !== null) {
                        this.selectFlow(this.selectedFlowIndex);
                    }
                },

                updateFlowSelector(flows) {
                    const selector = document.getElementById('flowSelector');
                    if (!selector) return;

                    selector.innerHTML = '<option value="">-- Select a flow --</option>';
                    flows.forEach((flow, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Flow ${index + 1}: ${flow.originalText.substring(0, 50)}${flow.originalText.length > 50 ? '...' : ''}`;
                        selector.appendChild(option);
                    });

                    if (this.selectedFlowIndex !== null) {
                        selector.value = this.selectedFlowIndex;
                    }
                },

                selectFlow(flowIndex) {
                    this.selectedFlowIndex = flowIndex;

                    // Update UI
                    const rows = document.querySelectorAll('.flow-row');
                    rows.forEach((row, index) => {
                        if (index === flowIndex) {
                            row.classList.add('selected');
                        } else {
                            row.classList.remove('selected');
                        }
                    });

                    const selector = document.getElementById('flowSelector');
                    if (selector) {
                        selector.value = flowIndex;
                    }

                    // Update flow navigation items selection
                    const flowNavItems = document.querySelectorAll('.flow-nav-item');
                    flowNavItems.forEach((item, index) => {
                        if (index === flowIndex) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });

                    // Update notes and products for selected flow
                    if (flowIndex !== null && this.flows[flowIndex]) {
                        this.updateNotesField(flowIndex);
                        this.updateRequiredProducts(flowIndex);
                    } else {
                        this.updateNotesField(null);
                        this.updateRequiredProducts(null);
                    }
                },

                updateRequiredProducts(flowIndex) {
                    const productsList = document.getElementById('requiredProductsList');
                    if (!productsList) return;

                    if (flowIndex === null || !this.flows[flowIndex]) {
                        productsList.innerHTML = '<div class="no-products-message">Select a flow to see potential products</div>';
                        return;
                    }

                    const flow = this.flows[flowIndex];
                    const requiredProducts = getRequiredProducts([flow]);

                    if (requiredProducts.length === 0) {
                        productsList.innerHTML = '<div class="no-products-message">No matching products found for the protocols used</div>';
                        return;
                    }

                    productsList.innerHTML = requiredProducts.map(product => {
                        const capabilitiesHtml = product.supportedCapabilities
                            .map(cap => `<span class="capability-badge">${cap}</span>`)
                            .join('');
                        return `
                        <div class="product-item">
                            <div class="product-name">${product.name}</div>
                            <div class="product-capabilities">${capabilitiesHtml}</div>
                        </div>
                    `;
                    }).join('');
                },

                updateNotesField(flowIndex) {
                    const notesField = document.getElementById('generalNotesField');
                    if (!notesField) return;

                    if (flowIndex === null) {
                        notesField.value = '';
                        notesField.disabled = true;
                    } else {
                        notesField.value = StateManager.getFlowNotes(flowIndex);
                        notesField.disabled = false;
                    }
                },

                createFlowRow(flow, flowIndex) {
                    const row = document.createElement('div');
                    row.className = 'flow-row';
                    if (flowIndex === this.selectedFlowIndex) {
                        row.classList.add('selected');
                    }

                    // Make row clickable
                    row.addEventListener('click', () => {
                        this.selectFlow(flowIndex);
                    });

                    // Row header with number and copy button
                    const rowHeader = document.createElement('div');
                    rowHeader.className = 'flow-row-header';

                    const rowNumber = document.createElement('div');
                    rowNumber.className = 'flow-row-number';
                    rowNumber.textContent = `Flow ${flowIndex + 1}`;

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'flow-copy-btn';
                    copyBtn.title = 'Copy flow as PNG';
                    copyBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>`;
                    copyBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await UIController.copyFlowAsPng(row, flowIndex);
                    });

                    rowHeader.appendChild(rowNumber);
                    rowHeader.appendChild(copyBtn);
                    row.appendChild(rowHeader);

                    // Group edges by their from->to pair to handle parallel steps
                    // Build a map: nodeLabel -> [edges leaving this node]
                    const edgesByFromNode = new Map();
                    flow.edges.forEach((edge, edgeIndex) => {
                        const key = edge.fromLabel;
                        if (!edgesByFromNode.has(key)) {
                            edgesByFromNode.set(key, []);
                        }
                        edgesByFromNode.get(key).push({ edge, edgeIndex });
                    });

                    // Track which edges we've rendered
                    const renderedEdgeIndices = new Set();
                    // Track nodes that are rendered as part of parallel outputs (so we don't duplicate them)
                    const renderedAsParallelOutputTarget = new Set();

                    // First pass: identify nodes that will be rendered as parallel output targets
                    flow.edges.forEach(edge => {
                        if (edge.isParallelOutput) {
                            renderedAsParallelOutputTarget.add(edge.toLabel);
                        }
                    });

                    // Render nodes and edges
                    flow.nodes.forEach((node, nodeIndex) => {
                        // Skip nodes that are rendered as part of parallel outputs
                        if (renderedAsParallelOutputTarget.has(node.label)) {
                            return;
                        }

                        // Add "Before Source" description field before the first node (source)
                        if (nodeIndex === 0 && node.type === 'source') {
                            const beforeSourceField = this.createDescriptionField(flowIndex, 'beforeSource', 'Before Source');
                            row.appendChild(beforeSourceField);
                        }

                        // Add node
                        const nodeElement = this.createNodeElement(node);
                        row.appendChild(nodeElement);

                        // Get all edges leaving this node
                        const edgesFromThisNode = edgesByFromNode.get(node.label) || [];
                        
                        // Filter out already rendered edges
                        const unrenderedEdges = edgesFromThisNode.filter(({ edgeIndex }) => !renderedEdgeIndices.has(edgeIndex));
                        
                        if (unrenderedEdges.length === 0) {
                            // No edges to render from this node
                        } else {
                            // Check if these are parallel outputs (different targets) or parallel inputs (same target)
                            const uniqueTargets = new Set(unrenderedEdges.map(({ edge }) => edge.toLabel));
                            const hasParallelOutputs = unrenderedEdges.some(({ edge }) => edge.isParallelOutput);
                            
                            if (hasParallelOutputs && uniqueTargets.size > 1) {
                                // PARALLEL OUTPUTS: one source branching to multiple targets
                                const parallelOutputContainer = this.createParallelOutputsElement(unrenderedEdges, flowIndex);
                                row.appendChild(parallelOutputContainer);
                                unrenderedEdges.forEach(({ edgeIndex }) => renderedEdgeIndices.add(edgeIndex));
                            } else {
                                // Group edges by their target (toLabel) to identify parallel inputs
                                const edgesByTarget = new Map();
                                unrenderedEdges.forEach(({ edge, edgeIndex }) => {
                                    const targetKey = edge.toLabel;
                                    if (!edgesByTarget.has(targetKey)) {
                                        edgesByTarget.set(targetKey, []);
                                    }
                                    edgesByTarget.get(targetKey).push({ edge, edgeIndex });
                                });

                                // Render edges grouped by target
                                edgesByTarget.forEach((targetEdges, targetLabel) => {
                                    if (targetEdges.length === 1) {
                                        // Single edge - render normally
                                        const { edge, edgeIndex } = targetEdges[0];
                                        const edgeElement = this.createEdgeElement(edge, flowIndex, edgeIndex);
                                        row.appendChild(edgeElement);
                                        renderedEdgeIndices.add(edgeIndex);
                                    } else {
                                        // Multiple edges to same target (parallel inputs) - render as stacked edges
                                        const parallelContainer = this.createParallelEdgesElement(targetEdges, flowIndex);
                                        row.appendChild(parallelContainer);
                                        targetEdges.forEach(({ edgeIndex }) => renderedEdgeIndices.add(edgeIndex));
                                    }
                                });
                            }
                        }

                        // Add "After Target" description field after the last node (target)
                        if (nodeIndex === flow.nodes.length - 1 && node.type === 'target') {
                            const afterTargetField = this.createDescriptionField(flowIndex, 'afterTarget', 'After Target');
                            row.appendChild(afterTargetField);
                        }
                    });

                    return row;
                },

                createParallelEdgesElement(edges, flowIndex) {
                    const container = document.createElement('div');
                    container.className = 'flow-edge parallel-edges';

                    // Create stacked arrows - each step gets its own arrow line with its own text fields
                    const arrowsStack = document.createElement('div');
                    arrowsStack.className = 'parallel-arrows-stack';

                    edges.forEach(({ edge, edgeIndex }) => {
                        const stepPrefix = edge.stepNumber ? `${edge.stepNumber}: ` : '';
                        const displayCapability = `${stepPrefix}${edge.protocol} ${edge.direction}`;

                        // Create a row for this step with label + arrow + text fields
                        const stepRow = document.createElement('div');
                        stepRow.className = 'parallel-step-row';

                        // Protocol label
                        const protocolLabel = document.createElement('div');
                        protocolLabel.className = 'edge-protocol parallel-step';
                        protocolLabel.textContent = displayCapability;

                        // Arrow line
                        const lineContainer = document.createElement('div');
                        lineContainer.className = 'edge-line-container';

                        if (edge.flowDirection === 'reverse') {
                            const arrowStart = document.createElement('div');
                            arrowStart.className = 'edge-arrow reverse';
                            lineContainer.appendChild(arrowStart);
                        }

                        const line = document.createElement('div');
                        line.className = 'edge-line';
                        lineContainer.appendChild(line);

                        if (edge.flowDirection === 'forward') {
                            const arrowEnd = document.createElement('div');
                            arrowEnd.className = 'edge-arrow';
                            lineContainer.appendChild(arrowEnd);
                        }

                        // Text fields for this specific edge
                        const edgeTextFields = document.createElement('div');
                        edgeTextFields.className = 'parallel-step-text-fields';

                        // PRE-PROCESSING
                        const preContainer = document.createElement('div');
                        preContainer.className = 'edge-notes-container';
                        const preLabel = document.createElement('div');
                        preLabel.className = 'edge-notes-label';
                        preLabel.textContent = 'PRE-PROCESSING';
                        const preInput = document.createElement('input');
                        preInput.type = 'text';
                        preInput.className = 'edge-notes-input';
                        preInput.placeholder = 'Add notes...';
                        preInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre') || '';
                        preInput.addEventListener('click', (e) => e.stopPropagation());
                        preInput.addEventListener('input', debounce(() => {
                            StateManager.updateAnnotation(flowIndex, edgeIndex, 'pre', preInput.value);
                            Persistence.save();
                        }, 300));
                        preContainer.appendChild(preLabel);
                        preContainer.appendChild(preInput);

                        // POST-PROCESSING
                        const postContainer = document.createElement('div');
                        postContainer.className = 'edge-notes-container';
                        const postLabel = document.createElement('div');
                        postLabel.className = 'edge-notes-label';
                        postLabel.textContent = 'POST-PROCESSING';
                        const postInput = document.createElement('input');
                        postInput.type = 'text';
                        postInput.className = 'edge-notes-input';
                        postInput.placeholder = 'Add notes...';
                        postInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'post') || '';
                        postInput.addEventListener('click', (e) => e.stopPropagation());
                        postInput.addEventListener('input', debounce(() => {
                            StateManager.updateAnnotation(flowIndex, edgeIndex, 'post', postInput.value);
                            Persistence.save();
                        }, 300));
                        postContainer.appendChild(postLabel);
                        postContainer.appendChild(postInput);

                        edgeTextFields.appendChild(preContainer);
                        edgeTextFields.appendChild(postContainer);

                        stepRow.appendChild(protocolLabel);
                        stepRow.appendChild(lineContainer);
                        stepRow.appendChild(edgeTextFields);
                        arrowsStack.appendChild(stepRow);
                    });

                    container.appendChild(arrowsStack);

                    return container;
                },

                createParallelOutputsElement(edges, flowIndex) {
                    // Container for branching outputs (one source to multiple targets)
                    const container = document.createElement('div');
                    container.className = 'parallel-outputs-container';

                    // Create each branch (arrow + target node + text fields)
                    edges.forEach(({ edge, edgeIndex }) => {
                        const branchRow = document.createElement('div');
                        branchRow.className = 'parallel-output-branch';

                        // Create the edge element with text fields
                        const edgeContainer = document.createElement('div');
                        edgeContainer.className = 'flow-edge';

                        const stepPrefix = edge.stepNumber ? `${edge.stepNumber}: ` : '';
                        const displayCapability = `${stepPrefix}${edge.protocol} ${edge.direction}`;

                        // Protocol label
                        const protocolLabel = document.createElement('div');
                        protocolLabel.className = 'edge-protocol parallel-step';
                        protocolLabel.textContent = displayCapability;

                        // Line container with arrow
                        const lineContainer = document.createElement('div');
                        lineContainer.className = 'edge-line-container';

                        if (edge.flowDirection === 'reverse') {
                            const arrowStart = document.createElement('div');
                            arrowStart.className = 'edge-arrow reverse';
                            lineContainer.appendChild(arrowStart);
                        }

                        const line = document.createElement('div');
                        line.className = 'edge-line';
                        lineContainer.appendChild(line);

                        if (edge.flowDirection === 'forward' || !edge.flowDirection) {
                            const arrowEnd = document.createElement('div');
                            arrowEnd.className = 'edge-arrow';
                            lineContainer.appendChild(arrowEnd);
                        }

                        edgeContainer.appendChild(protocolLabel);
                        edgeContainer.appendChild(lineContainer);

                        // Add PRE/POST processing fields for this edge
                        const edgeTextFields = document.createElement('div');
                        edgeTextFields.className = 'edge-text-fields';

                        // PRE-PROCESSING
                        const preContainer = document.createElement('div');
                        preContainer.className = 'edge-notes-container';
                        const preLabel = document.createElement('div');
                        preLabel.className = 'edge-notes-label';
                        preLabel.textContent = 'PRE-PROCESSING';
                        const preInput = document.createElement('input');
                        preInput.type = 'text';
                        preInput.className = 'edge-notes-input';
                        preInput.placeholder = 'Add notes...';
                        preInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre') || '';
                        preInput.addEventListener('click', (e) => e.stopPropagation());
                        preInput.addEventListener('input', debounce(() => {
                            StateManager.updateAnnotation(flowIndex, edgeIndex, 'pre', preInput.value);
                            Persistence.save();
                        }, 300));
                        preContainer.appendChild(preLabel);
                        preContainer.appendChild(preInput);

                        // POST-PROCESSING
                        const postContainer = document.createElement('div');
                        postContainer.className = 'edge-notes-container';
                        const postLabel = document.createElement('div');
                        postLabel.className = 'edge-notes-label';
                        postLabel.textContent = 'POST-PROCESSING';
                        const postInput = document.createElement('input');
                        postInput.type = 'text';
                        postInput.className = 'edge-notes-input';
                        postInput.placeholder = 'Add notes...';
                        postInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'post') || '';
                        postInput.addEventListener('click', (e) => e.stopPropagation());
                        postInput.addEventListener('input', debounce(() => {
                            StateManager.updateAnnotation(flowIndex, edgeIndex, 'post', postInput.value);
                            Persistence.save();
                        }, 300));
                        postContainer.appendChild(postLabel);
                        postContainer.appendChild(postInput);

                        edgeTextFields.appendChild(preContainer);
                        edgeTextFields.appendChild(postContainer);
                        edgeContainer.appendChild(edgeTextFields);

                        // Create target node (properly styled like node-box)
                        const targetNode = document.createElement('div');
                        targetNode.className = 'flow-node';
                        
                        const nodeBox = document.createElement('div');
                        nodeBox.className = 'node-box target';
                        nodeBox.textContent = edge.toLabel;
                        
                        const nodeType = document.createElement('div');
                        nodeType.className = 'node-type';
                        nodeType.textContent = 'TARGET';
                        
                        targetNode.appendChild(nodeBox);
                        targetNode.appendChild(nodeType);

                        // After Target description field
                        const afterTargetField = document.createElement('div');
                        afterTargetField.className = 'flow-description-field after-target';
                        
                        const afterTargetLabel = document.createElement('div');
                        afterTargetLabel.className = 'flow-description-label';
                        afterTargetLabel.textContent = 'After Target';
                        
                        const afterTargetTextarea = document.createElement('textarea');
                        afterTargetTextarea.className = 'flow-description-input';
                        afterTargetTextarea.placeholder = 'Describe post-target steps...';
                        // Use a unique key for each parallel output target
                        const afterTargetKey = `${flowIndex}-afterTarget-${edge.toLabel}`;
                        afterTargetTextarea.value = StateManager.getFlowDescription(flowIndex, `afterTarget-${edge.toLabel}`) || '';
                        afterTargetTextarea.addEventListener('click', (e) => e.stopPropagation());
                        afterTargetTextarea.addEventListener('input', debounce(() => {
                            StateManager.updateFlowDescription(flowIndex, `afterTarget-${edge.toLabel}`, afterTargetTextarea.value);
                            Persistence.save();
                        }, 300));
                        
                        afterTargetField.appendChild(afterTargetLabel);
                        afterTargetField.appendChild(afterTargetTextarea);

                        branchRow.appendChild(edgeContainer);
                        branchRow.appendChild(targetNode);
                        branchRow.appendChild(afterTargetField);
                        container.appendChild(branchRow);
                    });

                    return container;
                },

                createDescriptionField(flowIndex, type, label) {
                    const container = document.createElement('div');
                    container.className = `flow-description-field ${type === 'beforeSource' ? 'before-source' : 'after-target'}`;

                    const labelElement = document.createElement('div');
                    labelElement.className = 'flow-description-label';
                    labelElement.textContent = label;

                    const textarea = document.createElement('textarea');
                    textarea.className = 'flow-description-input';
                    textarea.placeholder = type === 'beforeSource'
                        ? 'Describe pre-source steps...'
                        : 'Describe post-target steps...';
                    textarea.value = StateManager.getFlowDescription(flowIndex, type);

                    // Debounced save
                    let saveTimeout;
                    textarea.addEventListener('input', () => {
                        clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            StateManager.updateFlowDescription(flowIndex, type, textarea.value);
                            Persistence.save();
                        }, 300);
                    });

                    // Stop propagation to prevent row selection when typing
                    textarea.addEventListener('click', (e) => e.stopPropagation());

                    container.appendChild(labelElement);
                    container.appendChild(textarea);

                    return container;
                },

                createNodeElement(node) {
                    const container = document.createElement('div');
                    container.className = 'flow-node';

                    const box = document.createElement('div');
                    box.className = `node-box ${node.type}`;
                    box.textContent = node.label;

                    const typeLabel = document.createElement('div');
                    typeLabel.className = 'node-type';
                    typeLabel.textContent = node.type;

                    container.appendChild(box);
                    container.appendChild(typeLabel);

                    return container;
                },

                createEdgeElement(edge, flowIndex, edgeIndex) {
                    const container = document.createElement('div');
                    container.className = 'flow-edge';

                    // Check if protocol+direction is valid
                    const currentCapability = `${edge.protocol} ${edge.direction}`;
                    // Build display text with step number if present
                    const stepPrefix = edge.stepNumber ? `${edge.stepNumber}: ` : '';
                    const displayCapability = `${stepPrefix}${edge.protocol} ${edge.direction}`;
                    
                    // Ensure functions are available (defensive check)
                    // If function doesn't exist, default to invalid (show dropdown) to be safe
                    let isValid = false;
                    if (typeof isValidCapability === 'function') {
                        try {
                            isValid = isValidCapability(edge.protocol, edge.direction);
                        } catch (e) {
                            console.error('Error checking capability validity:', e);
                            isValid = false; // Default to invalid on error
                        }
                    } else {
                        console.warn('isValidCapability function not found - treating all as potentially invalid');
                        // Default to showing dropdown if function not available
                        isValid = false;
                    }

                    // Protocol label or select dropdown
                    let protocolElement;
                    if (!isValid) {
                        // Create select dropdown for invalid capabilities
                        protocolElement = document.createElement('select');
                        protocolElement.className = 'edge-protocol-select';
                        protocolElement.title = 'Unknown capability - select a valid one';

                        // Get all available capabilities
                        const allCapabilities = getAllAvailableCapabilities();

                        // Add current (invalid) value as first option
                        const currentOption = document.createElement('option');
                        currentOption.value = currentCapability;
                        currentOption.textContent = `${displayCapability} âš `;
                        currentOption.selected = true;
                        protocolElement.appendChild(currentOption);

                        // Add separator
                        const separator = document.createElement('option');
                        separator.disabled = true;
                        separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                        protocolElement.appendChild(separator);

                        // Add all valid capabilities
                        allCapabilities.forEach(cap => {
                            const option = document.createElement('option');
                            option.value = cap;
                            option.textContent = cap;
                            protocolElement.appendChild(option);
                        });

                        // Handle change event
                        protocolElement.addEventListener('change', (e) => {
                            const newCapability = e.target.value;
                            if (newCapability && newCapability !== currentCapability) {
                                this.updateProtocolInPattern(flowIndex, edgeIndex, edge.protocol, edge.direction, newCapability);
                            }
                        });
                    } else {
                        // Create regular div for valid capabilities
                        protocolElement = document.createElement('div');
                        protocolElement.className = 'edge-protocol';
                        protocolElement.textContent = displayCapability;
                    }

                    // Line container
                    const lineContainer = document.createElement('div');
                    lineContainer.className = 'edge-line-container';

                    // Arrow at start if reverse
                    if (edge.flowDirection === 'reverse') {
                        const arrowStart = document.createElement('div');
                        arrowStart.className = 'edge-arrow reverse';
                        lineContainer.appendChild(arrowStart);
                    }

                    // Line
                    const line = document.createElement('div');
                    line.className = 'edge-line';
                    lineContainer.appendChild(line);

                    // Arrow at end if forward
                    if (edge.flowDirection === 'forward') {
                        const arrowEnd = document.createElement('div');
                        arrowEnd.className = 'edge-arrow';
                        lineContainer.appendChild(arrowEnd);
                    }

                    // Annotations container
                    const annotations = document.createElement('div');
                    annotations.className = 'edge-annotations';

                    // Pre-processing annotation
                    const preLabel = document.createElement('div');
                    preLabel.className = 'annotation-label';
                    preLabel.textContent = 'Pre-Processing';

                    const preInput = document.createElement('input');
                    preInput.type = 'text';
                    preInput.className = 'annotation-input';
                    preInput.placeholder = 'Add notes...';
                    preInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre');
                    preInput.addEventListener('input', debounce((e) => {
                        StateManager.updateAnnotation(flowIndex, edgeIndex, 'pre', e.target.value);
                        this.triggerSave();
                    }, 300));

                    // Post-processing annotation
                    const postLabel = document.createElement('div');
                    postLabel.className = 'annotation-label';
                    postLabel.textContent = 'Post-Processing';

                    const postInput = document.createElement('input');
                    postInput.type = 'text';
                    postInput.className = 'annotation-input';
                    postInput.placeholder = 'Add notes...';
                    postInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'post');
                    postInput.addEventListener('input', debounce((e) => {
                        StateManager.updateAnnotation(flowIndex, edgeIndex, 'post', e.target.value);
                        this.triggerSave();
                    }, 300));

                    annotations.appendChild(preLabel);
                    annotations.appendChild(preInput);
                    annotations.appendChild(postLabel);
                    annotations.appendChild(postInput);

                    container.appendChild(protocolElement);
                    container.appendChild(lineContainer);
                    container.appendChild(annotations);

                    return container;
                },

                updateProtocolInPattern(flowIndex, edgeIndex, oldProtocol, oldDirection, newCapability) {
                    // Parse new capability to get protocol and direction
                    const parts = newCapability.split(' ');
                    if (parts.length < 2) return;

                    const newDirection = parts[parts.length - 1];
                    const newProtocol = parts.slice(0, -1).join(' ');

                    // Get current pattern text
                    const patternText = UIController.elements.patternEditor.value;
                    const lines = patternText.split('\n');

                    // Find the flow's line
                    const result = Parser.parseMultiple(patternText);
                    if (!result.flows || flowIndex >= result.flows.length) return;

                    // Find which line contains this flow
                    let flowLineIndex = -1;
                    let currentFlowIndex = 0;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line || line.startsWith('//')) continue;

                        const lineResult = Parser.parseMultiple(line);
                        if (lineResult.flows && lineResult.flows.length > 0) {
                            if (currentFlowIndex === flowIndex) {
                                flowLineIndex = i;
                                break;
                            }
                            currentFlowIndex++;
                        }
                    }

                    if (flowLineIndex === -1) return;

                    // Parse the line to get segments
                    const line = lines[flowLineIndex];
                    const parseResult = Parser.parseMultiple(line);
                    if (!parseResult.flows || parseResult.flows.length === 0) return;

                    const flow = parseResult.flows[0];
                    if (!flow.edges || edgeIndex >= flow.edges.length) return;

                    // Rebuild the line by replacing the specific edge's protocol+direction
                    const entities = flow.nodes.map(n => n.label);
                    const edges = flow.edges;

                    // Rebuild the line string: Entity -> Protocol Direction -> Entity <- Protocol Direction <- Entity
                    const newLineParts = [entities[0]];

                    for (let i = 0; i < edges.length; i++) {
                        const edge = edges[i];
                        const arrow = edge.flowDirection === 'reverse' ? '<-' : '->';
                        const protocol = (i === edgeIndex) ? newProtocol : edge.protocol;
                        const direction = (i === edgeIndex) ? newDirection : edge.direction;

                        newLineParts.push(arrow);
                        newLineParts.push(`${protocol} ${direction}`);
                        newLineParts.push(arrow);
                        newLineParts.push(entities[i + 1]);
                    }

                    const newLine = newLineParts.join(' ');

                    // Update the pattern text
                    lines[flowLineIndex] = newLine;
                    const updatedPattern = lines.join('\n');

                    // Update the editor and trigger re-render
                    UIController.elements.patternEditor.value = updatedPattern;
                    UIController.updatePattern();
                    UIController.setSaveIndicator('saving');
                    Persistence.save();
                    setTimeout(() => UIController.setSaveIndicator('saved'), 500);
                },

                triggerSave() {
                    UIController.setSaveIndicator('saving');
                    Persistence.save();
                    setTimeout(() => UIController.setSaveIndicator('saved'), 500);
                }
            };

            // Make debounce available to DiagramRenderer
            DiagramRenderer.debounce = debounce;

            // ============================================
            // UI CONTROLLER
            // ============================================
            const UIController = {
                elements: {},

                init() {
                    // Cache DOM elements
                    this.elements = {
                        workspaceSelect: document.getElementById('workspaceSelect'),
                        patternEditor: document.getElementById('patternEditor'),
                        lineNumbers: document.getElementById('lineNumbers'),
                        generalNotesField: document.getElementById('generalNotesField'),
                        flowSelector: document.getElementById('flowSelector'),
                        errorMessage: document.getElementById('errorMessage'),
                        saveIndicator: document.getElementById('saveIndicator'),
                        saveText: document.getElementById('saveText'),
                        canvasContainer: document.getElementById('canvasContainer'),
                        emptyState: document.getElementById('emptyState'),
                        modalOverlay: document.getElementById('modalOverlay'),
                        modalTitle: document.getElementById('modalTitle'),
                        modalInput: document.getElementById('modalInput'),
                        modalConfirmBtn: document.getElementById('modalConfirmBtn'),
                        helpPanel: document.getElementById('helpPanel')
                    };

                    this.bindEvents();
                },

                bindEvents() {
                    // Workspace controls
                    document.getElementById('newWorkspaceBtn').addEventListener('click', () => {
                        this.showModal('New Workspace', 'Untitled Workspace', 'Create', (name) => {
                            WorkspaceManager.createWorkspace(name);
                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                        });
                    });

                    document.getElementById('renameWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws) {
                            this.showModal('Rename Workspace', ws.name, 'Rename', (name) => {
                                WorkspaceManager.renameWorkspace(ws.id, name);
                                this.updateWorkspaceSelect();
                            });
                        }
                    });

                    document.getElementById('duplicateWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws) {
                            WorkspaceManager.duplicateWorkspace(ws.id);
                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                        }
                    });

                    document.getElementById('deleteWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws && confirm(`Delete workspace "${ws.name}"?`)) {
                            WorkspaceManager.deleteWorkspace(ws.id);
                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                        }
                    });

                    // Export workspace
                    document.getElementById('exportWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws) {
                            const exportData = {
                                version: 1,
                                exportedAt: new Date().toISOString(),
                                workspace: {
                                    name: ws.name,
                                    patternText: ws.patternText || '',
                                    flowNotes: ws.flowNotes || {},
                                    flowDescriptions: ws.flowDescriptions || {},
                                    annotations: ws.annotations || {}
                                }
                            };
                            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `${ws.name.replace(/[^a-z0-9]/gi, '_')}_workspace.json`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }
                    });

                    // Import workspace
                    const importFileInput = document.getElementById('importFileInput');
                    document.getElementById('importWorkspaceBtn').addEventListener('click', () => {
                        importFileInput.click();
                    });

                    importFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;

                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                if (!data.workspace || !data.workspace.name) {
                                    throw new Error('Invalid workspace file format');
                                }

                                // Create new workspace with imported data
                                const newWorkspace = WorkspaceManager.createWorkspace(data.workspace.name + ' (imported)');
                                // Update the workspace with imported content
                                newWorkspace.patternText = data.workspace.patternText || '';
                                newWorkspace.flowNotes = data.workspace.flowNotes || {};
                                newWorkspace.flowDescriptions = data.workspace.flowDescriptions || {};
                                newWorkspace.annotations = data.workspace.annotations || {};
                                Persistence.save();

                                this.updateWorkspaceSelect();
                                this.loadActiveWorkspace();
                                alert(`Workspace "${data.workspace.name}" imported successfully!`);
                            } catch (err) {
                                alert('Failed to import workspace: ' + err.message);
                            }
                        };
                        reader.readAsText(file);
                        // Reset input so same file can be imported again
                        importFileInput.value = '';
                    });

                    this.elements.workspaceSelect.addEventListener('change', (e) => {
                        StateManager.setActiveWorkspace(e.target.value);
                        this.loadActiveWorkspace();
                    });

                    // Pattern editor
                    const debouncedUpdate = debounce(() => {
                        this.updatePattern();
                        this.setSaveIndicator('saving');
                        Persistence.save();
                        setTimeout(() => this.setSaveIndicator('saved'), 500);
                    }, 300);

                    this.elements.patternEditor.addEventListener('input', () => {
                        this.updateLineNumbers();
                        debouncedUpdate();
                    });

                    // Sync line numbers scroll with textarea scroll
                    this.elements.patternEditor.addEventListener('scroll', () => {
                        this.elements.lineNumbers.scrollTop = this.elements.patternEditor.scrollTop;
                    });

                    // Initial line numbers update
                    this.updateLineNumbers();

                    // Flow selector
                    this.elements.flowSelector.addEventListener('change', (e) => {
                        const flowIndex = e.target.value === '' ? null : parseInt(e.target.value);
                        DiagramRenderer.selectFlow(flowIndex);
                    });

                    // General notes field
                    const debouncedNotesUpdate = debounce(() => {
                        const flowIndex = DiagramRenderer.selectedFlowIndex;
                        if (flowIndex !== null) {
                            StateManager.updateFlowNotes(flowIndex, this.elements.generalNotesField.value);
                            this.setSaveIndicator('saving');
                            Persistence.save();
                            setTimeout(() => this.setSaveIndicator('saved'), 500);
                        }
                    }, 300);

                    this.elements.generalNotesField.addEventListener('input', debouncedNotesUpdate);

                    // Theme toggle
                    document.getElementById('themeToggleBtn').addEventListener('click', () => {
                        const newTheme = StateManager.state.theme === 'light' ? 'dark' : 'light';
                        StateManager.setTheme(newTheme);
                        document.body.setAttribute('data-theme', newTheme);
                        this.updateThemeIcon();
                        Persistence.save();
                    });

                    // Help panel
                    document.getElementById('helpBtn').addEventListener('click', () => {
                        this.elements.helpPanel.classList.add('visible');
                    });

                    document.getElementById('closeHelpBtn').addEventListener('click', () => {
                        this.elements.helpPanel.classList.remove('visible');
                    });

                    // Architecture diagram modal
                    document.getElementById('architectureBtn').addEventListener('click', () => {
                        this.showArchitectureDiagram();
                    });

                    document.getElementById('closeArchitectureBtn').addEventListener('click', () => {
                        this.hideArchitectureDiagram();
                    });

                    document.getElementById('architectureModal').addEventListener('click', (e) => {
                        if (e.target.id === 'architectureModal') {
                            this.hideArchitectureDiagram();
                        }
                    });

                    // Kroki diagram modal
                    document.getElementById('krokiBtn').addEventListener('click', () => {
                        this.showKrokiDiagram();
                    });

                    document.getElementById('closeKrokiBtn').addEventListener('click', () => {
                        this.hideKrokiDiagram();
                    });

                    document.getElementById('krokiModal').addEventListener('click', (e) => {
                        if (e.target.id === 'krokiModal') {
                            this.hideKrokiDiagram();
                        }
                    });

                    document.getElementById('krokiCopyCodeBtn').addEventListener('click', () => {
                        if (this.currentKrokiCode) {
                            navigator.clipboard.writeText(this.currentKrokiCode).then(() => {
                                const btn = document.getElementById('krokiCopyCodeBtn');
                                const originalText = btn.innerHTML;
                                btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!`;
                                setTimeout(() => {
                                    btn.innerHTML = originalText;
                                }, 2000);
                            });
                        }
                    });

                    document.getElementById('krokiOpenExternalBtn').addEventListener('click', () => {
                        if (this.currentKrokiUrl) {
                            window.open(this.currentKrokiUrl, '_blank');
                        }
                    });

                    // Kroki zoom controls
                    document.getElementById('krokiZoomInBtn').addEventListener('click', () => {
                        this.krokiZoom(0.25);
                    });

                    document.getElementById('krokiZoomOutBtn').addEventListener('click', () => {
                        this.krokiZoom(-0.25);
                    });

                    document.getElementById('krokiZoomResetBtn').addEventListener('click', () => {
                        this.krokiZoomReset();
                    });

                    // Kroki mouse wheel zoom
                    const krokiContainer = document.getElementById('krokiCanvasContainer');
                    krokiContainer.addEventListener('wheel', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const delta = e.deltaY > 0 ? -0.1 : 0.1;
                            this.krokiZoom(delta);
                        }
                    }, { passive: false });

                    // Kroki image drag/pan
                    const krokiImage = document.getElementById('krokiImage');
                    let krokiIsDragging = false;
                    let krokiStartX = 0;
                    let krokiStartY = 0;
                    let krokiScrollLeft = 0;
                    let krokiScrollTop = 0;

                    krokiImage.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        krokiIsDragging = true;
                        krokiImage.classList.add('dragging');
                        krokiStartX = e.pageX - krokiContainer.offsetLeft;
                        krokiStartY = e.pageY - krokiContainer.offsetTop;
                        krokiScrollLeft = krokiContainer.scrollLeft;
                        krokiScrollTop = krokiContainer.scrollTop;
                        e.preventDefault();
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!krokiIsDragging) return;
                        const x = e.pageX - krokiContainer.offsetLeft;
                        const y = e.pageY - krokiContainer.offsetTop;
                        const walkX = (x - krokiStartX) * 1.5;
                        const walkY = (y - krokiStartY) * 1.5;
                        krokiContainer.scrollLeft = krokiScrollLeft - walkX;
                        krokiContainer.scrollTop = krokiScrollTop - walkY;
                    });

                    document.addEventListener('mouseup', () => {
                        if (krokiIsDragging) {
                            krokiIsDragging = false;
                            krokiImage.classList.remove('dragging');
                        }
                    });

                    // Architecture canvas panning
                    const archCanvasContainer = document.getElementById('architectureCanvasContainer');
                    let isPanning = false;
                    let panStartX = 0;
                    let panStartY = 0;
                    let scrollLeft = 0;
                    let scrollTop = 0;

                    archCanvasContainer.addEventListener('mousedown', (e) => {
                        isPanning = true;
                        panStartX = e.pageX - archCanvasContainer.offsetLeft;
                        panStartY = e.pageY - archCanvasContainer.offsetTop;
                        scrollLeft = archCanvasContainer.scrollLeft;
                        scrollTop = archCanvasContainer.scrollTop;
                        archCanvasContainer.style.cursor = 'grabbing';
                    });

                    archCanvasContainer.addEventListener('mouseleave', () => {
                        isPanning = false;
                        archCanvasContainer.style.cursor = 'grab';
                    });

                    archCanvasContainer.addEventListener('mouseup', () => {
                        isPanning = false;
                        archCanvasContainer.style.cursor = 'grab';
                    });

                    archCanvasContainer.addEventListener('mousemove', (e) => {
                        if (!isPanning) return;
                        e.preventDefault();
                        const x = e.pageX - archCanvasContainer.offsetLeft;
                        const y = e.pageY - archCanvasContainer.offsetTop;
                        const walkX = (x - panStartX) * 1.5;
                        const walkY = (y - panStartY) * 1.5;
                        archCanvasContainer.scrollLeft = scrollLeft - walkX;
                        archCanvasContainer.scrollTop = scrollTop - walkY;
                    });

                    // Modal
                    document.getElementById('modalCancelBtn').addEventListener('click', () => {
                        this.hideModal();
                    });

                    this.elements.modalInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            this.elements.modalConfirmBtn.click();
                        } else if (e.key === 'Escape') {
                            this.hideModal();
                        }
                    });

                    // Click outside modal to close
                    this.elements.modalOverlay.addEventListener('click', (e) => {
                        if (e.target === this.elements.modalOverlay) {
                            this.hideModal();
                        }
                    });

                    // Keyboard shortcuts
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            // Close kroki modal if open
                            const krokiModal = document.getElementById('krokiModal');
                            if (krokiModal.classList.contains('visible')) {
                                this.hideKrokiDiagram();
                                return;
                            }
                            // Close architecture modal if open
                            const archModal = document.getElementById('architectureModal');
                            if (archModal.classList.contains('visible')) {
                                this.hideArchitectureDiagram();
                                return;
                            }
                        }
                        if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                            e.preventDefault();
                            document.getElementById('themeToggleBtn').click();
                        } else if (e.ctrlKey && e.key === 'n') {
                            e.preventDefault();
                            document.getElementById('newWorkspaceBtn').click();
                        }
                    });
                },

                updateWorkspaceSelect() {
                    const select = this.elements.workspaceSelect;
                    select.innerHTML = '';

                    StateManager.state.workspaces.forEach((ws, id) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = ws.name;
                        option.selected = id === StateManager.state.activeWorkspaceId;
                        select.appendChild(option);
                    });
                },

                loadActiveWorkspace() {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        this.elements.patternEditor.value = ws.patternText || '';
                        DiagramRenderer.selectedFlowIndex = null;
                        this.updateLineNumbers();
                        this.updatePattern();
                    }
                },

                updatePattern() {
                    const text = this.elements.patternEditor.value;
                    StateManager.updatePattern(text);

                    const result = Parser.parseMultiple(text);

                    if (result.errors.length > 0) {
                        this.showErrors(result.errors);
                    } else {
                        this.hideError();
                    }

                    DiagramRenderer.render(result.flows, this.elements.canvasContainer);

                    // Update flow analysis panel
                    this.updateFlowAnalysis(result.flows, text);
                },

                updateFlowAnalysis(flows, text) {
                    // Update stats
                    const flowCount = flows.length;
                    const uniqueNodes = new Set();
                    const protocolsUsed = new Map();

                    flows.forEach(flow => {
                        if (flow && flow.nodes) {
                            flow.nodes.forEach(node => {
                                uniqueNodes.add(node.label);
                            });
                        }
                        if (flow && flow.edges) {
                            flow.edges.forEach(edge => {
                                const protocol = edge.protocol;
                                if (protocol) {
                                    protocolsUsed.set(protocol, (protocolsUsed.get(protocol) || 0) + 1);
                                }
                            });
                        }
                    });

                    document.getElementById('statFlowCount').textContent = flowCount;
                    document.getElementById('statNodeCount').textContent = uniqueNodes.size;
                    document.getElementById('statProtocolCount').textContent = protocolsUsed.size;

                    // Update protocol tags
                    const protocolTags = document.getElementById('protocolTags');
                    if (protocolsUsed.size > 0) {
                        protocolTags.innerHTML = Array.from(protocolsUsed.entries())
                            .sort((a, b) => b[1] - a[1])
                            .map(([protocol, count]) =>
                                `<span class="protocol-tag" data-protocol="${protocol}">${protocol}<span class="tag-count">${count}</span></span>`
                            ).join('');

                        // Add click handlers for protocol tags
                        protocolTags.querySelectorAll('.protocol-tag').forEach(tag => {
                            tag.addEventListener('click', () => {
                                const protocol = tag.dataset.protocol;
                                this.highlightProtocolInEditor(protocol);
                            });
                        });
                    } else {
                        protocolTags.innerHTML = '<span style="color: var(--text-muted); font-size: 11px; font-style: italic;">No protocols detected</span>';
                    }

                    // Update flow navigation combobox
                    const flowNavSelect = document.getElementById('flowNavSelect');
                    const lines = text.split('\n');

                    if (flowCount > 0) {
                        let flowLineIndex = 0;
                        let optionsHtml = '<option value="">-- Select a flow --</option>';

                        flows.forEach((flow, index) => {
                            // Find the line for this flow
                            while (flowLineIndex < lines.length && lines[flowLineIndex].trim() === '') {
                                flowLineIndex++;
                            }
                            const lineNum = flowLineIndex + 1;
                            flowLineIndex++;

                            // Create preview from nodes
                            const preview = flow.nodes ? flow.nodes.map(n => n.label).join(' â†’ ') : 'Flow ' + (index + 1);
                            const isSelected = DiagramRenderer.selectedFlowIndex === index;

                            optionsHtml += `<option value="${index}" data-line="${lineNum}" ${isSelected ? 'selected' : ''}>L${lineNum}: ${preview}</option>`;
                        });

                        flowNavSelect.innerHTML = optionsHtml;

                        // Add change handler
                        flowNavSelect.onchange = () => {
                            const selectedOption = flowNavSelect.options[flowNavSelect.selectedIndex];
                            if (selectedOption.value !== '') {
                                const flowIndex = parseInt(selectedOption.value);
                                const lineNum = parseInt(selectedOption.dataset.line);
                                DiagramRenderer.selectFlow(flowIndex);
                                this.scrollToLine(lineNum);
                            }
                        };
                    } else {
                        flowNavSelect.innerHTML = '<option value="">-- No flows defined --</option>';
                    }
                },

                highlightProtocolInEditor(protocol) {
                    const editor = this.elements.patternEditor;
                    const text = editor.value;
                    const regex = new RegExp(protocol, 'gi');
                    const match = regex.exec(text);

                    if (match) {
                        editor.focus();
                        editor.setSelectionRange(match.index, match.index + match[0].length);

                        // Calculate approximate line and scroll
                        const textBefore = text.substring(0, match.index);
                        const lineNum = textBefore.split('\n').length;
                        this.scrollToLine(lineNum);
                    }
                },

                scrollToLine(lineNum) {
                    const editor = this.elements.patternEditor;
                    const lineHeight = 22.4; // matches CSS
                    const scrollTop = (lineNum - 1) * lineHeight;
                    editor.scrollTop = scrollTop;
                    this.elements.lineNumbers.scrollTop = scrollTop;
                },

                showErrors(errors) {
                    const errorHtml = errors.map(e =>
                        `<div class="error-line">Line ${e.line}: ${e.message}</div>`
                    ).join('');
                    this.elements.errorMessage.innerHTML = errorHtml;
                    this.elements.errorMessage.classList.add('visible');
                },

                hideError() {
                    this.elements.errorMessage.classList.remove('visible');
                },

                updateLineNumbers() {
                    const text = this.elements.patternEditor.value;
                    const lines = text.split('\n');
                    const lineCount = lines.length || 1;

                    // Generate line numbers HTML
                    let lineNumbersHtml = '';
                    for (let i = 1; i <= lineCount; i++) {
                        lineNumbersHtml += `<span>${i}</span>`;
                    }

                    this.elements.lineNumbers.innerHTML = lineNumbersHtml;
                },

                setSaveIndicator(status) {
                    const indicator = this.elements.saveIndicator;
                    indicator.classList.remove('saving', 'saved');
                    indicator.classList.add(status);
                    this.elements.saveText.textContent = status === 'saving' ? 'Saving...' : 'Saved';
                },

                async copyFlowAsPng(flowRow, flowIndex) {
                    if (typeof html2canvas === 'undefined') {
                        alert('PNG export library not loaded. Please refresh the page.');
                        return;
                    }

                    const copyBtn = flowRow.querySelector('.flow-copy-btn');
                    const originalHtml = copyBtn.innerHTML;

                    try {
                        // Show loading state
                        copyBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinning">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M12 6v6l4 2"></path>
                        </svg>`;

                        // Create a wrapper container for the entire export
                        const wrapper = document.createElement('div');
                        wrapper.style.position = 'absolute';
                        wrapper.style.left = '-9999px';
                        wrapper.style.top = '0';
                        wrapper.style.backgroundColor = '#ffffff';
                        wrapper.style.padding = '24px';
                        wrapper.style.borderRadius = '8px';
                        wrapper.style.display = 'flex';
                        wrapper.style.flexDirection = 'column';
                        wrapper.style.gap = '16px';
                        wrapper.style.fontFamily = 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

                        // Add flow title
                        const title = document.createElement('div');
                        title.style.fontSize = '16px';
                        title.style.fontWeight = '600';
                        title.style.color = '#1e293b';
                        title.style.borderBottom = '2px solid #e2e8f0';
                        title.style.paddingBottom = '8px';
                        title.textContent = `Flow ${flowIndex + 1}`;
                        wrapper.appendChild(title);

                        // Clone the flow row for rendering
                        const clone = flowRow.cloneNode(true);
                        clone.style.backgroundColor = 'transparent';
                        clone.style.display = 'inline-flex';
                        clone.style.border = 'none';
                        clone.style.boxShadow = 'none';
                        
                        // Remove the copy button and row header from clone
                        clone.querySelectorAll('.flow-row-header').forEach(el => el.remove());
                        clone.querySelectorAll('.flow-copy-btn').forEach(el => el.remove());

                        // Replace inputs/textareas with static text divs to preserve values
                        clone.querySelectorAll('input, textarea').forEach(el => {
                            const value = el.value || el.placeholder || '';
                            const staticDiv = document.createElement('div');
                            staticDiv.textContent = value;
                            staticDiv.style.padding = '6px 8px';
                            staticDiv.style.fontSize = '11px';
                            staticDiv.style.color = value === el.placeholder ? '#94a3b8' : '#334155';
                            staticDiv.style.fontStyle = value === el.placeholder ? 'italic' : 'normal';
                            staticDiv.style.background = '#fffbeb';
                            staticDiv.style.border = '1px dashed #fcd34d';
                            staticDiv.style.borderRadius = '4px';
                            staticDiv.style.textAlign = 'center';
                            staticDiv.style.minHeight = el.tagName === 'TEXTAREA' ? '40px' : 'auto';
                            staticDiv.style.whiteSpace = el.tagName === 'TEXTAREA' ? 'pre-wrap' : 'nowrap';
                            if (el.parentNode) {
                                el.parentNode.replaceChild(staticDiv, el);
                            }
                        });
                        
                        // Fix arrow lines for rendering
                        clone.querySelectorAll('.edge-line').forEach(el => {
                            el.style.backgroundImage = 'none';
                            el.style.backgroundColor = '#64748b';
                            el.style.animation = 'none';
                        });
                        clone.querySelectorAll('.edge-arrow').forEach(el => {
                            if (el.classList.contains('reverse')) {
                                el.style.borderRightColor = '#64748b';
                            } else {
                                el.style.borderLeftColor = '#64748b';
                            }
                        });

                        // Fix node colors for light background
                        clone.querySelectorAll('.node-box.source').forEach(el => {
                            el.style.background = '#dbeafe';
                            el.style.borderColor = '#3b82f6';
                            el.style.color = '#1e40af';
                        });
                        clone.querySelectorAll('.node-box.intermediate').forEach(el => {
                            el.style.background = '#fef9c3';
                            el.style.borderColor = '#eab308';
                            el.style.color = '#713f12';
                        });
                        clone.querySelectorAll('.node-box.target').forEach(el => {
                            el.style.background = '#dcfce7';
                            el.style.borderColor = '#22c55e';
                            el.style.color = '#166534';
                        });

                        // Fix text colors
                        clone.querySelectorAll('.node-type, .flow-description-label, .edge-notes-label, .annotation-label').forEach(el => {
                            el.style.color = '#64748b';
                        });
                        clone.querySelectorAll('.edge-protocol').forEach(el => {
                            el.style.background = '#eff6ff';
                            el.style.borderColor = '#3b82f6';
                            el.style.color = '#1d4ed8';
                        });

                        wrapper.appendChild(clone);

                        // Add General Notes section if there are notes
                        const generalNotes = StateManager.getFlowNotes(flowIndex);
                        if (generalNotes && generalNotes.trim()) {
                            const notesSection = document.createElement('div');
                            notesSection.style.marginTop = '8px';
                            notesSection.style.padding = '12px';
                            notesSection.style.background = '#f8fafc';
                            notesSection.style.borderRadius = '6px';
                            notesSection.style.border = '1px solid #e2e8f0';

                            const notesLabel = document.createElement('div');
                            notesLabel.style.fontSize = '10px';
                            notesLabel.style.fontWeight = '600';
                            notesLabel.style.color = '#64748b';
                            notesLabel.style.textTransform = 'uppercase';
                            notesLabel.style.letterSpacing = '0.5px';
                            notesLabel.style.marginBottom = '6px';
                            notesLabel.textContent = 'GENERAL NOTES';
                            notesSection.appendChild(notesLabel);

                            const notesContent = document.createElement('div');
                            notesContent.style.fontSize = '12px';
                            notesContent.style.color = '#334155';
                            notesContent.style.whiteSpace = 'pre-wrap';
                            notesContent.style.lineHeight = '1.5';
                            notesContent.textContent = generalNotes;
                            notesSection.appendChild(notesContent);

                            wrapper.appendChild(notesSection);
                        }

                        document.body.appendChild(wrapper);

                        // Wait for rendering
                        await new Promise(resolve => setTimeout(resolve, 100));

                        // Capture as canvas
                        const canvas = await html2canvas(wrapper, {
                            scale: 2,
                            backgroundColor: '#ffffff',
                            useCORS: true,
                            logging: false
                        });

                        // Clean up wrapper
                        document.body.removeChild(wrapper);

                        // Convert to blob and copy to clipboard
                        canvas.toBlob(async (blob) => {
                            try {
                                await navigator.clipboard.write([
                                    new ClipboardItem({ 'image/png': blob })
                                ]);
                                
                                // Show success
                                copyBtn.classList.add('copied');
                                copyBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>`;
                                
                                setTimeout(() => {
                                    copyBtn.classList.remove('copied');
                                    copyBtn.innerHTML = originalHtml;
                                }, 2000);
                            } catch (err) {
                                console.error('Failed to copy to clipboard:', err);
                                // Fallback: download the image
                                const link = document.createElement('a');
                                link.download = `flow_${flowIndex + 1}.png`;
                                link.href = canvas.toDataURL('image/png');
                                link.click();
                                
                                copyBtn.innerHTML = originalHtml;
                            }
                        }, 'image/png');

                    } catch (error) {
                        console.error('Failed to generate PNG:', error);
                        alert('Failed to generate PNG: ' + error.message);
                        copyBtn.innerHTML = originalHtml;
                    }
                },

                showModal(title, defaultValue, confirmText, onConfirm) {
                    this.elements.modalTitle.textContent = title;
                    this.elements.modalInput.value = defaultValue;
                    this.elements.modalConfirmBtn.textContent = confirmText;
                    this.elements.modalOverlay.classList.add('visible');
                    this.elements.modalInput.focus();
                    this.elements.modalInput.select();

                    const confirmHandler = () => {
                        const value = this.elements.modalInput.value.trim();
                        if (value) {
                            onConfirm(value);
                            this.hideModal();
                        }
                    };

                    this.elements.modalConfirmBtn.onclick = confirmHandler;
                },

                hideModal() {
                    this.elements.modalOverlay.classList.remove('visible');
                },

                showArchitectureDiagram() {
                    const modal = document.getElementById('architectureModal');
                    const canvas = document.getElementById('architectureCanvas');

                    // Get current flows
                    const text = this.elements.patternEditor.value;
                    const result = Parser.parseMultiple(text);
                    const flows = result.flows;

                    if (flows.length === 0) {
                        alert('No flows defined. Add some flow patterns first.');
                        return;
                    }

                    // Build unique nodes and connections
                    const uniqueNodes = new Map(); // label -> { type, connections }
                    const uniqueConnections = new Map(); // "from|to|protocol|direction" -> { from, to, protocol, direction, flowDirection }
                    const protocolsUsed = new Set();

                    flows.forEach(flow => {
                        if (!flow || !flow.nodes || !flow.edges) return;

                        // Track nodes with their types
                        flow.nodes.forEach(node => {
                            if (!uniqueNodes.has(node.label)) {
                                uniqueNodes.set(node.label, {
                                    label: node.label,
                                    type: node.type,
                                    connections: new Set()
                                });
                            }
                        });

                        // Track unique connections
                        flow.edges.forEach(edge => {
                            const connectionKey = `${edge.fromLabel}|${edge.toLabel}|${edge.protocol}|${edge.direction}|${edge.flowDirection}`;
                            if (!uniqueConnections.has(connectionKey)) {
                                uniqueConnections.set(connectionKey, {
                                    from: edge.fromLabel,
                                    to: edge.toLabel,
                                    protocol: edge.protocol,
                                    direction: edge.direction,
                                    flowDirection: edge.flowDirection
                                });

                                // Track connections for each node
                                uniqueNodes.get(edge.fromLabel).connections.add(edge.toLabel);
                                uniqueNodes.get(edge.toLabel).connections.add(edge.fromLabel);
                            }
                            protocolsUsed.add(edge.protocol);
                        });
                    });

                    // Update stats
                    document.getElementById('archStatNodes').textContent = uniqueNodes.size;
                    document.getElementById('archStatConnections').textContent = uniqueConnections.size;
                    document.getElementById('archStatProtocols').textContent = protocolsUsed.size;

                    // Generate the diagram
                    this.generateArchitectureSVG(canvas, uniqueNodes, uniqueConnections);

                    // Show modal
                    modal.classList.add('visible');

                    // Center the view
                    const container = document.getElementById('architectureCanvasContainer');
                    setTimeout(() => {
                        container.scrollLeft = (canvas.clientWidth - container.clientWidth) / 2;
                        container.scrollTop = (canvas.clientHeight - container.clientHeight) / 2;
                    }, 100);
                },

                hideArchitectureDiagram() {
                    document.getElementById('architectureModal').classList.remove('visible');
                },

                // Kroki diagram state
                currentKrokiCode: null,
                currentKrokiUrl: null,
                krokiZoomLevel: 4.5,
                krokiMinZoom: 0.5,
                krokiMaxZoom: 10,
                krokiBaseWidth: null,
                krokiBaseHeight: null,

                krokiZoom(delta) {
                    const newZoom = Math.max(this.krokiMinZoom, Math.min(this.krokiMaxZoom, this.krokiZoomLevel + delta));
                    if (newZoom !== this.krokiZoomLevel) {
                        this.krokiZoomLevel = newZoom;
                        this.applyKrokiZoom();
                    }
                },

                krokiZoomReset() {
                    this.krokiZoomLevel = 1;
                    this.applyKrokiZoom();
                    // Also reset scroll position to center
                    const container = document.getElementById('krokiCanvasContainer');
                    const wrapper = document.getElementById('krokiImageWrapper');
                    setTimeout(() => {
                        container.scrollLeft = (wrapper.scrollWidth - container.clientWidth) / 2;
                        container.scrollTop = (wrapper.scrollHeight - container.clientHeight) / 2;
                    }, 50);
                },

                applyKrokiZoom() {
                    const image = document.getElementById('krokiImage');
                    const zoomLabel = document.getElementById('krokiZoomLevel');
                    
                    if (this.krokiBaseWidth && this.krokiBaseHeight) {
                        image.style.width = `${this.krokiBaseWidth * this.krokiZoomLevel}px`;
                        image.style.height = `${this.krokiBaseHeight * this.krokiZoomLevel}px`;
                    }
                    zoomLabel.textContent = `${Math.round(this.krokiZoomLevel * 100)}%`;
                },

                async showKrokiDiagram() {
                    const modal = document.getElementById('krokiModal');
                    const loading = document.getElementById('krokiLoading');
                    const image = document.getElementById('krokiImage');

                    // Get current flows
                    const text = this.elements.patternEditor.value;
                    const result = Parser.parseMultiple(text);
                    const flows = result.flows;

                    if (flows.length === 0) {
                        alert('No flows defined. Add some flow patterns first.');
                        return;
                    }

                    // Show modal with loading state
                    modal.classList.add('visible');
                    loading.classList.remove('hidden');
                    image.classList.remove('visible');

                    // Build unique nodes and connections
                    const uniqueNodes = new Map();
                    const uniqueConnections = new Map();

                    flows.forEach(flow => {
                        if (!flow || !flow.nodes || !flow.edges) return;

                        flow.nodes.forEach(node => {
                            if (!uniqueNodes.has(node.label)) {
                                uniqueNodes.set(node.label, {
                                    label: node.label,
                                    type: node.type
                                });
                            }
                        });

                        flow.edges.forEach(edge => {
                            const connectionKey = `${edge.fromLabel}|${edge.toLabel}|${edge.protocol}|${edge.direction}`;
                            if (!uniqueConnections.has(connectionKey)) {
                                uniqueConnections.set(connectionKey, {
                                    from: edge.fromLabel,
                                    to: edge.toLabel,
                                    protocol: edge.protocol,
                                    direction: edge.direction,
                                    flowDirection: edge.flowDirection
                                });
                            }
                        });
                    });

                    // Update stats
                    document.getElementById('krokiStatNodes').textContent = uniqueNodes.size;
                    document.getElementById('krokiStatConnections').textContent = uniqueConnections.size;

                    // Generate D2 code
                    const d2Code = this.generateD2Code(uniqueNodes, uniqueConnections);
                    this.currentKrokiCode = d2Code;

                    try {
                        // Encode D2 code for Kroki API
                        const encoded = this.encodeKrokiDiagram(d2Code);
                        const krokiUrl = `https://kroki.io/d2/svg/${encoded}`;
                        this.currentKrokiUrl = krokiUrl;

                        // Fetch the diagram
                        const response = await fetch(krokiUrl);
                        if (!response.ok) {
                            throw new Error(`Kroki API error: ${response.status}`);
                        }

                        const svgText = await response.text();
                        
                        // Convert SVG to data URL for the image
                        const svgBlob = new Blob([svgText], { type: 'image/svg+xml' });
                        const svgUrl = URL.createObjectURL(svgBlob);

                        image.onload = () => {
                            // Store the natural dimensions as base for zoom
                            this.krokiBaseWidth = image.naturalWidth;
                            this.krokiBaseHeight = image.naturalHeight;
                            
                            // Set initial zoom to 450%
                            this.krokiZoomLevel = 4.5;
                            image.style.width = `${this.krokiBaseWidth * this.krokiZoomLevel}px`;
                            image.style.height = `${this.krokiBaseHeight * this.krokiZoomLevel}px`;
                            document.getElementById('krokiZoomLevel').textContent = '450%';
                            
                            loading.classList.add('hidden');
                            image.classList.add('visible');
                            URL.revokeObjectURL(svgUrl);
                            
                            // Center the view after image loads
                            const container = document.getElementById('krokiCanvasContainer');
                            const wrapper = document.getElementById('krokiImageWrapper');
                            setTimeout(() => {
                                container.scrollLeft = Math.max(0, (wrapper.scrollWidth - container.clientWidth) / 2);
                                container.scrollTop = Math.max(0, (wrapper.scrollHeight - container.clientHeight) / 2);
                            }, 50);
                        };

                        image.onerror = () => {
                            loading.innerHTML = `<div class="kroki-error"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg><span>Failed to load diagram</span></div>`;
                        };

                        image.src = svgUrl;
                    } catch (error) {
                        console.error('Kroki diagram error:', error);
                        loading.innerHTML = `<div class="kroki-error"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg><span>Failed to generate diagram: ${error.message}</span></div>`;
                    }
                },

                hideKrokiDiagram() {
                    const modal = document.getElementById('krokiModal');
                    const loading = document.getElementById('krokiLoading');
                    const image = document.getElementById('krokiImage');
                    
                    modal.classList.remove('visible');
                    
                    // Reset state for next time
                    loading.classList.remove('hidden');
                    loading.innerHTML = `<div class="kroki-spinner"></div><span>Generating diagram...</span>`;
                    image.classList.remove('visible');
                    image.src = '';
                    
                    // Reset zoom
                    this.krokiZoomLevel = 1;
                    this.krokiBaseWidth = null;
                    this.krokiBaseHeight = null;
                    image.style.width = '';
                    image.style.height = '';
                    document.getElementById('krokiZoomLevel').textContent = '100%';
                },

                generateD2Code(nodes, connections) {
                    const lines = [];
                    
                    // Add title
                    lines.push('# MFT Flow Architecture');
                    lines.push('');

                    // Define node styles based on type
                    const nodeStyles = {
                        source: 'style.fill: "#e8f5e9"\nstyle.stroke: "#2e7d32"\nstyle.font-color: "#1b5e20"',
                        intermediate: 'style.fill: "#e3f2fd"\nstyle.stroke: "#1565c0"\nstyle.font-color: "#0d47a1"',
                        target: 'style.fill: "#fce4ec"\nstyle.stroke: "#c2185b"\nstyle.font-color: "#880e4f"'
                    };

                    // Helper to create safe D2 identifiers
                    const safeId = (label) => {
                        return label.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
                    };

                    // Declare nodes with their styles
                    const nodeArray = Array.from(nodes.values());
                    nodeArray.forEach(node => {
                        const id = safeId(node.label);
                        const style = nodeStyles[node.type] || nodeStyles.intermediate;
                        lines.push(`${id}: "${node.label}" {`);
                        lines.push(`  shape: rectangle`);
                        style.split('\n').forEach(s => lines.push(`  ${s}`));
                        lines.push(`}`);
                        lines.push('');
                    });

                    // Add connections with protocol labels
                    const connectionArray = Array.from(connections.values());
                    connectionArray.forEach(conn => {
                        const fromId = safeId(conn.from);
                        const toId = safeId(conn.to);
                        const label = `${conn.protocol} (${conn.direction})`;
                        
                        // Use different arrow styles based on direction
                        const arrow = conn.direction === 'PUSH' ? '->' : '<-';
                        lines.push(`${fromId} ${arrow} ${toId}: "${label}" {`);
                        lines.push(`  style.stroke: "#546e7a"`);
                        lines.push(`  style.font-size: 12`);
                        lines.push(`}`);
                    });

                    // Add legend
                    lines.push('');
                    lines.push('legend: "Legend" {');
                    lines.push('  Source: "Source" {');
                    lines.push('    style.fill: "#e8f5e9"');
                    lines.push('    style.stroke: "#2e7d32"');
                    lines.push('  }');
                    lines.push('  Intermediate: "MFT Hub" {');
                    lines.push('    style.fill: "#e3f2fd"');
                    lines.push('    style.stroke: "#1565c0"');
                    lines.push('  }');
                    lines.push('  Target: "Target" {');
                    lines.push('    style.fill: "#fce4ec"');
                    lines.push('    style.stroke: "#c2185b"');
                    lines.push('  }');
                    lines.push('}');

                    return lines.join('\n');
                },

                encodeKrokiDiagram(source) {
                    // Kroki uses zlib deflate + base64url encoding
                    // pako.deflate (without raw:true) produces zlib format which is what Kroki expects
                    const data = new TextEncoder().encode(source);
                    const compressed = pako.deflate(data, { level: 9 });
                    return this.base64UrlEncode(compressed);
                },

                base64UrlEncode(data) {
                    // Convert Uint8Array to base64url
                    let binary = '';
                    for (let i = 0; i < data.length; i++) {
                        binary += String.fromCharCode(data[i]);
                    }
                    const base64 = btoa(binary);
                    // Convert to base64url
                    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                },

                generateArchitectureSVG(svg, nodes, connections) {
                    // Clear existing content
                    svg.innerHTML = '';

                    const nodeArray = Array.from(nodes.values());
                    const connectionArray = Array.from(connections.values());

                    // Layout configuration
                    const nodeWidth = 120;
                    const nodeHeight = 45;
                    const padding = 120;
                    const radialDistance = 280; // Distance from hub to connected nodes

                    // Build adjacency map to count connections per node
                    const adjacencyMap = new Map();
                    nodeArray.forEach(node => {
                        adjacencyMap.set(node.label, {
                            node: node,
                            connectedTo: new Set(),
                            connectionCount: 0
                        });
                    });

                    connectionArray.forEach(conn => {
                        if (adjacencyMap.has(conn.from) && adjacencyMap.has(conn.to)) {
                            adjacencyMap.get(conn.from).connectedTo.add(conn.to);
                            adjacencyMap.get(conn.to).connectedTo.add(conn.from);
                            adjacencyMap.get(conn.from).connectionCount++;
                            adjacencyMap.get(conn.to).connectionCount++;
                        }
                    });

                    // Sort nodes by connection count (hubs first)
                    const sortedNodes = Array.from(adjacencyMap.values())
                        .sort((a, b) => b.connectionCount - a.connectionCount);

                    const nodePositions = new Map();
                    const placedNodes = new Set();

                    // Helper function to check if a position overlaps with existing nodes
                    const checkOverlap = (x, y, minDist = 140) => {
                        for (const [label, pos] of nodePositions) {
                            const dx = pos.x + nodeWidth/2 - (x + nodeWidth/2);
                            const dy = pos.y + nodeHeight/2 - (y + nodeHeight/2);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) return true;
                        }
                        return false;
                    };

                    // Helper to find best position for a node
                    const findBestPosition = (node, preferredX, preferredY, connectedPositions) => {
                        let bestX = preferredX;
                        let bestY = preferredY;
                        
                        // Try the preferred position first
                        if (!checkOverlap(bestX, bestY)) {
                            return { x: bestX, y: bestY };
                        }
                        
                        // Try positions in a spiral pattern around preferred
                        for (let radius = 100; radius <= 500; radius += 80) {
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                const testX = preferredX + Math.cos(angle) * radius;
                                const testY = preferredY + Math.sin(angle) * radius;
                                if (testX >= padding && testY >= padding && !checkOverlap(testX, testY)) {
                                    return { x: testX, y: testY };
                                }
                            }
                        }
                        
                        return { x: bestX, y: bestY };
                    };

                    // Place nodes using a hub-centric radial layout
                    let centerX = padding + 350;
                    let centerY = padding + 280;

                    sortedNodes.forEach((nodeData, index) => {
                        if (placedNodes.has(nodeData.node.label)) return;

                        const node = nodeData.node;
                        const connectedNodes = Array.from(nodeData.connectedTo);
                        const unplacedConnected = connectedNodes.filter(n => !placedNodes.has(n));

                        // If this is a hub (has multiple connections) and not yet placed
                        if (nodeData.connectionCount >= 2 && unplacedConnected.length >= 2) {
                            // Place hub at center
                            const hubPos = findBestPosition(node, centerX, centerY, []);
                            nodePositions.set(node.label, { x: hubPos.x, y: hubPos.y, type: node.type });
                            placedNodes.add(node.label);

                            // Place connected nodes radially around the hub
                            const hubCenterX = hubPos.x + nodeWidth / 2;
                            const hubCenterY = hubPos.y + nodeHeight / 2;

                            // Separate connected nodes by type for better organization
                            const connectedSources = unplacedConnected.filter(n => adjacencyMap.get(n).node.type === 'source');
                            const connectedTargets = unplacedConnected.filter(n => adjacencyMap.get(n).node.type === 'target');
                            const connectedIntermediates = unplacedConnected.filter(n => adjacencyMap.get(n).node.type === 'intermediate');

                            // Place sources on the left (around -150 to -210 degrees, i.e., left side)
                            connectedSources.forEach((connLabel, i) => {
                                const angleStart = Math.PI * 0.65; // ~120 degrees
                                const angleRange = Math.PI * 0.7; // spread over 126 degrees
                                const angle = angleStart + (connectedSources.length > 1 ? (i / (connectedSources.length - 1)) * angleRange : angleRange / 2);
                                const x = hubCenterX + Math.cos(angle) * radialDistance - nodeWidth / 2;
                                const y = hubCenterY + Math.sin(angle) * radialDistance - nodeHeight / 2;
                                const pos = findBestPosition(adjacencyMap.get(connLabel).node, x, y, []);
                                nodePositions.set(connLabel, { x: pos.x, y: pos.y, type: adjacencyMap.get(connLabel).node.type });
                                placedNodes.add(connLabel);
                            });

                            // Place targets on the right (around -30 to 30 degrees)
                            connectedTargets.forEach((connLabel, i) => {
                                const angleStart = -Math.PI * 0.35; // -63 degrees
                                const angleRange = Math.PI * 0.7; // spread over 126 degrees
                                const angle = angleStart + (connectedTargets.length > 1 ? (i / (connectedTargets.length - 1)) * angleRange : angleRange / 2);
                                const x = hubCenterX + Math.cos(angle) * radialDistance - nodeWidth / 2;
                                const y = hubCenterY + Math.sin(angle) * radialDistance - nodeHeight / 2;
                                const pos = findBestPosition(adjacencyMap.get(connLabel).node, x, y, []);
                                nodePositions.set(connLabel, { x: pos.x, y: pos.y, type: adjacencyMap.get(connLabel).node.type });
                                placedNodes.add(connLabel);
                            });

                            // Place intermediates at top/bottom
                            connectedIntermediates.forEach((connLabel, i) => {
                                const angleStart = Math.PI * 0.35;
                                const angleRange = Math.PI * 0.3;
                                const angle = (i % 2 === 0 ? -1 : 1) * (angleStart + Math.floor(i/2) * 0.3);
                                const x = hubCenterX + Math.cos(angle) * radialDistance * 1.2 - nodeWidth / 2;
                                const y = hubCenterY + Math.sin(angle) * radialDistance * 1.2 - nodeHeight / 2;
                                const pos = findBestPosition(adjacencyMap.get(connLabel).node, x, y, []);
                                nodePositions.set(connLabel, { x: pos.x, y: pos.y, type: adjacencyMap.get(connLabel).node.type });
                                placedNodes.add(connLabel);
                            });

                            // Move center for next hub
                            centerX += 650;
                            if (centerX > 1600) {
                                centerX = padding + 400;
                                centerY += 500;
                            }
                        }
                    });

                    // Place any remaining unplaced nodes
                    sortedNodes.forEach(nodeData => {
                        if (placedNodes.has(nodeData.node.label)) return;

                        const node = nodeData.node;
                        const connectedNodes = Array.from(nodeData.connectedTo);
                        const placedConnected = connectedNodes.filter(n => placedNodes.has(n));

                        if (placedConnected.length > 0) {
                            // Place near an already-placed connected node
                            const connectedPos = nodePositions.get(placedConnected[0]);
                            let preferredX, preferredY;
                            
                            // Position based on node type
                            if (node.type === 'source') {
                                preferredX = connectedPos.x - radialDistance;
                                preferredY = connectedPos.y;
                            } else if (node.type === 'target') {
                                preferredX = connectedPos.x + radialDistance;
                                preferredY = connectedPos.y;
                            } else {
                                preferredX = connectedPos.x;
                                preferredY = connectedPos.y - radialDistance;
                            }
                            
                            const pos = findBestPosition(node, preferredX, preferredY, [connectedPos]);
                            nodePositions.set(node.label, { x: pos.x, y: pos.y, type: node.type });
                            placedNodes.add(node.label);
                        } else {
                            // No connections, place in a default area
                            const pos = findBestPosition(node, centerX, centerY, []);
                            nodePositions.set(node.label, { x: pos.x, y: pos.y, type: node.type });
                            placedNodes.add(node.label);
                            centerY += nodeHeight + 60;
                        }
                    });

                    // Calculate canvas size based on actual node positions
                    let maxX = 0, maxY = 0, minX = Infinity, minY = Infinity;
                    nodePositions.forEach(pos => {
                        maxX = Math.max(maxX, pos.x + nodeWidth);
                        maxY = Math.max(maxY, pos.y + nodeHeight);
                        minX = Math.min(minX, pos.x);
                        minY = Math.min(minY, pos.y);
                    });

                    // Normalize positions to start from padding
                    const offsetX = padding - minX;
                    const offsetY = padding - minY;
                    nodePositions.forEach((pos, label) => {
                        pos.x += offsetX;
                        pos.y += offsetY;
                    });

                    const canvasWidth = maxX - minX + padding * 2;
                    const canvasHeight = maxY - minY + padding * 2;

                    svg.setAttribute('width', Math.max(canvasWidth, 800));
                    svg.setAttribute('height', Math.max(canvasHeight, 500));
                    svg.setAttribute('viewBox', `0 0 ${Math.max(canvasWidth, 800)} ${Math.max(canvasHeight, 500)}`);

                    // Define arrow markers
                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    defs.innerHTML = `
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--edge-color)" />
                    </marker>
                `;
                    svg.appendChild(defs);

                    // Group connections by: visual arrow direction (fromâ†’to) + PUSH/PULL
                    // This consolidates multiple protocols into single arrows while keeping
                    // arrows in different directions separate
                    const consolidatedConnections = new Map();
                    
                    connectionArray.forEach(conn => {
                        // Determine the visual arrow direction (where the arrowhead points)
                        // For forward arrows (->): arrow goes from conn.from to conn.to
                        // For reverse arrows (<-): arrow goes from conn.to to conn.from
                        const visualFrom = conn.flowDirection === 'reverse' ? conn.to : conn.from;
                        const visualTo = conn.flowDirection === 'reverse' ? conn.from : conn.to;
                        
                        // Key combines: visual direction (fromâ†’to) + PUSH/PULL
                        // This ensures Aâ†’B PUSH and Bâ†’A PUSH are separate arrows
                        const directionKey = `${visualFrom}â†’${visualTo}|${conn.direction}`;
                        
                        if (!consolidatedConnections.has(directionKey)) {
                            consolidatedConnections.set(directionKey, {
                                from: visualFrom,      // Visual start of arrow
                                to: visualTo,          // Visual end of arrow (where arrowhead is)
                                direction: conn.direction,
                                protocols: new Set()
                            });
                        }
                        consolidatedConnections.get(directionKey).protocols.add(conn.protocol);
                    });

                    // Group consolidated connections by node pair for offset calculation
                    // This groups arrows between the same two nodes (regardless of direction)
                    const connectionsByPair = new Map();
                    consolidatedConnections.forEach((conn, key) => {
                        // Sort to get consistent pair key regardless of arrow direction
                        const pairKey = [conn.from, conn.to].sort().join('|');
                        if (!connectionsByPair.has(pairKey)) {
                            connectionsByPair.set(pairKey, []);
                        }
                        connectionsByPair.get(pairKey).push(conn);
                    });

                    // Draw consolidated connections
                    connectionsByPair.forEach((pairConnections, pairKey) => {
                        const [nodeA, nodeB] = pairKey.split('|');
                        
                        // Get positions for consistent reference direction
                        const posA = nodePositions.get(nodeA);
                        const posB = nodePositions.get(nodeB);
                        if (!posA || !posB) return;
                        
                        // Calculate a consistent reference angle from A to B (used for both directions)
                        const refCenterAX = posA.x + nodeWidth / 2;
                        const refCenterAY = posA.y + nodeHeight / 2;
                        const refCenterBX = posB.x + nodeWidth / 2;
                        const refCenterBY = posB.y + nodeHeight / 2;
                        const referenceAngle = Math.atan2(refCenterBY - refCenterAY, refCenterBX - refCenterAX);
                        
                        // Separate connections by direction: Aâ†’B vs Bâ†’A
                        const forwardConns = pairConnections.filter(c => c.from === nodeA && c.to === nodeB);
                        const reverseConns = pairConnections.filter(c => c.from === nodeB && c.to === nodeA);
                        
                        // Calculate base offset: if bidirectional, separate the two directions
                        const hasBidirectional = forwardConns.length > 0 && reverseConns.length > 0;
                        const baseOffset = hasBidirectional ? 20 : 0; // Base separation for bidirectional
                        const offsetStep = 18; // Additional offset for multiple arrows in same direction
                        
                        // Helper function to draw a group of connections
                        // curveSign: +1 for one direction, -1 for opposite (consistent regardless of arrow direction)
                        const drawConnectionGroup = (connections, curveSign, withinGroupStartIndex) => {
                            connections.forEach((conn, index) => {
                                const fromPos = nodePositions.get(conn.from);
                                const toPos = nodePositions.get(conn.to);

                                if (!fromPos || !toPos) return;

                                // Calculate node centers
                                const fromCenterX = fromPos.x + nodeWidth / 2;
                                const fromCenterY = fromPos.y + nodeHeight / 2;
                                const toCenterX = toPos.x + nodeWidth / 2;
                                const toCenterY = toPos.y + nodeHeight / 2;

                                // Calculate angle between nodes (from source to target)
                                const angle = Math.atan2(toCenterY - fromCenterY, toCenterX - fromCenterX);

                                // Calculate edge points - connect from the edge of the node closest to target
                                let x1, y1, x2, y2;
                                
                                // Determine connection points based on angle
                                const absAngle = Math.abs(angle);
                                const threshold = Math.atan2(nodeHeight, nodeWidth);

                                if (absAngle < threshold || absAngle > Math.PI - threshold) {
                                    // Connect horizontally (left/right sides)
                                    if (angle > -Math.PI / 2 && angle < Math.PI / 2) {
                                        x1 = fromPos.x + nodeWidth;
                                        x2 = toPos.x;
                                    } else {
                                        x1 = fromPos.x;
                                        x2 = toPos.x + nodeWidth;
                                    }
                                    y1 = fromCenterY;
                                    y2 = toCenterY;
                                } else {
                                    // Connect vertically (top/bottom sides)
                                    if (angle > 0) {
                                        y1 = fromPos.y + nodeHeight;
                                        y2 = toPos.y;
                                    } else {
                                        y1 = fromPos.y;
                                        y2 = toPos.y + nodeHeight;
                                    }
                                    x1 = fromCenterX;
                                    x2 = toCenterX;
                                }

                                // Create curved path
                                const midX = (x1 + x2) / 2;
                                const midY = (y1 + y2) / 2;
                                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                
                                // Calculate distance for curvature
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                // Use REFERENCE angle for perpendicular direction (consistent for both arrow directions)
                                const perpX = -Math.sin(referenceAngle);
                                const perpY = Math.cos(referenceAngle);
                                
                                // Calculate curvature: base + extra for multiple connections
                                const withinGroupOffset = index * offsetStep;
                                const totalCurve = baseOffset + withinGroupOffset + dist * 0.08;
                                
                                // Control point using consistent perpendicular direction
                                const ctrl1X = midX + perpX * totalCurve * curveSign;
                                const ctrl1Y = midY + perpY * totalCurve * curveSign;
                            
                                const d = `M ${x1} ${y1} Q ${ctrl1X} ${ctrl1Y}, ${x2} ${y2}`;
                                
                                path.setAttribute('d', d);
                                path.setAttribute('fill', 'none');
                                path.setAttribute('stroke', 'var(--edge-color)');
                                path.setAttribute('stroke-width', '2');

                                // Arrow always points to 'to' node (we normalized direction during consolidation)
                                path.setAttribute('marker-end', 'url(#arrowhead)');

                                svg.appendChild(path);

                                // Create consolidated label: "PUSH: FTP, SFTP, PeSIT" or "PULL: HTTP, HTTPS"
                                const protocolList = Array.from(conn.protocols).sort().join(', ');
                                const labelText = `${conn.direction}: ${protocolList}`;
                                
                                // Position label at the curve midpoint with offset
                                const labelX = ctrl1X;
                                const labelY = ctrl1Y;

                                // Calculate label width based on text length
                                const labelWidth = Math.max(labelText.length * 5.5 + 16, 80);
                                const labelHeight = 18;

                                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                labelBg.setAttribute('x', labelX - labelWidth / 2);
                                labelBg.setAttribute('y', labelY - labelHeight / 2);
                                labelBg.setAttribute('width', labelWidth);
                                labelBg.setAttribute('height', labelHeight);
                                labelBg.setAttribute('rx', '9');
                                labelBg.setAttribute('fill', 'var(--bg-secondary)');
                                labelBg.setAttribute('stroke', 'var(--border-color)');
                                labelBg.setAttribute('stroke-width', '1');
                                svg.appendChild(labelBg);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', labelX);
                                label.setAttribute('y', labelY + 4);
                                label.setAttribute('text-anchor', 'middle');
                                label.setAttribute('font-size', '10');
                                label.setAttribute('font-weight', '500');
                                label.setAttribute('fill', 'var(--text-secondary)');
                                label.textContent = labelText;
                                svg.appendChild(label);
                            });
                        };
                        
                        // Draw forward connections (Aâ†’B) curving one way
                        if (forwardConns.length > 0) {
                            drawConnectionGroup(forwardConns, hasBidirectional ? 1 : 0, 0);
                        }
                        
                        // Draw reverse connections (Bâ†’A) curving the opposite way
                        if (reverseConns.length > 0) {
                            drawConnectionGroup(reverseConns, hasBidirectional ? -1 : 0, 0);
                        }
                    });

                    // Draw nodes
                    nodePositions.forEach((pos, label) => {
                        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                        // Node rectangle
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', pos.x);
                        rect.setAttribute('y', pos.y);
                        rect.setAttribute('width', nodeWidth);
                        rect.setAttribute('height', nodeHeight);
                        rect.setAttribute('rx', '8');

                        // Apply colors based on type
                        if (pos.type === 'source') {
                            rect.setAttribute('fill', 'var(--node-source)');
                            rect.setAttribute('stroke', 'var(--node-source-border)');
                        } else if (pos.type === 'target') {
                            rect.setAttribute('fill', 'var(--node-target)');
                            rect.setAttribute('stroke', 'var(--node-target-border)');
                        } else {
                            rect.setAttribute('fill', 'var(--node-intermediate)');
                            rect.setAttribute('stroke', 'var(--node-intermediate-border)');
                        }
                        rect.setAttribute('stroke-width', '2');
                        group.appendChild(rect);

                        // Node label
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', pos.x + nodeWidth / 2);
                        text.setAttribute('y', pos.y + nodeHeight / 2 + 4);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '13');
                        text.setAttribute('font-weight', '500');

                        if (pos.type === 'source') {
                            text.setAttribute('fill', 'var(--node-source-border)');
                        } else if (pos.type === 'target') {
                            text.setAttribute('fill', 'var(--node-target-border)');
                        } else {
                            text.setAttribute('fill', 'var(--text-primary)');
                        }
                        text.textContent = label;
                        group.appendChild(text);

                        svg.appendChild(group);
                    });
                },

                updateThemeIcon() {
                    const icon = document.getElementById('themeIcon');
                    if (StateManager.state.theme === 'dark') {
                        icon.innerHTML = `
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    `;
                    } else {
                        icon.innerHTML = `
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    `;
                    }
                }
            };

            // ============================================
            // ============================================
            // APPLICATION INITIALIZATION
            // ============================================
            function initApp() {
                // Initialize workspace manager (loads from storage or creates default)
                WorkspaceManager.initialize();

                // Apply saved theme
                document.body.setAttribute('data-theme', StateManager.state.theme);

                // Initialize UI
                UIController.init();
                UIController.updateWorkspaceSelect();
                UIController.loadActiveWorkspace();
                UIController.updateThemeIcon();
            }

            // Start the application when DOM is ready
            document.addEventListener('DOMContentLoaded', initApp);
        </script>
</body>

</html>