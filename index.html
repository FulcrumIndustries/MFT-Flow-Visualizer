<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MFT Flow Visualizer</title>
    <style>
        /* ============================================
           CSS VARIABLES & THEMES
           ============================================ */
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            --transition-speed: 0.2s;
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Light Theme */
        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --node-source: #dbeafe;
            --node-source-border: #3b82f6;
            --node-intermediate: #f1f5f9;
            --node-intermediate-border: #64748b;
            --node-target: #dcfce7;
            --node-target-border: #10b981;
            --edge-color: #64748b;
            --canvas-bg: #fafafa;
            --gradient-start: #f0f4ff;
            --gradient-end: #faf5ff;
            --annotation-bg: #fffbeb;
            --annotation-border: #fcd34d;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --accent-primary: #60a5fa;
            --accent-secondary: #34d399;
            --accent-warning: #fbbf24;
            --accent-danger: #f87171;
            --node-source: #1e3a5f;
            --node-source-border: #60a5fa;
            --node-intermediate: #334155;
            --node-intermediate-border: #94a3b8;
            --node-target: #14532d;
            --node-target-border: #34d399;
            --edge-color: #94a3b8;
            --canvas-bg: #0f172a;
            --gradient-start: #1e1b4b;
            --gradient-end: #1e293b;
            --annotation-bg: #422006;
            --annotation-border: #b45309;
        }

        /* ============================================
           BASE STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: var(--text-primary);
            transition: background var(--transition-speed), color var(--transition-speed);
        }

        /* Grainy texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* ============================================
           LAYOUT
           ============================================ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* ============================================
           HEADER
           ============================================ */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .workspace-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            min-width: 180px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .workspace-select:hover {
            border-color: var(--accent-primary);
        }

        .workspace-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
        }

        .btn-danger {
            color: var(--accent-danger);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--accent-danger);
        }

        /* ============================================
           EDITOR SECTION
           ============================================ */
        .editor-section {
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .editor-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .save-indicator {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .save-indicator.saving {
            color: var(--accent-warning);
        }

        .save-indicator.saved {
            color: var(--accent-secondary);
        }

        .pattern-editor {
            width: 100%;
            min-height: 120px;
            padding: 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .pattern-editor:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .pattern-editor::placeholder {
            color: var(--text-muted);
        }

        .error-message {
            margin-top: 8px;
            padding: 10px 14px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-danger);
            border-radius: var(--border-radius);
            color: var(--accent-danger);
            font-size: 13px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        .error-line {
            margin-bottom: 4px;
        }

        .error-line:last-child {
            margin-bottom: 0;
        }

        /* ============================================
           CANVAS SECTION
           ============================================ */
        .canvas-section {
            flex: 1;
            position: relative;
            overflow: auto;
            background: var(--canvas-bg);
        }

        .canvas-container {
            min-width: 100%;
            min-height: 100%;
            padding: 20px;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .empty-state-description {
            font-size: 14px;
            max-width: 300px;
        }

        /* ============================================
           FLOW ROW STYLES
           ============================================ */
        .flow-row {
            display: flex;
            align-items: center;
            margin-bottom: 40px;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            position: relative;
        }

        .flow-row:last-child {
            margin-bottom: 0;
        }

        .flow-row-number {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--accent-primary);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .flow-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
            flex-shrink: 0;
        }

        .node-box {
            padding: 12px 20px;
            border-radius: var(--border-radius);
            border: 2px solid;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            min-width: 100px;
            transition: all var(--transition-speed);
        }

        .node-box.source {
            background: var(--node-source);
            border-color: var(--node-source-border);
            color: var(--node-source-border);
        }

        .node-box.intermediate {
            background: var(--node-intermediate);
            border-color: var(--node-intermediate-border);
            color: var(--text-primary);
        }

        .node-box.target {
            background: var(--node-target);
            border-color: var(--node-target-border);
            color: var(--node-target-border);
        }

        .node-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 6px;
            color: var(--text-muted);
        }

        /* ============================================
           EDGE / CONNECTION STYLES
           ============================================ */
        .flow-edge {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
            min-width: 160px;
            position: relative;
        }

        .edge-line-container {
            display: flex;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .edge-line {
            flex: 1;
            height: 2px;
            background: var(--edge-color);
            position: relative;
        }

        .edge-line::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(90deg,
                    var(--edge-color) 0,
                    var(--edge-color) 6px,
                    transparent 6px,
                    transparent 10px);
            animation: flowDash 0.5s linear infinite;
        }

        @keyframes flowDash {
            to {
                transform: translateX(10px);
            }
        }

        .edge-arrow {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid var(--edge-color);
            flex-shrink: 0;
        }

        .edge-arrow.reverse {
            border-left: none;
            border-right: 10px solid var(--edge-color);
        }

        .edge-protocol {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        /* ============================================
           ANNOTATION INPUT STYLES
           ============================================ */
        .edge-annotations {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            width: 100%;
        }

        .annotation-input {
            width: 100%;
            padding: 6px 8px;
            font-size: 11px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            text-align: center;
            transition: all var(--transition-speed);
        }

        .annotation-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .annotation-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        .annotation-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        /* ============================================
           MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 24px;
            min-width: 360px;
            max-width: 90%;
            box-shadow: var(--shadow-lg);
            transform: scale(0.95);
            transition: transform var(--transition-speed);
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* ============================================
           HELP PANEL
           ============================================ */
        .help-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: right var(--transition-speed);
            overflow-y: auto;
        }

        .help-panel.visible {
            right: 0;
        }

        .help-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .help-panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .help-panel-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .help-section p {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .help-example {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            color: var(--text-primary);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                gap: 12px;
            }

            .header-left {
                width: 100%;
                justify-content: space-between;
            }

            .workspace-controls {
                width: 100%;
            }

            .workspace-select {
                flex: 1;
            }

            .help-panel {
                width: 100%;
                right: -100%;
            }

            .flow-row {
                overflow-x: auto;
            }
        }
    </style>
</head>

<body data-theme="light">
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <div class="logo">
                    <div class="logo-icon">⇌</div>
                    <span>MFT Flow Visualizer</span>
                </div>
                <div class="workspace-controls">
                    <select id="workspaceSelect" class="workspace-select">
                        <option value="">Loading...</option>
                    </select>
                    <button id="newWorkspaceBtn" class="btn btn-primary btn-icon" title="New Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <button id="renameWorkspaceBtn" class="btn btn-icon" title="Rename Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                        </svg>
                    </button>
                    <button id="duplicateWorkspaceBtn" class="btn btn-icon" title="Duplicate Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button id="deleteWorkspaceBtn" class="btn btn-icon btn-danger" title="Delete Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                            </path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="header-right">
                <button id="themeToggleBtn" class="btn btn-icon" title="Toggle Theme">
                    <svg id="themeIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <button id="helpBtn" class="btn btn-icon" title="Help">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Editor Section -->
        <section class="editor-section">
            <div class="editor-header">
                <span class="editor-title">Flow Patterns (one per line)</span>
                <span id="saveIndicator" class="save-indicator saved">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    <span id="saveText">Saved</span>
                </span>
            </div>
            <textarea id="patternEditor" class="pattern-editor" placeholder="Enter your MFT flow patterns here (one per line)...

Examples:
TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF" spellcheck="false"></textarea>
            <div id="errorMessage" class="error-message"></div>
        </section>

        <!-- Canvas Section -->
        <section class="canvas-section">
            <div id="canvasContainer" class="canvas-container">
                <!-- Flow rows will be rendered here -->
            </div>

            <div id="emptyState" class="empty-state">
                <div class="empty-state-icon">⇌</div>
                <div class="empty-state-title">No Flows Defined</div>
                <div class="empty-state-description">
                    Enter flow patterns in the editor above to visualize your MFT flows.
                </div>
            </div>
        </section>
    </div>

    <!-- Help Panel -->
    <div id="helpPanel" class="help-panel">
        <div class="help-panel-header">
            <span class="help-panel-title">Help & Syntax Guide</span>
            <button id="closeHelpBtn" class="btn btn-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="help-panel-content">
            <div class="help-section">
                <h3 class="help-section-title">Pattern Syntax</h3>
                <p>Define MFT flows using a simple text-based syntax. Enter one pattern per line.</p>
                <div class="help-example">SOURCE -> PROTOCOL DIRECTION -> MIDDLE -> PROTOCOL DIRECTION -> TARGET</div>
            </div>
            <div class="help-section">
                <h3 class="help-section-title">Examples</h3>
                <div class="help-example">TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
                    TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
                    TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF
                        TESTZ -> PeSIT PUSH -> ST -> JMS PUSH -> SFC -> EBICS PUSH -> BANK1</div>
            </div>
            <div class="help-section">
                <h3 class="help-section-title">Components</h3>
                <p><strong>Entities:</strong> Names like TESTA, ST, CFT (alphanumeric + underscores)</p>
                <p><strong>Protocols:</strong> SFTP, PeSIT, HTTPS, FTP, AS2, SSH, JMS, EBICS, etc.</p>
                <p><strong>Directions:</strong> PULL (fetch data) or PUSH (send data)</p>
                <p><strong>Arrows:</strong> <- (left) and -> (right) indicate flow direction</p>
            </div>
            <div class="help-section">
                <h3 class="help-section-title">Annotations</h3>
                <p>Each connection has editable annotation fields for pre-processing and post-processing notes. Click on
                    the yellow dashed boxes to add annotations.</p>
            </div>
        </div>
    </div>

    <!-- Modal for Rename/New Workspace -->
    <div id="modalOverlay" class="modal-overlay">
        <div class="modal">
            <h2 id="modalTitle" class="modal-title">New Workspace</h2>
            <input type="text" id="modalInput" class="modal-input" placeholder="Workspace name">
            <div class="modal-actions">
                <button id="modalCancelBtn" class="btn">Cancel</button>
                <button id="modalConfirmBtn" class="btn btn-primary">Create</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function generateId() {
            return 'ws_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ============================================
        // STATE MANAGER
        // ============================================
        const StateManager = {
            state: {
                workspaces: new Map(),
                activeWorkspaceId: null,
                theme: 'light'
            },
            listeners: [],

            subscribe(listener) {
                this.listeners.push(listener);
                return () => {
                    this.listeners = this.listeners.filter(l => l !== listener);
                };
            },

            notify(event) {
                this.listeners.forEach(listener => listener(event, this.state));
            },

            getActiveWorkspace() {
                return this.state.workspaces.get(this.state.activeWorkspaceId);
            },

            setActiveWorkspace(id) {
                if (this.state.workspaces.has(id)) {
                    this.state.activeWorkspaceId = id;
                    this.notify({ type: 'WORKSPACE_CHANGED', workspaceId: id });
                }
            },

            updatePattern(text) {
                const workspace = this.getActiveWorkspace();
                if (workspace) {
                    workspace.patternText = text;
                    workspace.metadata.updatedAt = Date.now();
                    this.notify({ type: 'PATTERN_UPDATED', workspaceId: workspace.id });
                }
            },

            updateAnnotation(flowIndex, edgeIndex, field, value) {
                const workspace = this.getActiveWorkspace();
                if (workspace) {
                    if (!workspace.annotations) {
                        workspace.annotations = {};
                    }
                    const key = `${flowIndex}-${edgeIndex}-${field}`;
                    workspace.annotations[key] = value;
                    workspace.metadata.updatedAt = Date.now();
                    this.notify({ type: 'ANNOTATION_UPDATED', workspaceId: workspace.id });
                }
            },

            getAnnotation(flowIndex, edgeIndex, field) {
                const workspace = this.getActiveWorkspace();
                if (workspace && workspace.annotations) {
                    const key = `${flowIndex}-${edgeIndex}-${field}`;
                    return workspace.annotations[key] || '';
                }
                return '';
            },

            setTheme(theme) {
                this.state.theme = theme;
                this.notify({ type: 'THEME_CHANGED', theme });
            }
        };

        // ============================================
        // PERSISTENCE LAYER
        // ============================================
        const Persistence = {
            STORAGE_KEY: 'mft_flow_visualizer',
            VERSION: '1.1.0',

            save() {
                try {
                    const data = {
                        version: this.VERSION,
                        activeWorkspaceId: StateManager.state.activeWorkspaceId,
                        theme: StateManager.state.theme,
                        workspaces: Array.from(StateManager.state.workspaces.entries()).map(([id, ws]) => ({
                            id: ws.id,
                            name: ws.name,
                            patternText: ws.patternText,
                            annotations: ws.annotations || {},
                            metadata: ws.metadata
                        }))
                    };
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('Failed to save:', e);
                    return false;
                }
            },

            load() {
                try {
                    const raw = localStorage.getItem(this.STORAGE_KEY);
                    if (!raw) return null;

                    const data = JSON.parse(raw);

                    // Convert workspaces array back to Map
                    const workspaces = new Map();
                    if (data.workspaces) {
                        data.workspaces.forEach(ws => {
                            workspaces.set(ws.id, {
                                ...ws,
                                annotations: ws.annotations || {}
                            });
                        });
                    }

                    return {
                        ...data,
                        workspaces
                    };
                } catch (e) {
                    console.error('Failed to load:', e);
                    return null;
                }
            },

            clear() {
                localStorage.removeItem(this.STORAGE_KEY);
            }
        };

        // ============================================
        // WORKSPACE MANAGER
        // ============================================
        const WorkspaceManager = {
            createWorkspace(name = 'Untitled Workspace') {
                const id = generateId();
                const workspace = {
                    id,
                    name,
                    patternText: '',
                    annotations: {},
                    metadata: {
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        version: '1.0.0'
                    }
                };
                StateManager.state.workspaces.set(id, workspace);
                StateManager.setActiveWorkspace(id);
                Persistence.save();
                return workspace;
            },

            renameWorkspace(id, newName) {
                const workspace = StateManager.state.workspaces.get(id);
                if (workspace) {
                    workspace.name = newName;
                    workspace.metadata.updatedAt = Date.now();
                    StateManager.notify({ type: 'WORKSPACE_RENAMED', workspaceId: id });
                    Persistence.save();
                }
            },

            duplicateWorkspace(id) {
                const original = StateManager.state.workspaces.get(id);
                if (original) {
                    const newId = generateId();
                    const duplicate = {
                        ...JSON.parse(JSON.stringify(original)),
                        id: newId,
                        name: original.name + ' (Copy)',
                        metadata: {
                            createdAt: Date.now(),
                            updatedAt: Date.now(),
                            version: original.metadata.version
                        }
                    };
                    StateManager.state.workspaces.set(newId, duplicate);
                    StateManager.setActiveWorkspace(newId);
                    Persistence.save();
                    return duplicate;
                }
                return null;
            },

            deleteWorkspace(id) {
                if (StateManager.state.workspaces.size <= 1) {
                    alert('Cannot delete the last workspace');
                    return false;
                }

                StateManager.state.workspaces.delete(id);

                // Switch to another workspace
                const firstId = StateManager.state.workspaces.keys().next().value;
                StateManager.setActiveWorkspace(firstId);
                Persistence.save();
                return true;
            },

            initialize() {
                const saved = Persistence.load();

                if (saved && saved.workspaces.size > 0) {
                    StateManager.state.workspaces = saved.workspaces;
                    StateManager.state.theme = saved.theme || 'light';

                    // Set active workspace
                    if (saved.activeWorkspaceId && saved.workspaces.has(saved.activeWorkspaceId)) {
                        StateManager.setActiveWorkspace(saved.activeWorkspaceId);
                    } else {
                        const firstId = saved.workspaces.keys().next().value;
                        StateManager.setActiveWorkspace(firstId);
                    }
                } else {
                    // Create default workspace
                    this.createWorkspace('My First Flow');
                }
            }
        };

        // ============================================
        // PARSER ENGINE
        // ============================================
        const Parser = {
            parseMultiple(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const results = [];
                const errors = [];

                lines.forEach((line, index) => {
                    const result = this.parseLine(line.trim(), index + 1);
                    if (result.error) {
                        errors.push({ line: index + 1, message: result.error });
                    } else if (result.nodes.length > 0) {
                        results.push({
                            lineNumber: index + 1,
                            originalText: line.trim(),
                            nodes: result.nodes,
                            edges: result.edges
                        });
                    }
                });

                return { flows: results, errors };
            },

            parseLine(text, lineNumber) {
                const result = {
                    nodes: [],
                    edges: [],
                    error: null
                };

                if (!text || !text.trim()) {
                    return result;
                }

                const trimmed = text.trim();

                // Tokenize the pattern
                const tokens = this.tokenize(trimmed);

                if (tokens.error) {
                    result.error = tokens.error;
                    return result;
                }

                // Build nodes and edges from tokens
                const { nodes, edges, error } = this.buildGraph(tokens.segments);

                if (error) {
                    result.error = error;
                    return result;
                }

                result.nodes = nodes;
                result.edges = edges;

                return result;
            },

            tokenize(text) {
                const segments = [];

                // Split by arrows while keeping track of direction
                const arrowPattern = /(<-|->)/g;
                const parts = text.split(arrowPattern).map(p => p.trim()).filter(p => p);

                if (parts.length < 5) {
                    return { error: 'Invalid pattern. Expected: Entity -> PROTOCOL DIRECTION -> Entity' };
                }

                let currentIndex = 0;

                // First entity
                const firstEntity = parts[currentIndex];
                if (!this.isValidEntity(firstEntity)) {
                    return { error: `Invalid entity name: "${firstEntity}"` };
                }
                segments.push({ type: 'entity', value: firstEntity });
                currentIndex++;

                while (currentIndex < parts.length) {
                    // Expect arrow
                    const arrow1 = parts[currentIndex];
                    if (arrow1 !== '<-' && arrow1 !== '->') {
                        return { error: `Expected arrow (<- or ->), got: "${arrow1}"` };
                    }
                    currentIndex++;

                    // Expect PROTOCOL DIRECTION
                    if (currentIndex >= parts.length) {
                        return { error: 'Unexpected end of pattern after arrow' };
                    }
                    const protocolDir = parts[currentIndex];
                    const pdMatch = protocolDir.match(/^([A-Za-z0-9_]+)\s+(PULL|PUSH)$/i);
                    if (!pdMatch) {
                        return { error: `Invalid protocol/direction: "${protocolDir}". Expected: PROTOCOL PULL/PUSH` };
                    }
                    currentIndex++;

                    // Expect second arrow (should match the first in direction sense)
                    if (currentIndex >= parts.length) {
                        return { error: 'Unexpected end of pattern, expected arrow' };
                    }
                    const arrow2 = parts[currentIndex];
                    if (arrow2 !== '<-' && arrow2 !== '->') {
                        return { error: `Expected arrow (<- or ->), got: "${arrow2}"` };
                    }

                    // Validate arrow consistency
                    if (arrow1 !== arrow2) {
                        return { error: `Inconsistent arrows: ${arrow1} and ${arrow2}. Both should match.` };
                    }
                    currentIndex++;

                    // Expect entity
                    if (currentIndex >= parts.length) {
                        return { error: 'Unexpected end of pattern, expected entity' };
                    }
                    const entity = parts[currentIndex];
                    if (!this.isValidEntity(entity)) {
                        return { error: `Invalid entity name: "${entity}"` };
                    }

                    segments.push({
                        type: 'connection',
                        arrow: arrow1,
                        protocol: pdMatch[1].toUpperCase(),
                        direction: pdMatch[2].toUpperCase(),
                        toEntity: entity
                    });

                    segments.push({ type: 'entity', value: entity });
                    currentIndex++;
                }

                return { segments };
            },

            isValidEntity(str) {
                return /^[A-Za-z][A-Za-z0-9_]*$/.test(str);
            },

            buildGraph(segments) {
                const nodes = [];
                const edges = [];
                const nodeMap = new Map();

                let nodeIndex = 0;

                // First pass: collect all unique entities
                segments.forEach(seg => {
                    if (seg.type === 'entity' && !nodeMap.has(seg.value)) {
                        nodeMap.set(seg.value, nodeIndex++);
                    }
                });

                // Determine node types based on position
                const entityList = segments.filter(s => s.type === 'entity').map(s => s.value);

                entityList.forEach((entity, idx) => {
                    let type = 'intermediate';
                    if (idx === 0) type = 'source';
                    else if (idx === entityList.length - 1) type = 'target';

                    nodes.push({
                        id: 'node_' + idx,
                        label: entity,
                        type: type,
                        index: idx
                    });
                });

                // Second pass: build edges
                let lastEntity = null;
                let edgeIndex = 0;
                segments.forEach(seg => {
                    if (seg.type === 'entity') {
                        lastEntity = seg.value;
                    } else if (seg.type === 'connection' && lastEntity) {
                        const fromEntity = lastEntity;
                        const toEntity = seg.toEntity;

                        // Determine actual from/to based on arrow direction
                        let flowDirection = seg.arrow === '<-' ? 'reverse' : 'forward';

                        edges.push({
                            id: 'edge_' + edgeIndex,
                            fromLabel: fromEntity,
                            toLabel: toEntity,
                            protocol: seg.protocol,
                            direction: seg.direction,
                            flowDirection: flowDirection,
                            index: edgeIndex
                        });
                        edgeIndex++;
                    }
                });

                return { nodes, edges, error: null };
            }
        };

        // ============================================
        // DIAGRAM RENDERER
        // ============================================
        const DiagramRenderer = {
            render(flows, container) {
                container.innerHTML = '';

                if (!flows || flows.length === 0) {
                    document.getElementById('emptyState').style.display = 'block';
                    return;
                }

                document.getElementById('emptyState').style.display = 'none';

                flows.forEach((flow, flowIndex) => {
                    const rowElement = this.createFlowRow(flow, flowIndex);
                    container.appendChild(rowElement);
                });
            },

            createFlowRow(flow, flowIndex) {
                const row = document.createElement('div');
                row.className = 'flow-row';

                // Row number indicator
                const rowNumber = document.createElement('div');
                rowNumber.className = 'flow-row-number';
                rowNumber.textContent = `Flow ${flowIndex + 1}`;
                row.appendChild(rowNumber);

                // Render nodes and edges
                flow.nodes.forEach((node, nodeIndex) => {
                    // Add node
                    const nodeElement = this.createNodeElement(node);
                    row.appendChild(nodeElement);

                    // Add edge after node (except for last node)
                    if (nodeIndex < flow.edges.length) {
                        const edge = flow.edges[nodeIndex];
                        const edgeElement = this.createEdgeElement(edge, flowIndex, nodeIndex);
                        row.appendChild(edgeElement);
                    }
                });

                return row;
            },

            createNodeElement(node) {
                const container = document.createElement('div');
                container.className = 'flow-node';

                const box = document.createElement('div');
                box.className = `node-box ${node.type}`;
                box.textContent = node.label;

                const typeLabel = document.createElement('div');
                typeLabel.className = 'node-type';
                typeLabel.textContent = node.type;

                container.appendChild(box);
                container.appendChild(typeLabel);

                return container;
            },

            createEdgeElement(edge, flowIndex, edgeIndex) {
                const container = document.createElement('div');
                container.className = 'flow-edge';

                // Protocol label
                const protocol = document.createElement('div');
                protocol.className = 'edge-protocol';
                protocol.textContent = `${edge.protocol} ${edge.direction}`;

                // Line container
                const lineContainer = document.createElement('div');
                lineContainer.className = 'edge-line-container';

                // Arrow at start if reverse
                if (edge.flowDirection === 'reverse') {
                    const arrowStart = document.createElement('div');
                    arrowStart.className = 'edge-arrow reverse';
                    lineContainer.appendChild(arrowStart);
                }

                // Line
                const line = document.createElement('div');
                line.className = 'edge-line';
                lineContainer.appendChild(line);

                // Arrow at end if forward
                if (edge.flowDirection === 'forward') {
                    const arrowEnd = document.createElement('div');
                    arrowEnd.className = 'edge-arrow';
                    lineContainer.appendChild(arrowEnd);
                }

                // Annotations container
                const annotations = document.createElement('div');
                annotations.className = 'edge-annotations';

                // Pre-processing annotation
                const preLabel = document.createElement('div');
                preLabel.className = 'annotation-label';
                preLabel.textContent = 'Pre-Processing';

                const preInput = document.createElement('input');
                preInput.type = 'text';
                preInput.className = 'annotation-input';
                preInput.placeholder = 'Add notes...';
                preInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre');
                preInput.addEventListener('input', debounce((e) => {
                    StateManager.updateAnnotation(flowIndex, edgeIndex, 'pre', e.target.value);
                    this.triggerSave();
                }, 300));

                // Post-processing annotation
                const postLabel = document.createElement('div');
                postLabel.className = 'annotation-label';
                postLabel.textContent = 'Post-Processing';

                const postInput = document.createElement('input');
                postInput.type = 'text';
                postInput.className = 'annotation-input';
                postInput.placeholder = 'Add notes...';
                postInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'post');
                postInput.addEventListener('input', debounce((e) => {
                    StateManager.updateAnnotation(flowIndex, edgeIndex, 'post', e.target.value);
                    this.triggerSave();
                }, 300));

                annotations.appendChild(preLabel);
                annotations.appendChild(preInput);
                annotations.appendChild(postLabel);
                annotations.appendChild(postInput);

                container.appendChild(protocol);
                container.appendChild(lineContainer);
                container.appendChild(annotations);

                return container;
            },

            triggerSave() {
                UIController.setSaveIndicator('saving');
                Persistence.save();
                setTimeout(() => UIController.setSaveIndicator('saved'), 500);
            }
        };

        // Make debounce available to DiagramRenderer
        DiagramRenderer.debounce = debounce;

        // ============================================
        // UI CONTROLLER
        // ============================================
        const UIController = {
            elements: {},

            init() {
                // Cache DOM elements
                this.elements = {
                    workspaceSelect: document.getElementById('workspaceSelect'),
                    patternEditor: document.getElementById('patternEditor'),
                    errorMessage: document.getElementById('errorMessage'),
                    saveIndicator: document.getElementById('saveIndicator'),
                    saveText: document.getElementById('saveText'),
                    canvasContainer: document.getElementById('canvasContainer'),
                    emptyState: document.getElementById('emptyState'),
                    modalOverlay: document.getElementById('modalOverlay'),
                    modalTitle: document.getElementById('modalTitle'),
                    modalInput: document.getElementById('modalInput'),
                    modalConfirmBtn: document.getElementById('modalConfirmBtn'),
                    helpPanel: document.getElementById('helpPanel')
                };

                this.bindEvents();
            },

            bindEvents() {
                // Workspace controls
                document.getElementById('newWorkspaceBtn').addEventListener('click', () => {
                    this.showModal('New Workspace', 'Untitled Workspace', 'Create', (name) => {
                        WorkspaceManager.createWorkspace(name);
                        this.updateWorkspaceSelect();
                        this.loadActiveWorkspace();
                    });
                });

                document.getElementById('renameWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        this.showModal('Rename Workspace', ws.name, 'Rename', (name) => {
                            WorkspaceManager.renameWorkspace(ws.id, name);
                            this.updateWorkspaceSelect();
                        });
                    }
                });

                document.getElementById('duplicateWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        WorkspaceManager.duplicateWorkspace(ws.id);
                        this.updateWorkspaceSelect();
                        this.loadActiveWorkspace();
                    }
                });

                document.getElementById('deleteWorkspaceBtn').addEventListener('click', () => {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws && confirm(`Delete workspace "${ws.name}"?`)) {
                        WorkspaceManager.deleteWorkspace(ws.id);
                        this.updateWorkspaceSelect();
                        this.loadActiveWorkspace();
                    }
                });

                this.elements.workspaceSelect.addEventListener('change', (e) => {
                    StateManager.setActiveWorkspace(e.target.value);
                    this.loadActiveWorkspace();
                });

                // Pattern editor
                const debouncedUpdate = debounce(() => {
                    this.updatePattern();
                    this.setSaveIndicator('saving');
                    Persistence.save();
                    setTimeout(() => this.setSaveIndicator('saved'), 500);
                }, 300);

                this.elements.patternEditor.addEventListener('input', debouncedUpdate);

                // Theme toggle
                document.getElementById('themeToggleBtn').addEventListener('click', () => {
                    const newTheme = StateManager.state.theme === 'light' ? 'dark' : 'light';
                    StateManager.setTheme(newTheme);
                    document.body.setAttribute('data-theme', newTheme);
                    this.updateThemeIcon();
                    Persistence.save();
                });

                // Help panel
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.elements.helpPanel.classList.add('visible');
                });

                document.getElementById('closeHelpBtn').addEventListener('click', () => {
                    this.elements.helpPanel.classList.remove('visible');
                });

                // Modal
                document.getElementById('modalCancelBtn').addEventListener('click', () => {
                    this.hideModal();
                });

                this.elements.modalInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.elements.modalConfirmBtn.click();
                    } else if (e.key === 'Escape') {
                        this.hideModal();
                    }
                });

                // Click outside modal to close
                this.elements.modalOverlay.addEventListener('click', (e) => {
                    if (e.target === this.elements.modalOverlay) {
                        this.hideModal();
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                        e.preventDefault();
                        document.getElementById('themeToggleBtn').click();
                    } else if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        document.getElementById('newWorkspaceBtn').click();
                    }
                });
            },

            updateWorkspaceSelect() {
                const select = this.elements.workspaceSelect;
                select.innerHTML = '';

                StateManager.state.workspaces.forEach((ws, id) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = ws.name;
                    option.selected = id === StateManager.state.activeWorkspaceId;
                    select.appendChild(option);
                });
            },

            loadActiveWorkspace() {
                const ws = StateManager.getActiveWorkspace();
                if (ws) {
                    this.elements.patternEditor.value = ws.patternText || '';
                    this.updatePattern();
                }
            },

            updatePattern() {
                const text = this.elements.patternEditor.value;
                StateManager.updatePattern(text);

                const result = Parser.parseMultiple(text);

                if (result.errors.length > 0) {
                    this.showErrors(result.errors);
                } else {
                    this.hideError();
                }

                DiagramRenderer.render(result.flows, this.elements.canvasContainer);
            },

            showErrors(errors) {
                const errorHtml = errors.map(e =>
                    `<div class="error-line">Line ${e.line}: ${e.message}</div>`
                ).join('');
                this.elements.errorMessage.innerHTML = errorHtml;
                this.elements.errorMessage.classList.add('visible');
            },

            hideError() {
                this.elements.errorMessage.classList.remove('visible');
            },

            setSaveIndicator(status) {
                const indicator = this.elements.saveIndicator;
                indicator.classList.remove('saving', 'saved');
                indicator.classList.add(status);
                this.elements.saveText.textContent = status === 'saving' ? 'Saving...' : 'Saved';
            },

            showModal(title, defaultValue, confirmText, onConfirm) {
                this.elements.modalTitle.textContent = title;
                this.elements.modalInput.value = defaultValue;
                this.elements.modalConfirmBtn.textContent = confirmText;
                this.elements.modalOverlay.classList.add('visible');
                this.elements.modalInput.focus();
                this.elements.modalInput.select();

                const confirmHandler = () => {
                    const value = this.elements.modalInput.value.trim();
                    if (value) {
                        onConfirm(value);
                        this.hideModal();
                    }
                };

                this.elements.modalConfirmBtn.onclick = confirmHandler;
            },

            hideModal() {
                this.elements.modalOverlay.classList.remove('visible');
            },

            updateThemeIcon() {
                const icon = document.getElementById('themeIcon');
                if (StateManager.state.theme === 'dark') {
                    icon.innerHTML = `
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    `;
                } else {
                    icon.innerHTML = `
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    `;
                }
            }
        };

        // ============================================
        // APPLICATION INITIALIZATION
        // ============================================
        function initApp() {
            // Initialize workspace manager (loads from storage or creates default)
            WorkspaceManager.initialize();

            // Apply saved theme
            document.body.setAttribute('data-theme', StateManager.state.theme);

            // Initialize UI
            UIController.init();
            UIController.updateWorkspaceSelect();
            UIController.loadActiveWorkspace();
            UIController.updateThemeIcon();
        }

        // Start the application when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>

</html>