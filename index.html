<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MFT Flow Visualizer</title>
    <style>
        /* ============================================
           CSS VARIABLES & THEMES
           ============================================ */
        :root {
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            --transition-speed: 0.2s;
            --border-radius: 8px;
            --border-radius-lg: 12px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Light Theme */
        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --node-source: #dbeafe;
            --node-source-border: #3b82f6;
            --node-intermediate: #f1f5f9;
            --node-intermediate-border: #64748b;
            --node-target: #dcfce7;
            --node-target-border: #10b981;
            --edge-color: #64748b;
            --canvas-bg: #fafafa;
            --gradient-start: #f0f4ff;
            --gradient-end: #faf5ff;
            --annotation-bg: #fffbeb;
            --annotation-border: #fcd34d;
        }

        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --accent-primary: #60a5fa;
            --accent-secondary: #34d399;
            --accent-warning: #fbbf24;
            --accent-danger: #f87171;
            --node-source: #1e3a5f;
            --node-source-border: #60a5fa;
            --node-intermediate: #334155;
            --node-intermediate-border: #94a3b8;
            --node-target: #14532d;
            --node-target-border: #34d399;
            --edge-color: #94a3b8;
            --canvas-bg: #0f172a;
            --gradient-start: #1e1b4b;
            --gradient-end: #1e293b;
            --annotation-bg: #422006;
            --annotation-border: #b45309;
        }

        /* ============================================
           BASE STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: var(--text-primary);
            transition: background var(--transition-speed), color var(--transition-speed);
        }

        /* Grainy texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* ============================================
           LAYOUT
           ============================================ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* ============================================
           HEADER
           ============================================ */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        /* Grayscale Interlacing Waves - Soft Surreal Art */
        .header-gradient {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            mask-image: linear-gradient(to left, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 80%, rgba(0, 0, 0, 0.4) 95%, transparent 100%);
            -webkit-mask-image: linear-gradient(to left, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 80%, rgba(0, 0, 0, 0.4) 95%, transparent 100%);
        }

        /* Soft grayscale gradient background */
        .header-gradient-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(165deg, #e8e8e8 0%, #d4d4d4 30%, #a8a8a8 70%, #888888 100%);
        }

        /* SVG Sine Waves Container */
        .header-sine-waves {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .header-sine-waves svg {
            position: absolute;
            width: 250%;
            height: 100%;
            left: -75%;
        }

        /* Wave 1 - Light gray, soft */
        .sine-wave-1 {
            animation: sineMove1 20s ease-in-out infinite;
        }

        .sine-wave-1 path {
            fill: none;
            stroke: url(#waveGradient1);
            stroke-width: 6;
            filter: blur(2px);
            opacity: 0.8;
        }

        /* Wave 2 - Mid gray */
        .sine-wave-2 {
            animation: sineMove2 25s ease-in-out infinite;
        }

        .sine-wave-2 path {
            fill: none;
            stroke: url(#waveGradient2);
            stroke-width: 5;
            filter: blur(1.5px);
            opacity: 0.7;
        }

        /* Wave 3 - Darker gray */
        .sine-wave-3 {
            animation: sineMove3 30s ease-in-out infinite;
        }

        .sine-wave-3 path {
            fill: none;
            stroke: url(#waveGradient3);
            stroke-width: 4;
            filter: blur(1px);
            opacity: 0.6;
        }

        /* Wave 4 - Soft white highlight */
        .sine-wave-4 {
            animation: sineMove4 18s ease-in-out infinite;
        }

        .sine-wave-4 path {
            fill: none;
            stroke: url(#waveGradient4);
            stroke-width: 3;
            filter: blur(3px);
            opacity: 0.5;
        }

        /* Soft ambient glow - grayscale only */
        .header-gradient-wave1 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse 90% 60% at 60% 20%, rgba(255, 255, 255, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse 70% 50% at 30% 80%, rgba(120, 120, 120, 0.3) 0%, transparent 45%);
            animation: softGlow1 15s ease-in-out infinite;
        }

        .header-gradient-wave2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse 80% 55% at 75% 60%, rgba(200, 200, 200, 0.35) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 40%, rgba(180, 180, 180, 0.25) 0%, transparent 45%);
            animation: softGlow2 18s ease-in-out infinite;
        }

        /* Heavy film grain - primary layer */
        .header-gradient-grain {
            position: absolute;
            top: -40%;
            left: -40%;
            width: 180%;
            height: 180%;
            opacity: 0.55;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            mix-blend-mode: multiply;
            animation: grainDrift 0.8s steps(4) infinite;
        }

        /* Secondary fine grain layer */
        .header-gradient-grain2 {
            position: absolute;
            top: -20%;
            left: -20%;
            width: 140%;
            height: 140%;
            opacity: 0.4;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grain2'%3E%3CfeTurbulence type='turbulence' baseFrequency='1.0' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grain2)'/%3E%3C/svg%3E");
            mix-blend-mode: soft-light;
            animation: grainDrift2 1.2s steps(3) infinite reverse;
        }

        /* Remove unused elements */
        .header-gradient-wave3,
        .header-gradient-noise,
        .header-gradient-inner {
            display: none;
        }

        /* Slow, relaxing wave animations */
        @keyframes sineMove1 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(20%) translateY(2px);
            }
        }

        @keyframes sineMove2 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(-15%) translateY(-1px);
            }
        }

        @keyframes sineMove3 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(12%) translateY(3px);
            }
        }

        @keyframes sineMove4 {

            0%,
            100% {
                transform: translateX(0) translateY(0);
            }

            50% {
                transform: translateX(-25%) translateY(-2px);
            }
        }

        @keyframes softGlow1 {

            0%,
            100% {
                opacity: 0.4;
                transform: scale(1) translateX(0);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.03) translateX(3%);
            }
        }

        @keyframes softGlow2 {

            0%,
            100% {
                opacity: 0.35;
                transform: scale(1.02) translateX(0);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.98) translateX(-2%);
            }
        }

        /* Slower grain animation for relaxing feel */
        @keyframes grainDrift {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, 0);
            }

            75% {
                transform: translate(0, -1px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        @keyframes grainDrift2 {
            0% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(1px, 0) scale(1.01);
            }

            66% {
                transform: translate(-1px, 1px) scale(0.99);
            }

            100% {
                transform: translate(0, 0) scale(1);
            }
        }

        /* Light theme - soft ethereal feel */
        [data-theme="light"] .header-gradient-bg {
            background: linear-gradient(165deg, #f5f5f5 0%, #e0e0e0 30%, #c0c0c0 70%, #a0a0a0 100%);
        }

        [data-theme="light"] .header-gradient-wave1 {
            background:
                radial-gradient(ellipse 90% 60% at 60% 20%, rgba(255, 255, 255, 0.5) 0%, transparent 50%),
                radial-gradient(ellipse 70% 50% at 30% 80%, rgba(140, 140, 140, 0.25) 0%, transparent 45%);
        }

        [data-theme="light"] .header-gradient-wave2 {
            background:
                radial-gradient(ellipse 80% 55% at 75% 60%, rgba(220, 220, 220, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 40%, rgba(200, 200, 200, 0.2) 0%, transparent 45%);
        }

        [data-theme="light"] .header-gradient-grain {
            opacity: 0.45;
            mix-blend-mode: multiply;
        }

        [data-theme="light"] .header-gradient-grain2 {
            opacity: 0.35;
        }

        /* Dark theme - moody grayscale */
        [data-theme="dark"] .header-gradient-bg {
            background: linear-gradient(165deg, #4a4a4a 0%, #3a3a3a 30%, #2a2a2a 70%, #1a1a1a 100%);
        }

        [data-theme="dark"] .header-gradient-wave1 {
            background:
                radial-gradient(ellipse 90% 60% at 60% 20%, rgba(200, 200, 200, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse 70% 50% at 30% 80%, rgba(100, 100, 100, 0.25) 0%, transparent 45%);
        }

        [data-theme="dark"] .header-gradient-wave2 {
            background:
                radial-gradient(ellipse 80% 55% at 75% 60%, rgba(150, 150, 150, 0.25) 0%, transparent 50%),
                radial-gradient(ellipse 60% 40% at 20% 40%, rgba(120, 120, 120, 0.2) 0%, transparent 45%);
        }

        [data-theme="dark"] .header-gradient-grain {
            opacity: 0.6;
            mix-blend-mode: overlay;
        }

        [data-theme="dark"] .header-gradient-grain2 {
            opacity: 0.45;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            position: relative;
            z-index: 2;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .workspace-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-divider {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 4px;
        }

        .workspace-select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            min-width: 180px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .workspace-select:hover {
            border-color: var(--accent-primary);
        }

        .workspace-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            z-index: 2;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        .btn-primary {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
        }

        .btn-danger {
            color: var(--accent-danger);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--accent-danger);
        }

        /* ============================================
           EDITOR SECTION
           ============================================ */
        .editor-section {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        /* Flow Analysis Panel - Left Side */
        .flow-analysis-panel {
            width: 350px;
            padding: 12px 16px;
            border-right: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
            overflow-y: auto;
            max-height: 200px;
        }

        .analysis-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .analysis-header svg {
            color: var(--accent-primary);
        }

        .analysis-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 10px;
            text-align: center;
            transition: all var(--transition-speed);
        }

        .stat-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent-primary);
            line-height: 1.2;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 2px;
        }

        .protocol-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .protocol-tag {
            font-size: 11px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .protocol-tag:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .protocol-tag .tag-count {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            padding: 1px 5px;
            border-radius: 8px;
            font-size: 10px;
            margin-left: 4px;
        }

        .protocol-tag:hover .tag-count {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .flow-nav-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 12px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            cursor: pointer;
            transition: all var(--transition-speed);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2364748b' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 32px;
        }

        .flow-nav-select:hover {
            border-color: var(--accent-primary);
        }

        .flow-nav-select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .flow-nav-select option {
            padding: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        [data-theme="dark"] .flow-nav-select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        }

        /* Pattern Editor - Right Side */
        .pattern-editor-section {
            flex: 1;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
        }

        .editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .editor-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .save-indicator {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .save-indicator.saving {
            color: var(--accent-warning);
        }

        .save-indicator.saved {
            color: var(--accent-secondary);
        }

        .pattern-editor-wrapper {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            overflow: hidden;
            transition: all var(--transition-speed);
            height: 150px;
            max-height: 200px;
            resize: vertical;
        }

        .pattern-editor-wrapper:focus-within {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .line-numbers {
            padding: 14px 8px 14px 12px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 22.4px;
            color: var(--text-muted);
            text-align: right;
            user-select: none;
            min-width: 44px;
            overflow-y: hidden;
            overflow-x: hidden;
            flex-shrink: 0;
        }

        .line-numbers span {
            display: block;
            height: 22.4px;
        }

        .pattern-editor {
            flex: 1;
            height: 100%;
            padding: 14px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 14px;
            line-height: 22.4px;
            resize: none;
            overflow-y: auto;
        }

        .pattern-editor:focus {
            outline: none;
        }

        .pattern-editor::placeholder {
            color: var(--text-muted);
        }

        .error-message {
            margin-top: 8px;
            padding: 10px 14px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-danger);
            border-radius: var(--border-radius);
            color: var(--accent-danger);
            font-size: 13px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        .error-line {
            margin-bottom: 4px;
        }

        .error-line:last-child {
            margin-bottom: 0;
        }

        /* ============================================
           CANVAS SECTION
           ============================================ */
        .canvas-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .canvas-section {
            flex: 1;
            position: relative;
            overflow: auto;
            background: var(--canvas-bg);
        }

        .canvas-container {
            min-width: 100%;
            min-height: 100%;
            padding: 20px;
            display: inline-block;
        }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .empty-state-description {
            font-size: 14px;
            max-width: 300px;
        }

        /* ============================================
           FLOW ROW STYLES
           ============================================ */
        .flow-row {
            display: inline-flex;
            align-items: center;
            margin-bottom: 40px;
            padding: 20px;
            padding-right: 30px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            position: relative;
            cursor: pointer;
            transition: all var(--transition-speed);
            min-width: calc(100% - 40px);
            white-space: nowrap;
        }

        .flow-row:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-md);
        }

        .flow-row.selected {
            border-color: var(--accent-primary);
            border-width: 2px;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .flow-row:last-child {
            margin-bottom: 0;
        }

        .flow-row-number {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--accent-primary);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .flow-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
            flex-shrink: 0;
        }

        .node-box {
            padding: 12px 20px;
            border-radius: var(--border-radius);
            border: 2px solid;
            font-weight: 500;
            font-size: 14px;
            text-align: center;
            min-width: 100px;
            transition: all var(--transition-speed);
        }

        .node-box.source {
            background: var(--node-source);
            border-color: var(--node-source-border);
            color: var(--node-source-border);
        }

        .node-box.intermediate {
            background: var(--node-intermediate);
            border-color: var(--node-intermediate-border);
            color: var(--text-primary);
        }

        .node-box.target {
            background: var(--node-target);
            border-color: var(--node-target-border);
            color: var(--node-target-border);
        }

        .node-type {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 6px;
            color: var(--text-muted);
        }

        /* ============================================
           EDGE / CONNECTION STYLES
           ============================================ */
        .flow-edge {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 10px;
            min-width: 160px;
            position: relative;
        }

        .edge-line-container {
            display: flex;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .edge-line {
            flex: 1;
            height: 2px;
            position: relative;
            background-image: repeating-linear-gradient(90deg,
                    var(--edge-color) 0,
                    var(--edge-color) 6px,
                    transparent 6px,
                    transparent 10px);
            background-size: 10px 2px;
            animation: flowDash 0.4s linear infinite;
        }

        @keyframes flowDash {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 10px 0;
            }
        }

        .edge-arrow {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid var(--edge-color);
            flex-shrink: 0;
        }

        .edge-arrow.reverse {
            border-left: none;
            border-right: 10px solid var(--edge-color);
        }

        .edge-protocol {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .edge-protocol.invalid {
            font-style: italic;
            border-color: var(--accent-warning, #ff9800);
            background: var(--bg-warning, rgba(255, 152, 0, 0.1));
        }

        .edge-protocol.invalid::before {
            content: 'âš  ';
            margin-right: 2px;
        }

        .edge-protocol-select {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-warning, #ff9800);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            cursor: pointer;
            min-width: 150px;
            font-style: italic;
        }

        .edge-protocol-select:focus {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        /* ============================================
           ANNOTATION INPUT STYLES
           ============================================ */
        .edge-annotations {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            width: 100%;
        }

        .annotation-input {
            width: 100%;
            padding: 6px 8px;
            font-size: 11px;
            border: 1px dashed var(--annotation-border);
            border-radius: 4px;
            background: var(--annotation-bg);
            color: var(--text-primary);
            text-align: center;
            transition: all var(--transition-speed);
        }

        .annotation-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .annotation-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-warning);
            box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
        }

        .annotation-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        /* ============================================
           SOURCE/TARGET DESCRIPTION FIELDS
           ============================================ */
        .flow-description-field {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            min-width: 120px;
            max-width: 180px;
        }

        .flow-description-label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .flow-description-input {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            font-size: 11px;
            border: 1px dashed var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            text-align: center;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .flow-description-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .flow-description-input:focus {
            outline: none;
            border-style: solid;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .flow-description-field.before-source .flow-description-input {
            border-color: var(--node-source);
        }

        .flow-description-field.after-target .flow-description-input {
            border-color: var(--node-target);
        }

        .flow-description-field.before-source .flow-description-input:focus {
            border-color: var(--node-source);
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
        }

        .flow-description-field.after-target .flow-description-input:focus {
            border-color: var(--node-target);
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }

        /* ============================================
           MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            padding: 24px;
            min-width: 360px;
            max-width: 90%;
            box-shadow: var(--shadow-lg);
            transform: scale(0.95);
            transition: transform var(--transition-speed);
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* ============================================
           ARCHITECTURE MODAL
           ============================================ */
        .architecture-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed);
        }

        .architecture-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .architecture-modal-content {
            background: var(--bg-secondary);
            border-radius: var(--border-radius-lg);
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
            transform: scale(0.95);
            transition: transform var(--transition-speed);
            overflow: hidden;
        }

        .architecture-modal.visible .architecture-modal-content {
            transform: scale(1);
        }

        .architecture-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .architecture-modal-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .architecture-modal-title svg {
            color: var(--accent-primary);
        }

        .architecture-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 8px;
            border-radius: var(--border-radius);
            transition: all var(--transition-speed);
        }

        .architecture-modal-close:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .architecture-modal-body {
            flex: 1;
            overflow: hidden;
            position: relative;
            background: var(--canvas-bg);
        }

        .architecture-canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }

        .architecture-canvas-container:active {
            cursor: grabbing;
        }

        .architecture-canvas {
            position: absolute;
            min-width: 100%;
            min-height: 100%;
            padding: 40px;
        }

        .architecture-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px 16px;
            font-size: 12px;
            display: flex;
            gap: 20px;
            box-shadow: var(--shadow-md);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
        }

        .legend-dot.source {
            background: var(--node-source);
            border-color: var(--node-source-border);
        }

        .legend-dot.intermediate {
            background: var(--node-intermediate);
            border-color: var(--node-intermediate-border);
        }

        .legend-dot.target {
            background: var(--node-target);
            border-color: var(--node-target-border);
        }

        .architecture-stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px 16px;
            font-size: 12px;
            box-shadow: var(--shadow-md);
        }

        .arch-stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 4px;
        }

        .arch-stat-row:last-child {
            margin-bottom: 0;
        }

        .arch-stat-label {
            color: var(--text-secondary);
        }

        .arch-stat-value {
            font-weight: 600;
            color: var(--accent-primary);
        }

        /* Architecture diagram nodes */
        .arch-node {
            position: absolute;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            box-shadow: var(--shadow-sm);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            cursor: default;
            white-space: nowrap;
        }

        .arch-node:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .arch-node.source {
            background: var(--node-source);
            border: 2px solid var(--node-source-border);
            color: var(--node-source-border);
        }

        .arch-node.intermediate {
            background: var(--node-intermediate);
            border: 2px solid var(--node-intermediate-border);
            color: var(--text-primary);
        }

        .arch-node.target {
            background: var(--node-target);
            border: 2px solid var(--node-target-border);
            color: var(--node-target-border);
        }

        /* Architecture diagram edges */
        .arch-edge-label {
            position: absolute;
            font-size: 10px;
            padding: 3px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
            pointer-events: none;
        }

        /* ============================================
           KROKI MODAL STYLES
           ============================================ */
        .kroki-modal-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .kroki-modal-actions .btn-sm {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-size: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .kroki-modal-actions .btn-sm:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .kroki-modal-actions .btn-icon-only {
            padding: 6px 8px;
        }

        .kroki-zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            padding: 2px;
        }

        .kroki-zoom-level {
            min-width: 50px;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            padding: 0 4px;
        }

        .kroki-actions-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 4px;
        }

        .kroki-modal-body {
            display: flex;
            flex-direction: column;
        }

        .kroki-canvas-container {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--canvas-bg);
            overflow: auto;
        }

        .kroki-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: var(--text-secondary);
        }

        .kroki-loading.hidden {
            display: none;
        }

        .kroki-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .kroki-image {
            display: none;
            cursor: grab;
        }

        .kroki-image.visible {
            display: block;
        }

        .kroki-image.dragging {
            cursor: grabbing;
        }

        .kroki-canvas-container {
            overflow: auto;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .kroki-image-wrapper {
            display: block;
            /* Extra padding to allow scrolling beyond image edges on all sides */
            padding: 200px;
        }

        .kroki-legend {
            flex-direction: column;
            gap: 8px;
        }

        .kroki-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: var(--error-color, #e74c3c);
            padding: 20px;
            text-align: center;
        }

        .kroki-error.hidden {
            display: none;
        }

        /* ============================================
           LOADING OVERLAY
           ============================================ */
        .loading-overlay {
            position: fixed;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: #ffffff;
            font-size: 16px;
            margin-top: 20px;
            font-weight: 500;
        }

        .loading-subtext {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            margin-top: 8px;
        }

        /* ============================================
           HELP PANEL
           ============================================ */
        .help-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: right var(--transition-speed);
            overflow-y: auto;
        }

        .help-panel.visible {
            right: 0;
        }

        .help-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .help-panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .help-panel-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .help-section p {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .help-example {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            color: var(--text-primary);
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* ============================================
           PATTERN INFO PANEL
           ============================================ */
        .pattern-info-panel {
            width: 350px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            overflow: hidden;
        }

        .pattern-info-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .pattern-info-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flow-selector {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .flow-selector:hover {
            border-color: var(--accent-primary);
        }

        .flow-selector:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .pattern-info-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .info-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .info-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .general-notes-field {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: var(--font-family);
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: all var(--transition-speed);
        }

        .general-notes-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .general-notes-field::placeholder {
            color: var(--text-muted);
        }

        .required-products-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .product-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            transition: all var(--transition-speed);
        }

        .product-item:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-sm);
        }

        .product-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .product-capabilities {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .capability-badge {
            padding: 4px 8px;
            background: var(--accent-primary);
            color: white;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .no-products-message {
            padding: 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 13px;
            font-style: italic;
        }

        /* ============================================
           RESPONSIVE
           ============================================ */
        @media (max-width: 1024px) {
            .flow-analysis-panel {
                width: 280px;
            }

            .analysis-stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                gap: 12px;
            }

            .header-left {
                width: 100%;
                justify-content: space-between;
            }

            .workspace-controls {
                width: 100%;
            }

            .workspace-select {
                flex: 1;
            }

            .help-panel {
                width: 100%;
                right: -100%;
            }

            .flow-row {
                overflow-x: auto;
            }

            .editor-section {
                flex-direction: column;
            }

            .flow-analysis-panel {
                width: 100%;
                max-height: 150px;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .analysis-stats {
                grid-template-columns: repeat(3, 1fr);
            }

            .canvas-wrapper {
                flex-direction: column;
            }

            .pattern-info-panel {
                width: 100%;
                max-height: 300px;
            }
        }
    </style>
</head>

<body data-theme="light">
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <!-- Animated Sine Wave with Subtle Colors -->
            <div class="header-gradient">
                <div class="header-gradient-bg"></div>
                <div class="header-gradient-wave1"></div>
                <div class="header-gradient-wave2"></div>

                <!-- SVG Sine Waves - Grayscale -->
                <div class="header-sine-waves">
                    <svg viewBox="0 0 1200 60" preserveAspectRatio="none">
                        <defs>
                            <!-- Light gray gradient -->
                            <linearGradient id="waveGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.9" />
                                <stop offset="50%" style="stop-color:#e0e0e0;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#f5f5f5;stop-opacity:0.7" />
                            </linearGradient>
                            <!-- Mid gray gradient -->
                            <linearGradient id="waveGradient2" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#b0b0b0;stop-opacity:0.8" />
                                <stop offset="50%" style="stop-color:#909090;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#c0c0c0;stop-opacity:0.6" />
                            </linearGradient>
                            <!-- Dark gray gradient -->
                            <linearGradient id="waveGradient3" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#707070;stop-opacity:0.7" />
                                <stop offset="50%" style="stop-color:#505050;stop-opacity:0.9" />
                                <stop offset="100%" style="stop-color:#606060;stop-opacity:0.5" />
                            </linearGradient>
                            <!-- Soft white highlight -->
                            <linearGradient id="waveGradient4" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.6" />
                                <stop offset="50%" style="stop-color:#f8f8f8;stop-opacity:0.8" />
                                <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0.4" />
                            </linearGradient>
                        </defs>

                        <!-- Wave 1 - Light, wide amplitude, slow -->
                        <g class="sine-wave-1">
                            <path
                                d="M0,30 C75,15 150,15 225,30 C300,45 375,45 450,30 C525,15 600,15 675,30 C750,45 825,45 900,30 C975,15 1050,15 1125,30 C1200,45 1275,45 1350,30 C1425,15 1500,15 1575,30" />
                        </g>

                        <!-- Wave 2 - Mid gray, different frequency -->
                        <g class="sine-wave-2">
                            <path
                                d="M0,35 C60,22 120,22 180,35 C240,48 300,48 360,35 C420,22 480,22 540,35 C600,48 660,48 720,35 C780,22 840,22 900,35 C960,48 1020,48 1080,35 C1140,22 1200,22 1260,35 C1320,48 1380,48 1440,35" />
                        </g>

                        <!-- Wave 3 - Dark, tighter frequency -->
                        <g class="sine-wave-3">
                            <path
                                d="M0,28 C45,38 90,38 135,28 C180,18 225,18 270,28 C315,38 360,38 405,28 C450,18 495,18 540,28 C585,38 630,38 675,28 C720,18 765,18 810,28 C855,38 900,38 945,28 C990,18 1035,18 1080,28 C1125,38 1170,38 1215,28" />
                        </g>

                        <!-- Wave 4 - White highlight, very soft -->
                        <g class="sine-wave-4">
                            <path
                                d="M0,32 C90,20 180,20 270,32 C360,44 450,44 540,32 C630,20 720,20 810,32 C900,44 990,44 1080,32 C1170,20 1260,20 1350,32 C1440,44 1530,44 1620,32" />
                        </g>
                    </svg>
                </div>

                <div class="header-gradient-grain"></div>
                <div class="header-gradient-grain2"></div>
            </div>

            <div class="header-left">
                <div class="logo">
                    <div class="logo-icon">â‡Œ</div>
                    <span>MFT Flow Visualizer</span>
                </div>
                <div class="workspace-controls">
                    <select id="workspaceSelect" class="workspace-select">
                        <option value="">Loading...</option>
                    </select>
                    <button id="newWorkspaceBtn" class="btn btn-primary btn-icon" title="New Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                    </button>
                    <button id="renameWorkspaceBtn" class="btn btn-icon" title="Rename Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                        </svg>
                    </button>
                    <button id="duplicateWorkspaceBtn" class="btn btn-icon" title="Duplicate Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                    </button>
                    <button id="deleteWorkspaceBtn" class="btn btn-icon btn-danger" title="Delete Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2">
                            </path>
                        </svg>
                    </button>
                    <span class="workspace-divider"></span>
                    <button id="exportWorkspaceBtn" class="btn btn-icon" title="Export Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                    </button>
                    <button id="importWorkspaceBtn" class="btn btn-icon" title="Import Workspace">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                    </button>
                    <button id="exportPdfBtn" class="btn btn-icon" title="Export PDF Report">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;">
                </div>
            </div>
            <div class="header-right">
                <button id="architectureBtn" class="btn btn-icon" title="View Full Architecture">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7" rx="1"></rect>
                        <rect x="14" y="3" width="7" height="7" rx="1"></rect>
                        <rect x="14" y="14" width="7" height="7" rx="1"></rect>
                        <rect x="3" y="14" width="7" height="7" rx="1"></rect>
                        <path d="M10 6.5h4"></path>
                        <path d="M17.5 10v4"></path>
                        <path d="M10 17.5h4"></path>
                        <path d="M6.5 10v4"></path>
                    </svg>
                </button>
                <button id="krokiBtn" class="btn btn-icon" title="Generate Kroki Diagram (D2)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                        <path d="M2 17l10 5 10-5"></path>
                        <path d="M2 12l10 5 10-5"></path>
                    </svg>
                </button>
                <button id="themeToggleBtn" class="btn btn-icon" title="Toggle Theme">
                    <svg id="themeIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <button id="helpBtn" class="btn btn-icon" title="Help">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Editor Section -->
        <section class="editor-section">
            <!-- Flow Analysis Panel - Left Side -->
            <div class="flow-analysis-panel">
                <div class="analysis-header">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path
                            d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
                        </path>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                        <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                    Flow Analysis
                </div>
                <div class="analysis-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="statFlowCount">0</div>
                        <div class="stat-label">Flows</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statNodeCount">0</div>
                        <div class="stat-label">Nodes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="statProtocolCount">0</div>
                        <div class="stat-label">Protocols</div>
                    </div>
                </div>
                <div class="protocol-tags" id="protocolTags">
                    <!-- Protocol tags will be populated dynamically -->
                </div>
                <select class="flow-nav-select" id="flowNavSelect">
                    <option value="">-- Select a flow --</option>
                </select>
            </div>

            <!-- Pattern Editor - Right Side -->
            <div class="pattern-editor-section">
                <div class="editor-header">
                    <span class="editor-title">Flow Patterns (one per line)</span>
                    <span id="saveIndicator" class="save-indicator saved">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                        <span id="saveText">Saved</span>
                    </span>
                </div>
                <div class="pattern-editor-wrapper">
                    <div id="lineNumbers" class="line-numbers"><span>1</span></div>
                    <textarea id="patternEditor" class="pattern-editor" placeholder="Enter your MFT flow patterns here (one per line)...

Examples:
TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF" spellcheck="false"></textarea>
                </div>
                <div id="errorMessage" class="error-message"></div>
            </div>
        </section>

        <!-- Canvas Section -->
        <div class="canvas-wrapper">
            <section class="canvas-section">
                <div id="canvasContainer" class="canvas-container">
                    <!-- Flow rows will be rendered here -->
                </div>

                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">â‡Œ</div>
                    <div class="empty-state-title">No Flows Defined</div>
                    <div class="empty-state-description">
                        Enter flow patterns in the editor above to visualize your MFT flows.
                    </div>
                </div>
            </section>

            <!-- Pattern Info Panel -->
            <div id="patternInfoPanel" class="pattern-info-panel">
                <div class="pattern-info-header">
                    <span class="pattern-info-title">Flow Information</span>
                </div>
                <div class="pattern-info-content">
                    <div class="info-section">
                        <label class="info-label">Select Flow</label>
                        <select id="flowSelector" class="flow-selector">
                            <option value="">-- Select a flow --</option>
                        </select>
                    </div>
                    <div class="info-section">
                        <label class="info-label">General Notes</label>
                        <textarea id="generalNotesField" class="general-notes-field"
                            placeholder="Add general notes about this flow..."></textarea>
                    </div>
                    <div class="info-section">
                        <label class="info-label">Potential Products</label>
                        <div id="requiredProductsList" class="required-products-list">
                            <div class="no-products-message">Select a flow to see potential products</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Help Panel -->
        <div id="helpPanel" class="help-panel">
            <div class="help-panel-header">
                <span class="help-panel-title">Help & Syntax Guide</span>
                <button id="closeHelpBtn" class="btn btn-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="help-panel-content">
                <div class="help-section">
                    <h3 class="help-section-title">Pattern Syntax</h3>
                    <p>Define MFT flows using a simple text-based syntax. Enter one pattern per line.</p>
                    <div class="help-example">SOURCE -> PROTOCOL DIRECTION -> MIDDLE -> PROTOCOL DIRECTION -> TARGET
                    </div>
                </div>
                <div class="help-section">
                    <h3 class="help-section-title">Examples</h3>
                    <div class="help-example">TESTA -> PeSIT PUSH -> ST -> SFTP PUSH -> TESTB
                        TESTA -> PeSIT PUSH -> CFT -> SSH PUSH -> TESTC
                        TESTZ <- PeSIT PULL <- CFT -> SSH PUSH -> TESTF
                            TESTZ -> PeSIT PUSH -> ST -> JMS PUSH -> SFC -> EBICS PUSH -> BANK1</div>
                </div>
                <div class="help-section">
                    <h3 class="help-section-title">Components</h3>
                    <p><strong>Entities:</strong> Names like TESTA, ST, CFT (alphanumeric + underscores)</p>
                    <p><strong>Protocols:</strong> SFTP, PeSIT, HTTPS, FTP, AS2, SSH, JMS, EBICS, etc.</p>
                    <p><strong>Directions:</strong> PULL (fetch data) or PUSH (send data)</p>
                    <p><strong>Arrows:</strong> <- (left) and -> (right) indicate flow direction</p>
                </div>
                <div class="help-section">
                    <h3 class="help-section-title">Annotations</h3>
                    <p>Each connection has editable annotation fields for pre-processing and post-processing notes.
                        Click on
                        the yellow dashed boxes to add annotations.</p>
                </div>
            </div>
        </div>

        <!-- Loading Overlay for PDF Generation -->
        <div id="loadingOverlay" class="loading-overlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Generating PDF Report</div>
            <div class="loading-subtext">Please wait...</div>
        </div>

        <!-- Modal for Rename/New Workspace -->
        <div id="modalOverlay" class="modal-overlay">
            <div class="modal">
                <h2 id="modalTitle" class="modal-title">New Workspace</h2>
                <input type="text" id="modalInput" class="modal-input" placeholder="Workspace name">
                <div class="modal-actions">
                    <button id="modalCancelBtn" class="btn">Cancel</button>
                    <button id="modalConfirmBtn" class="btn btn-primary">Create</button>
                </div>
            </div>
        </div>

        <!-- Architecture Diagram Modal -->
        <div id="architectureModal" class="architecture-modal">
            <div class="architecture-modal-content">
                <div class="architecture-modal-header">
                    <div class="architecture-modal-title">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <rect x="3" y="3" width="7" height="7" rx="1"></rect>
                            <rect x="14" y="3" width="7" height="7" rx="1"></rect>
                            <rect x="14" y="14" width="7" height="7" rx="1"></rect>
                            <rect x="3" y="14" width="7" height="7" rx="1"></rect>
                            <path d="M10 6.5h4"></path>
                            <path d="M17.5 10v4"></path>
                            <path d="M10 17.5h4"></path>
                            <path d="M6.5 10v4"></path>
                        </svg>
                        Full Architecture Diagram
                    </div>
                    <button id="closeArchitectureBtn" class="architecture-modal-close" title="Close">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="architecture-modal-body">
                    <div id="architectureCanvasContainer" class="architecture-canvas-container">
                        <svg id="architectureCanvas" class="architecture-canvas"></svg>
                    </div>
                    <div class="architecture-legend">
                        <div class="legend-item">
                            <div class="legend-dot source"></div>
                            <span>Source</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot intermediate"></div>
                            <span>Intermediate</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot target"></div>
                            <span>Target</span>
                        </div>
                    </div>
                    <div id="architectureStats" class="architecture-stats">
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Unique Nodes:</span>
                            <span class="arch-stat-value" id="archStatNodes">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Connections:</span>
                            <span class="arch-stat-value" id="archStatConnections">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Protocols:</span>
                            <span class="arch-stat-value" id="archStatProtocols">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Kroki Diagram Modal -->
        <div id="krokiModal" class="architecture-modal">
            <div class="architecture-modal-content">
                <div class="architecture-modal-header">
                    <div class="architecture-modal-title">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2">
                            <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                            <path d="M2 17l10 5 10-5"></path>
                            <path d="M2 12l10 5 10-5"></path>
                        </svg>
                        Kroki Diagram (D2)
                    </div>
                    <div class="kroki-modal-actions">
                        <div class="kroki-zoom-controls">
                            <button id="krokiZoomOutBtn" class="btn btn-sm btn-icon-only" title="Zoom Out (-)">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                    <line x1="8" y1="11" x2="14" y2="11"></line>
                                </svg>
                            </button>
                            <span id="krokiZoomLevel" class="kroki-zoom-level">100%</span>
                            <button id="krokiZoomInBtn" class="btn btn-sm btn-icon-only" title="Zoom In (+)">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                    <line x1="11" y1="8" x2="11" y2="14"></line>
                                    <line x1="8" y1="11" x2="14" y2="11"></line>
                                </svg>
                            </button>
                            <button id="krokiZoomResetBtn" class="btn btn-sm" title="Reset Zoom">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                                    <path d="M3 3v5h5"></path>
                                </svg>
                                Fit
                            </button>
                        </div>
                        <div class="kroki-actions-divider"></div>
                        <button id="krokiCopyCodeBtn" class="btn btn-sm" title="Copy D2 Code">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            Copy Code
                        </button>
                        <button id="krokiOpenExternalBtn" class="btn btn-sm" title="Open in Kroki">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                                <polyline points="15 3 21 3 21 9"></polyline>
                                <line x1="10" y1="14" x2="21" y2="3"></line>
                            </svg>
                            Open External
                        </button>
                        <button id="closeKrokiBtn" class="architecture-modal-close" title="Close">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="architecture-modal-body kroki-modal-body">
                    <div id="krokiCanvasContainer" class="architecture-canvas-container kroki-canvas-container">
                        <div id="krokiLoading" class="kroki-loading">
                            <div class="kroki-spinner"></div>
                            <span>Generating diagram...</span>
                        </div>
                        <div id="krokiImageWrapper" class="kroki-image-wrapper">
                            <img id="krokiImage" class="kroki-image" alt="Kroki D2 Diagram" />
                        </div>
                    </div>
                    <div class="architecture-legend kroki-legend">
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Nodes:</span>
                            <span class="arch-stat-value" id="krokiStatNodes">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Connections:</span>
                            <span class="arch-stat-value" id="krokiStatConnections">0</span>
                        </div>
                        <div class="arch-stat-row">
                            <span class="arch-stat-label">Format:</span>
                            <span class="arch-stat-value">D2</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script src="products_capabilities.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
        <script>
            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            function generateId() {
                return 'ws_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
            }

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // ============================================
            // STATE MANAGER
            // ============================================
            const StateManager = {
                state: {
                    workspaces: new Map(),
                    activeWorkspaceId: null,
                    theme: 'light'
                },
                listeners: [],

                subscribe(listener) {
                    this.listeners.push(listener);
                    return () => {
                        this.listeners = this.listeners.filter(l => l !== listener);
                    };
                },

                notify(event) {
                    this.listeners.forEach(listener => listener(event, this.state));
                },

                getActiveWorkspace() {
                    return this.state.workspaces.get(this.state.activeWorkspaceId);
                },

                setActiveWorkspace(id) {
                    if (this.state.workspaces.has(id)) {
                        this.state.activeWorkspaceId = id;
                        this.notify({ type: 'WORKSPACE_CHANGED', workspaceId: id });
                    }
                },

                updatePattern(text) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        workspace.patternText = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'PATTERN_UPDATED', workspaceId: workspace.id });
                    }
                },

                updateFlowNotes(flowIndex, text) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.flowNotes) {
                            workspace.flowNotes = {};
                        }
                        workspace.flowNotes[flowIndex] = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'FLOW_NOTES_UPDATED', workspaceId: workspace.id, flowIndex });
                    }
                },

                getFlowNotes(flowIndex) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.flowNotes) {
                        return workspace.flowNotes[flowIndex] || '';
                    }
                    return '';
                },

                updateFlowDescription(flowIndex, type, text) {
                    // type is 'beforeSource' or 'afterTarget'
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.flowDescriptions) {
                            workspace.flowDescriptions = {};
                        }
                        const key = `${flowIndex}-${type}`;
                        workspace.flowDescriptions[key] = text;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'FLOW_DESCRIPTION_UPDATED', workspaceId: workspace.id, flowIndex, descType: type });
                    }
                },

                getFlowDescription(flowIndex, type) {
                    // type is 'beforeSource' or 'afterTarget'
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.flowDescriptions) {
                        const key = `${flowIndex}-${type}`;
                        return workspace.flowDescriptions[key] || '';
                    }
                    return '';
                },

                updateAnnotation(flowIndex, edgeIndex, field, value) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace) {
                        if (!workspace.annotations) {
                            workspace.annotations = {};
                        }
                        const key = `${flowIndex}-${edgeIndex}-${field}`;
                        workspace.annotations[key] = value;
                        workspace.metadata.updatedAt = Date.now();
                        this.notify({ type: 'ANNOTATION_UPDATED', workspaceId: workspace.id });
                    }
                },

                getAnnotation(flowIndex, edgeIndex, field) {
                    const workspace = this.getActiveWorkspace();
                    if (workspace && workspace.annotations) {
                        const key = `${flowIndex}-${edgeIndex}-${field}`;
                        return workspace.annotations[key] || '';
                    }
                    return '';
                },

                setTheme(theme) {
                    this.state.theme = theme;
                    this.notify({ type: 'THEME_CHANGED', theme });
                }
            };

            // ============================================
            // PERSISTENCE LAYER
            // ============================================
            const Persistence = {
                STORAGE_KEY: 'mft_flow_visualizer',
                VERSION: '1.1.0',

                save() {
                    try {
                        const data = {
                            version: this.VERSION,
                            activeWorkspaceId: StateManager.state.activeWorkspaceId,
                            theme: StateManager.state.theme,
                            workspaces: Array.from(StateManager.state.workspaces.entries()).map(([id, ws]) => ({
                                id: ws.id,
                                name: ws.name,
                                patternText: ws.patternText,
                                flowNotes: ws.flowNotes || {},
                                flowDescriptions: ws.flowDescriptions || {},
                                annotations: ws.annotations || {},
                                metadata: ws.metadata
                            }))
                        };
                        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                        return true;
                    } catch (e) {
                        console.error('Failed to save:', e);
                        return false;
                    }
                },

                load() {
                    try {
                        const raw = localStorage.getItem(this.STORAGE_KEY);
                        if (!raw) return null;

                        const data = JSON.parse(raw);

                        // Convert workspaces array back to Map
                        const workspaces = new Map();
                        if (data.workspaces) {
                            data.workspaces.forEach(ws => {
                                workspaces.set(ws.id, {
                                    ...ws,
                                    flowNotes: ws.flowNotes || {},
                                    flowDescriptions: ws.flowDescriptions || {},
                                    annotations: ws.annotations || {}
                                });
                            });
                        }

                        return {
                            ...data,
                            workspaces
                        };
                    } catch (e) {
                        console.error('Failed to load:', e);
                        return null;
                    }
                },

                clear() {
                    localStorage.removeItem(this.STORAGE_KEY);
                }
            };

            // ============================================
            // WORKSPACE MANAGER
            // ============================================
            const WorkspaceManager = {
                createWorkspace(name = 'Untitled Workspace') {
                    const id = generateId();
                    const workspace = {
                        id,
                        name,
                        patternText: '',
                        flowNotes: {},
                        flowDescriptions: {},
                        annotations: {},
                        metadata: {
                            createdAt: Date.now(),
                            updatedAt: Date.now(),
                            version: '1.0.0'
                        }
                    };
                    StateManager.state.workspaces.set(id, workspace);
                    StateManager.setActiveWorkspace(id);
                    Persistence.save();
                    return workspace;
                },

                renameWorkspace(id, newName) {
                    const workspace = StateManager.state.workspaces.get(id);
                    if (workspace) {
                        workspace.name = newName;
                        workspace.metadata.updatedAt = Date.now();
                        StateManager.notify({ type: 'WORKSPACE_RENAMED', workspaceId: id });
                        Persistence.save();
                    }
                },

                duplicateWorkspace(id) {
                    const original = StateManager.state.workspaces.get(id);
                    if (original) {
                        const newId = generateId();
                        const duplicate = {
                            ...JSON.parse(JSON.stringify(original)),
                            id: newId,
                            name: original.name + ' (Copy)',
                            metadata: {
                                createdAt: Date.now(),
                                updatedAt: Date.now(),
                                version: original.metadata.version
                            }
                        };
                        StateManager.state.workspaces.set(newId, duplicate);
                        StateManager.setActiveWorkspace(newId);
                        Persistence.save();
                        return duplicate;
                    }
                    return null;
                },

                deleteWorkspace(id) {
                    if (StateManager.state.workspaces.size <= 1) {
                        alert('Cannot delete the last workspace');
                        return false;
                    }

                    StateManager.state.workspaces.delete(id);

                    // Switch to another workspace
                    const firstId = StateManager.state.workspaces.keys().next().value;
                    StateManager.setActiveWorkspace(firstId);
                    Persistence.save();
                    return true;
                },

                initialize() {
                    const saved = Persistence.load();

                    if (saved && saved.workspaces.size > 0) {
                        StateManager.state.workspaces = saved.workspaces;
                        StateManager.state.theme = saved.theme || 'light';

                        // Set active workspace
                        if (saved.activeWorkspaceId && saved.workspaces.has(saved.activeWorkspaceId)) {
                            StateManager.setActiveWorkspace(saved.activeWorkspaceId);
                        } else {
                            const firstId = saved.workspaces.keys().next().value;
                            StateManager.setActiveWorkspace(firstId);
                        }
                    } else {
                        // Create default workspace
                        this.createWorkspace('My First Flow');
                    }
                }
            };

            // ============================================
            // PARSER ENGINE
            // ============================================
            const Parser = {
                parseMultiple(text) {
                    const lines = text.split('\n').filter(line => line.trim());
                    const results = [];
                    const errors = [];

                    lines.forEach((line, index) => {
                        const result = this.parseLine(line.trim(), index + 1);
                        if (result.error) {
                            errors.push({ line: index + 1, message: result.error });
                        } else if (result.nodes.length > 0) {
                            results.push({
                                lineNumber: index + 1,
                                originalText: line.trim(),
                                nodes: result.nodes,
                                edges: result.edges
                            });
                        }
                    });

                    return { flows: results, errors };
                },

                parseLine(text, lineNumber) {
                    const result = {
                        nodes: [],
                        edges: [],
                        error: null
                    };

                    if (!text || !text.trim()) {
                        return result;
                    }

                    const trimmed = text.trim();

                    // Tokenize the pattern
                    const tokens = this.tokenize(trimmed);

                    if (tokens.error) {
                        result.error = tokens.error;
                        return result;
                    }

                    // Build nodes and edges from tokens
                    const { nodes, edges, error } = this.buildGraph(tokens.segments);

                    if (error) {
                        result.error = error;
                        return result;
                    }

                    result.nodes = nodes;
                    result.edges = edges;

                    return result;
                },

                tokenize(text) {
                    const segments = [];

                    // Split by arrows while keeping track of direction
                    const arrowPattern = /(<-|->)/g;
                    const parts = text.split(arrowPattern).map(p => p.trim()).filter(p => p);

                    if (parts.length < 5) {
                        return { error: 'Invalid pattern. Expected: Entity -> PROTOCOL DIRECTION -> Entity' };
                    }

                    let currentIndex = 0;

                    // First entity - accept any string (no validation)
                    const firstEntity = parts[currentIndex];
                    segments.push({ type: 'entity', value: firstEntity });
                    currentIndex++;

                    while (currentIndex < parts.length) {
                        // Expect arrow
                        const arrow1 = parts[currentIndex];
                        if (arrow1 !== '<-' && arrow1 !== '->') {
                            return { error: `Expected arrow (<- or ->), got: "${arrow1}"` };
                        }
                        currentIndex++;

                        // Expect PROTOCOL DIRECTION
                        if (currentIndex >= parts.length) {
                            return { error: 'Unexpected end of pattern after arrow' };
                        }
                        const protocolDir = parts[currentIndex];
                        // Match protocol (can contain spaces, letters, numbers, underscores) followed by PULL or PUSH
                        const pdMatch = protocolDir.match(/^(.+?)\s+(PULL|PUSH)$/i);
                        if (!pdMatch) {
                            return { error: `Invalid protocol/direction: "${protocolDir}". Expected: PROTOCOL PULL/PUSH` };
                        }
                        currentIndex++;

                        // Expect second arrow (should match the first in direction sense)
                        if (currentIndex >= parts.length) {
                            return { error: 'Unexpected end of pattern, expected arrow' };
                        }
                        const arrow2 = parts[currentIndex];
                        if (arrow2 !== '<-' && arrow2 !== '->') {
                            return { error: `Expected arrow (<- or ->), got: "${arrow2}"` };
                        }

                        // Validate arrow consistency
                        if (arrow1 !== arrow2) {
                            return { error: `Inconsistent arrows: ${arrow1} and ${arrow2}. Both should match.` };
                        }
                        currentIndex++;

                        // Expect entity - accept any string (no validation)
                        if (currentIndex >= parts.length) {
                            return { error: 'Unexpected end of pattern, expected entity' };
                        }
                        const entity = parts[currentIndex];

                        // Preserve original protocol name case for matching (e.g., "Amazon S3" not "AMAZON S3")
                        const protocolName = pdMatch[1].trim();
                        segments.push({
                            type: 'connection',
                            arrow: arrow1,
                            protocol: protocolName,
                            direction: pdMatch[2].toUpperCase(),
                            toEntity: entity
                        });

                        segments.push({ type: 'entity', value: entity });
                        currentIndex++;
                    }

                    return { segments };
                },


                buildGraph(segments) {
                    const nodes = [];
                    const edges = [];
                    const nodeMap = new Map();

                    let nodeIndex = 0;

                    // First pass: collect all unique entities
                    segments.forEach(seg => {
                        if (seg.type === 'entity' && !nodeMap.has(seg.value)) {
                            nodeMap.set(seg.value, nodeIndex++);
                        }
                    });

                    // Determine node types based on position
                    const entityList = segments.filter(s => s.type === 'entity').map(s => s.value);

                    entityList.forEach((entity, idx) => {
                        let type = 'intermediate';
                        if (idx === 0) type = 'source';
                        else if (idx === entityList.length - 1) type = 'target';

                        nodes.push({
                            id: 'node_' + idx,
                            label: entity,
                            type: type,
                            index: idx
                        });
                    });

                    // Second pass: build edges
                    let lastEntity = null;
                    let edgeIndex = 0;
                    segments.forEach(seg => {
                        if (seg.type === 'entity') {
                            lastEntity = seg.value;
                        } else if (seg.type === 'connection' && lastEntity) {
                            const fromEntity = lastEntity;
                            const toEntity = seg.toEntity;

                            // Determine actual from/to based on arrow direction
                            let flowDirection = seg.arrow === '<-' ? 'reverse' : 'forward';

                            edges.push({
                                id: 'edge_' + edgeIndex,
                                fromLabel: fromEntity,
                                toLabel: toEntity,
                                protocol: seg.protocol,
                                direction: seg.direction,
                                flowDirection: flowDirection,
                                index: edgeIndex
                            });
                            edgeIndex++;
                        }
                    });

                    return { nodes, edges, error: null };
                }
            };

            // ============================================
            // DIAGRAM RENDERER
            // ============================================
            const DiagramRenderer = {
                selectedFlowIndex: null,
                flows: [],

                render(flows, container) {
                    container.innerHTML = '';
                    this.flows = flows;

                    if (!flows || flows.length === 0) {
                        document.getElementById('emptyState').style.display = 'block';
                        this.updateFlowSelector([]);
                        this.updateRequiredProducts(null);
                        this.updateNotesField(null);
                        return;
                    }

                    document.getElementById('emptyState').style.display = 'none';

                    flows.forEach((flow, flowIndex) => {
                        const rowElement = this.createFlowRow(flow, flowIndex);
                        container.appendChild(rowElement);
                    });

                    // Update flow selector
                    this.updateFlowSelector(flows);

                    // If no flow selected, select first one
                    if (this.selectedFlowIndex === null && flows.length > 0) {
                        this.selectFlow(0);
                    } else if (this.selectedFlowIndex !== null) {
                        this.selectFlow(this.selectedFlowIndex);
                    }
                },

                updateFlowSelector(flows) {
                    const selector = document.getElementById('flowSelector');
                    if (!selector) return;

                    selector.innerHTML = '<option value="">-- Select a flow --</option>';
                    flows.forEach((flow, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Flow ${index + 1}: ${flow.originalText.substring(0, 50)}${flow.originalText.length > 50 ? '...' : ''}`;
                        selector.appendChild(option);
                    });

                    if (this.selectedFlowIndex !== null) {
                        selector.value = this.selectedFlowIndex;
                    }
                },

                selectFlow(flowIndex) {
                    this.selectedFlowIndex = flowIndex;

                    // Update UI
                    const rows = document.querySelectorAll('.flow-row');
                    rows.forEach((row, index) => {
                        if (index === flowIndex) {
                            row.classList.add('selected');
                        } else {
                            row.classList.remove('selected');
                        }
                    });

                    const selector = document.getElementById('flowSelector');
                    if (selector) {
                        selector.value = flowIndex;
                    }

                    // Update flow navigation items selection
                    const flowNavItems = document.querySelectorAll('.flow-nav-item');
                    flowNavItems.forEach((item, index) => {
                        if (index === flowIndex) {
                            item.classList.add('selected');
                        } else {
                            item.classList.remove('selected');
                        }
                    });

                    // Update notes and products for selected flow
                    if (flowIndex !== null && this.flows[flowIndex]) {
                        this.updateNotesField(flowIndex);
                        this.updateRequiredProducts(flowIndex);
                    } else {
                        this.updateNotesField(null);
                        this.updateRequiredProducts(null);
                    }
                },

                updateRequiredProducts(flowIndex) {
                    const productsList = document.getElementById('requiredProductsList');
                    if (!productsList) return;

                    if (flowIndex === null || !this.flows[flowIndex]) {
                        productsList.innerHTML = '<div class="no-products-message">Select a flow to see potential products</div>';
                        return;
                    }

                    const flow = this.flows[flowIndex];
                    const requiredProducts = getRequiredProducts([flow]);

                    if (requiredProducts.length === 0) {
                        productsList.innerHTML = '<div class="no-products-message">No matching products found for the protocols used</div>';
                        return;
                    }

                    productsList.innerHTML = requiredProducts.map(product => {
                        const capabilitiesHtml = product.supportedCapabilities
                            .map(cap => `<span class="capability-badge">${cap}</span>`)
                            .join('');
                        return `
                        <div class="product-item">
                            <div class="product-name">${product.name}</div>
                            <div class="product-capabilities">${capabilitiesHtml}</div>
                        </div>
                    `;
                    }).join('');
                },

                updateNotesField(flowIndex) {
                    const notesField = document.getElementById('generalNotesField');
                    if (!notesField) return;

                    if (flowIndex === null) {
                        notesField.value = '';
                        notesField.disabled = true;
                    } else {
                        notesField.value = StateManager.getFlowNotes(flowIndex);
                        notesField.disabled = false;
                    }
                },

                createFlowRow(flow, flowIndex) {
                    const row = document.createElement('div');
                    row.className = 'flow-row';
                    if (flowIndex === this.selectedFlowIndex) {
                        row.classList.add('selected');
                    }

                    // Make row clickable
                    row.addEventListener('click', () => {
                        this.selectFlow(flowIndex);
                    });

                    // Row number indicator
                    const rowNumber = document.createElement('div');
                    rowNumber.className = 'flow-row-number';
                    rowNumber.textContent = `Flow ${flowIndex + 1}`;
                    row.appendChild(rowNumber);

                    // Render nodes and edges
                    flow.nodes.forEach((node, nodeIndex) => {
                        // Add "Before Source" description field before the first node (source)
                        if (nodeIndex === 0 && node.type === 'source') {
                            const beforeSourceField = this.createDescriptionField(flowIndex, 'beforeSource', 'Before Source');
                            row.appendChild(beforeSourceField);
                        }

                        // Add node
                        const nodeElement = this.createNodeElement(node);
                        row.appendChild(nodeElement);

                        // Add edge after node (except for last node)
                        if (nodeIndex < flow.edges.length) {
                            const edge = flow.edges[nodeIndex];
                            const edgeElement = this.createEdgeElement(edge, flowIndex, nodeIndex);
                            row.appendChild(edgeElement);
                        }

                        // Add "After Target" description field after the last node (target)
                        if (nodeIndex === flow.nodes.length - 1 && node.type === 'target') {
                            const afterTargetField = this.createDescriptionField(flowIndex, 'afterTarget', 'After Target');
                            row.appendChild(afterTargetField);
                        }
                    });

                    return row;
                },

                createDescriptionField(flowIndex, type, label) {
                    const container = document.createElement('div');
                    container.className = `flow-description-field ${type === 'beforeSource' ? 'before-source' : 'after-target'}`;

                    const labelElement = document.createElement('div');
                    labelElement.className = 'flow-description-label';
                    labelElement.textContent = label;

                    const textarea = document.createElement('textarea');
                    textarea.className = 'flow-description-input';
                    textarea.placeholder = type === 'beforeSource'
                        ? 'Describe pre-source steps...'
                        : 'Describe post-target steps...';
                    textarea.value = StateManager.getFlowDescription(flowIndex, type);

                    // Debounced save
                    let saveTimeout;
                    textarea.addEventListener('input', () => {
                        clearTimeout(saveTimeout);
                        saveTimeout = setTimeout(() => {
                            StateManager.updateFlowDescription(flowIndex, type, textarea.value);
                            Persistence.save();
                        }, 300);
                    });

                    // Stop propagation to prevent row selection when typing
                    textarea.addEventListener('click', (e) => e.stopPropagation());

                    container.appendChild(labelElement);
                    container.appendChild(textarea);

                    return container;
                },

                createNodeElement(node) {
                    const container = document.createElement('div');
                    container.className = 'flow-node';

                    const box = document.createElement('div');
                    box.className = `node-box ${node.type}`;
                    box.textContent = node.label;

                    const typeLabel = document.createElement('div');
                    typeLabel.className = 'node-type';
                    typeLabel.textContent = node.type;

                    container.appendChild(box);
                    container.appendChild(typeLabel);

                    return container;
                },

                createEdgeElement(edge, flowIndex, edgeIndex) {
                    const container = document.createElement('div');
                    container.className = 'flow-edge';

                    // Check if protocol+direction is valid
                    const currentCapability = `${edge.protocol} ${edge.direction}`;
                    // Ensure functions are available (defensive check)
                    // If function doesn't exist, default to invalid (show dropdown) to be safe
                    let isValid = false;
                    if (typeof isValidCapability === 'function') {
                        try {
                            isValid = isValidCapability(edge.protocol, edge.direction);
                        } catch (e) {
                            console.error('Error checking capability validity:', e);
                            isValid = false; // Default to invalid on error
                        }
                    } else {
                        console.warn('isValidCapability function not found - treating all as potentially invalid');
                        // Default to showing dropdown if function not available
                        isValid = false;
                    }

                    // Protocol label or select dropdown
                    let protocolElement;
                    if (!isValid) {
                        // Create select dropdown for invalid capabilities
                        protocolElement = document.createElement('select');
                        protocolElement.className = 'edge-protocol-select';
                        protocolElement.title = 'Unknown capability - select a valid one';

                        // Get all available capabilities
                        const allCapabilities = getAllAvailableCapabilities();

                        // Add current (invalid) value as first option
                        const currentOption = document.createElement('option');
                        currentOption.value = currentCapability;
                        currentOption.textContent = `${edge.protocol} ${edge.direction} âš `;
                        currentOption.selected = true;
                        protocolElement.appendChild(currentOption);

                        // Add separator
                        const separator = document.createElement('option');
                        separator.disabled = true;
                        separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                        protocolElement.appendChild(separator);

                        // Add all valid capabilities
                        allCapabilities.forEach(cap => {
                            const option = document.createElement('option');
                            option.value = cap;
                            option.textContent = cap;
                            protocolElement.appendChild(option);
                        });

                        // Handle change event
                        protocolElement.addEventListener('change', (e) => {
                            const newCapability = e.target.value;
                            if (newCapability && newCapability !== currentCapability) {
                                this.updateProtocolInPattern(flowIndex, edgeIndex, edge.protocol, edge.direction, newCapability);
                            }
                        });
                    } else {
                        // Create regular div for valid capabilities
                        protocolElement = document.createElement('div');
                        protocolElement.className = 'edge-protocol';
                        protocolElement.textContent = currentCapability;
                    }

                    // Line container
                    const lineContainer = document.createElement('div');
                    lineContainer.className = 'edge-line-container';

                    // Arrow at start if reverse
                    if (edge.flowDirection === 'reverse') {
                        const arrowStart = document.createElement('div');
                        arrowStart.className = 'edge-arrow reverse';
                        lineContainer.appendChild(arrowStart);
                    }

                    // Line
                    const line = document.createElement('div');
                    line.className = 'edge-line';
                    lineContainer.appendChild(line);

                    // Arrow at end if forward
                    if (edge.flowDirection === 'forward') {
                        const arrowEnd = document.createElement('div');
                        arrowEnd.className = 'edge-arrow';
                        lineContainer.appendChild(arrowEnd);
                    }

                    // Annotations container
                    const annotations = document.createElement('div');
                    annotations.className = 'edge-annotations';

                    // Pre-processing annotation
                    const preLabel = document.createElement('div');
                    preLabel.className = 'annotation-label';
                    preLabel.textContent = 'Pre-Processing';

                    const preInput = document.createElement('input');
                    preInput.type = 'text';
                    preInput.className = 'annotation-input';
                    preInput.placeholder = 'Add notes...';
                    preInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre');
                    preInput.addEventListener('input', debounce((e) => {
                        StateManager.updateAnnotation(flowIndex, edgeIndex, 'pre', e.target.value);
                        this.triggerSave();
                    }, 300));

                    // Post-processing annotation
                    const postLabel = document.createElement('div');
                    postLabel.className = 'annotation-label';
                    postLabel.textContent = 'Post-Processing';

                    const postInput = document.createElement('input');
                    postInput.type = 'text';
                    postInput.className = 'annotation-input';
                    postInput.placeholder = 'Add notes...';
                    postInput.value = StateManager.getAnnotation(flowIndex, edgeIndex, 'post');
                    postInput.addEventListener('input', debounce((e) => {
                        StateManager.updateAnnotation(flowIndex, edgeIndex, 'post', e.target.value);
                        this.triggerSave();
                    }, 300));

                    annotations.appendChild(preLabel);
                    annotations.appendChild(preInput);
                    annotations.appendChild(postLabel);
                    annotations.appendChild(postInput);

                    container.appendChild(protocolElement);
                    container.appendChild(lineContainer);
                    container.appendChild(annotations);

                    return container;
                },

                updateProtocolInPattern(flowIndex, edgeIndex, oldProtocol, oldDirection, newCapability) {
                    // Parse new capability to get protocol and direction
                    const parts = newCapability.split(' ');
                    if (parts.length < 2) return;

                    const newDirection = parts[parts.length - 1];
                    const newProtocol = parts.slice(0, -1).join(' ');

                    // Get current pattern text
                    const patternText = UIController.elements.patternEditor.value;
                    const lines = patternText.split('\n');

                    // Find the flow's line
                    const result = Parser.parseMultiple(patternText);
                    if (!result.flows || flowIndex >= result.flows.length) return;

                    // Find which line contains this flow
                    let flowLineIndex = -1;
                    let currentFlowIndex = 0;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line || line.startsWith('//')) continue;

                        const lineResult = Parser.parseMultiple(line);
                        if (lineResult.flows && lineResult.flows.length > 0) {
                            if (currentFlowIndex === flowIndex) {
                                flowLineIndex = i;
                                break;
                            }
                            currentFlowIndex++;
                        }
                    }

                    if (flowLineIndex === -1) return;

                    // Parse the line to get segments
                    const line = lines[flowLineIndex];
                    const parseResult = Parser.parseMultiple(line);
                    if (!parseResult.flows || parseResult.flows.length === 0) return;

                    const flow = parseResult.flows[0];
                    if (!flow.edges || edgeIndex >= flow.edges.length) return;

                    // Rebuild the line by replacing the specific edge's protocol+direction
                    const entities = flow.nodes.map(n => n.label);
                    const edges = flow.edges;

                    // Rebuild the line string: Entity -> Protocol Direction -> Entity <- Protocol Direction <- Entity
                    const newLineParts = [entities[0]];

                    for (let i = 0; i < edges.length; i++) {
                        const edge = edges[i];
                        const arrow = edge.flowDirection === 'reverse' ? '<-' : '->';
                        const protocol = (i === edgeIndex) ? newProtocol : edge.protocol;
                        const direction = (i === edgeIndex) ? newDirection : edge.direction;

                        newLineParts.push(arrow);
                        newLineParts.push(`${protocol} ${direction}`);
                        newLineParts.push(arrow);
                        newLineParts.push(entities[i + 1]);
                    }

                    const newLine = newLineParts.join(' ');

                    // Update the pattern text
                    lines[flowLineIndex] = newLine;
                    const updatedPattern = lines.join('\n');

                    // Update the editor and trigger re-render
                    UIController.elements.patternEditor.value = updatedPattern;
                    UIController.updatePattern();
                    UIController.setSaveIndicator('saving');
                    Persistence.save();
                    setTimeout(() => UIController.setSaveIndicator('saved'), 500);
                },

                triggerSave() {
                    UIController.setSaveIndicator('saving');
                    Persistence.save();
                    setTimeout(() => UIController.setSaveIndicator('saved'), 500);
                }
            };

            // Make debounce available to DiagramRenderer
            DiagramRenderer.debounce = debounce;

            // ============================================
            // UI CONTROLLER
            // ============================================
            const UIController = {
                elements: {},

                init() {
                    // Cache DOM elements
                    this.elements = {
                        workspaceSelect: document.getElementById('workspaceSelect'),
                        patternEditor: document.getElementById('patternEditor'),
                        lineNumbers: document.getElementById('lineNumbers'),
                        generalNotesField: document.getElementById('generalNotesField'),
                        flowSelector: document.getElementById('flowSelector'),
                        errorMessage: document.getElementById('errorMessage'),
                        saveIndicator: document.getElementById('saveIndicator'),
                        saveText: document.getElementById('saveText'),
                        canvasContainer: document.getElementById('canvasContainer'),
                        emptyState: document.getElementById('emptyState'),
                        modalOverlay: document.getElementById('modalOverlay'),
                        modalTitle: document.getElementById('modalTitle'),
                        modalInput: document.getElementById('modalInput'),
                        modalConfirmBtn: document.getElementById('modalConfirmBtn'),
                        helpPanel: document.getElementById('helpPanel')
                    };

                    this.bindEvents();
                },

                bindEvents() {
                    // Workspace controls
                    document.getElementById('newWorkspaceBtn').addEventListener('click', () => {
                        this.showModal('New Workspace', 'Untitled Workspace', 'Create', (name) => {
                            WorkspaceManager.createWorkspace(name);
                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                        });
                    });

                    document.getElementById('renameWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws) {
                            this.showModal('Rename Workspace', ws.name, 'Rename', (name) => {
                                WorkspaceManager.renameWorkspace(ws.id, name);
                                this.updateWorkspaceSelect();
                            });
                        }
                    });

                    document.getElementById('duplicateWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws) {
                            WorkspaceManager.duplicateWorkspace(ws.id);
                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                        }
                    });

                    document.getElementById('deleteWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws && confirm(`Delete workspace "${ws.name}"?`)) {
                            WorkspaceManager.deleteWorkspace(ws.id);
                            this.updateWorkspaceSelect();
                            this.loadActiveWorkspace();
                        }
                    });

                    // Export workspace
                    document.getElementById('exportWorkspaceBtn').addEventListener('click', () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (ws) {
                            const exportData = {
                                version: 1,
                                exportedAt: new Date().toISOString(),
                                workspace: {
                                    name: ws.name,
                                    patternText: ws.patternText || '',
                                    flowNotes: ws.flowNotes || {},
                                    flowDescriptions: ws.flowDescriptions || {},
                                    annotations: ws.annotations || {}
                                }
                            };
                            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `${ws.name.replace(/[^a-z0-9]/gi, '_')}_workspace.json`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }
                    });

                    // Import workspace
                    const importFileInput = document.getElementById('importFileInput');
                    document.getElementById('importWorkspaceBtn').addEventListener('click', () => {
                        importFileInput.click();
                    });

                    importFileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;

                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                if (!data.workspace || !data.workspace.name) {
                                    throw new Error('Invalid workspace file format');
                                }

                                // Create new workspace with imported data
                                const newWorkspace = WorkspaceManager.createWorkspace(data.workspace.name + ' (imported)');
                                // Update the workspace with imported content
                                newWorkspace.patternText = data.workspace.patternText || '';
                                newWorkspace.flowNotes = data.workspace.flowNotes || {};
                                newWorkspace.flowDescriptions = data.workspace.flowDescriptions || {};
                                newWorkspace.annotations = data.workspace.annotations || {};
                                Persistence.save();

                                this.updateWorkspaceSelect();
                                this.loadActiveWorkspace();
                                alert(`Workspace "${data.workspace.name}" imported successfully!`);
                            } catch (err) {
                                alert('Failed to import workspace: ' + err.message);
                            }
                        };
                        reader.readAsText(file);
                        // Reset input so same file can be imported again
                        importFileInput.value = '';
                    });

                    // Export PDF Report
                    document.getElementById('exportPdfBtn').addEventListener('click', async () => {
                        const ws = StateManager.getActiveWorkspace();
                        if (!ws) {
                            alert('No workspace selected');
                            return;
                        }

                        // Show loading indicator
                        const originalTitle = document.title;
                        document.title = 'Generating PDF...';
                        this.setSaveIndicator('saving');

                        try {
                            await this.exportToPDF(ws);
                        } catch (err) {
                            console.error('PDF export error:', err);
                            alert('Failed to generate PDF: ' + err.message);
                        } finally {
                            document.title = originalTitle;
                            this.setSaveIndicator('saved');
                        }
                    });

                    this.elements.workspaceSelect.addEventListener('change', (e) => {
                        StateManager.setActiveWorkspace(e.target.value);
                        this.loadActiveWorkspace();
                    });

                    // Pattern editor
                    const debouncedUpdate = debounce(() => {
                        this.updatePattern();
                        this.setSaveIndicator('saving');
                        Persistence.save();
                        setTimeout(() => this.setSaveIndicator('saved'), 500);
                    }, 300);

                    this.elements.patternEditor.addEventListener('input', () => {
                        this.updateLineNumbers();
                        debouncedUpdate();
                    });

                    // Sync line numbers scroll with textarea scroll
                    this.elements.patternEditor.addEventListener('scroll', () => {
                        this.elements.lineNumbers.scrollTop = this.elements.patternEditor.scrollTop;
                    });

                    // Initial line numbers update
                    this.updateLineNumbers();

                    // Flow selector
                    this.elements.flowSelector.addEventListener('change', (e) => {
                        const flowIndex = e.target.value === '' ? null : parseInt(e.target.value);
                        DiagramRenderer.selectFlow(flowIndex);
                    });

                    // General notes field
                    const debouncedNotesUpdate = debounce(() => {
                        const flowIndex = DiagramRenderer.selectedFlowIndex;
                        if (flowIndex !== null) {
                            StateManager.updateFlowNotes(flowIndex, this.elements.generalNotesField.value);
                            this.setSaveIndicator('saving');
                            Persistence.save();
                            setTimeout(() => this.setSaveIndicator('saved'), 500);
                        }
                    }, 300);

                    this.elements.generalNotesField.addEventListener('input', debouncedNotesUpdate);

                    // Theme toggle
                    document.getElementById('themeToggleBtn').addEventListener('click', () => {
                        const newTheme = StateManager.state.theme === 'light' ? 'dark' : 'light';
                        StateManager.setTheme(newTheme);
                        document.body.setAttribute('data-theme', newTheme);
                        this.updateThemeIcon();
                        Persistence.save();
                    });

                    // Help panel
                    document.getElementById('helpBtn').addEventListener('click', () => {
                        this.elements.helpPanel.classList.add('visible');
                    });

                    document.getElementById('closeHelpBtn').addEventListener('click', () => {
                        this.elements.helpPanel.classList.remove('visible');
                    });

                    // Architecture diagram modal
                    document.getElementById('architectureBtn').addEventListener('click', () => {
                        this.showArchitectureDiagram();
                    });

                    document.getElementById('closeArchitectureBtn').addEventListener('click', () => {
                        this.hideArchitectureDiagram();
                    });

                    document.getElementById('architectureModal').addEventListener('click', (e) => {
                        if (e.target.id === 'architectureModal') {
                            this.hideArchitectureDiagram();
                        }
                    });

                    // Kroki diagram modal
                    document.getElementById('krokiBtn').addEventListener('click', () => {
                        this.showKrokiDiagram();
                    });

                    document.getElementById('closeKrokiBtn').addEventListener('click', () => {
                        this.hideKrokiDiagram();
                    });

                    document.getElementById('krokiModal').addEventListener('click', (e) => {
                        if (e.target.id === 'krokiModal') {
                            this.hideKrokiDiagram();
                        }
                    });

                    document.getElementById('krokiCopyCodeBtn').addEventListener('click', () => {
                        if (this.currentKrokiCode) {
                            navigator.clipboard.writeText(this.currentKrokiCode).then(() => {
                                const btn = document.getElementById('krokiCopyCodeBtn');
                                const originalText = btn.innerHTML;
                                btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!`;
                                setTimeout(() => {
                                    btn.innerHTML = originalText;
                                }, 2000);
                            });
                        }
                    });

                    document.getElementById('krokiOpenExternalBtn').addEventListener('click', () => {
                        if (this.currentKrokiUrl) {
                            window.open(this.currentKrokiUrl, '_blank');
                        }
                    });

                    // Kroki zoom controls
                    document.getElementById('krokiZoomInBtn').addEventListener('click', () => {
                        this.krokiZoom(0.25);
                    });

                    document.getElementById('krokiZoomOutBtn').addEventListener('click', () => {
                        this.krokiZoom(-0.25);
                    });

                    document.getElementById('krokiZoomResetBtn').addEventListener('click', () => {
                        this.krokiZoomReset();
                    });

                    // Kroki mouse wheel zoom
                    const krokiContainer = document.getElementById('krokiCanvasContainer');
                    krokiContainer.addEventListener('wheel', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const delta = e.deltaY > 0 ? -0.1 : 0.1;
                            this.krokiZoom(delta);
                        }
                    }, { passive: false });

                    // Kroki image drag/pan
                    const krokiImage = document.getElementById('krokiImage');
                    let krokiIsDragging = false;
                    let krokiStartX = 0;
                    let krokiStartY = 0;
                    let krokiScrollLeft = 0;
                    let krokiScrollTop = 0;

                    krokiImage.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        krokiIsDragging = true;
                        krokiImage.classList.add('dragging');
                        krokiStartX = e.pageX - krokiContainer.offsetLeft;
                        krokiStartY = e.pageY - krokiContainer.offsetTop;
                        krokiScrollLeft = krokiContainer.scrollLeft;
                        krokiScrollTop = krokiContainer.scrollTop;
                        e.preventDefault();
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!krokiIsDragging) return;
                        const x = e.pageX - krokiContainer.offsetLeft;
                        const y = e.pageY - krokiContainer.offsetTop;
                        const walkX = (x - krokiStartX) * 1.5;
                        const walkY = (y - krokiStartY) * 1.5;
                        krokiContainer.scrollLeft = krokiScrollLeft - walkX;
                        krokiContainer.scrollTop = krokiScrollTop - walkY;
                    });

                    document.addEventListener('mouseup', () => {
                        if (krokiIsDragging) {
                            krokiIsDragging = false;
                            krokiImage.classList.remove('dragging');
                        }
                    });

                    // Architecture canvas panning
                    const archCanvasContainer = document.getElementById('architectureCanvasContainer');
                    let isPanning = false;
                    let panStartX = 0;
                    let panStartY = 0;
                    let scrollLeft = 0;
                    let scrollTop = 0;

                    archCanvasContainer.addEventListener('mousedown', (e) => {
                        isPanning = true;
                        panStartX = e.pageX - archCanvasContainer.offsetLeft;
                        panStartY = e.pageY - archCanvasContainer.offsetTop;
                        scrollLeft = archCanvasContainer.scrollLeft;
                        scrollTop = archCanvasContainer.scrollTop;
                        archCanvasContainer.style.cursor = 'grabbing';
                    });

                    archCanvasContainer.addEventListener('mouseleave', () => {
                        isPanning = false;
                        archCanvasContainer.style.cursor = 'grab';
                    });

                    archCanvasContainer.addEventListener('mouseup', () => {
                        isPanning = false;
                        archCanvasContainer.style.cursor = 'grab';
                    });

                    archCanvasContainer.addEventListener('mousemove', (e) => {
                        if (!isPanning) return;
                        e.preventDefault();
                        const x = e.pageX - archCanvasContainer.offsetLeft;
                        const y = e.pageY - archCanvasContainer.offsetTop;
                        const walkX = (x - panStartX) * 1.5;
                        const walkY = (y - panStartY) * 1.5;
                        archCanvasContainer.scrollLeft = scrollLeft - walkX;
                        archCanvasContainer.scrollTop = scrollTop - walkY;
                    });

                    // Modal
                    document.getElementById('modalCancelBtn').addEventListener('click', () => {
                        this.hideModal();
                    });

                    this.elements.modalInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            this.elements.modalConfirmBtn.click();
                        } else if (e.key === 'Escape') {
                            this.hideModal();
                        }
                    });

                    // Click outside modal to close
                    this.elements.modalOverlay.addEventListener('click', (e) => {
                        if (e.target === this.elements.modalOverlay) {
                            this.hideModal();
                        }
                    });

                    // Keyboard shortcuts
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            // Close kroki modal if open
                            const krokiModal = document.getElementById('krokiModal');
                            if (krokiModal.classList.contains('visible')) {
                                this.hideKrokiDiagram();
                                return;
                            }
                            // Close architecture modal if open
                            const archModal = document.getElementById('architectureModal');
                            if (archModal.classList.contains('visible')) {
                                this.hideArchitectureDiagram();
                                return;
                            }
                        }
                        if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                            e.preventDefault();
                            document.getElementById('themeToggleBtn').click();
                        } else if (e.ctrlKey && e.key === 'n') {
                            e.preventDefault();
                            document.getElementById('newWorkspaceBtn').click();
                        }
                    });
                },

                updateWorkspaceSelect() {
                    const select = this.elements.workspaceSelect;
                    select.innerHTML = '';

                    StateManager.state.workspaces.forEach((ws, id) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = ws.name;
                        option.selected = id === StateManager.state.activeWorkspaceId;
                        select.appendChild(option);
                    });
                },

                loadActiveWorkspace() {
                    const ws = StateManager.getActiveWorkspace();
                    if (ws) {
                        this.elements.patternEditor.value = ws.patternText || '';
                        DiagramRenderer.selectedFlowIndex = null;
                        this.updateLineNumbers();
                        this.updatePattern();
                    }
                },

                updatePattern() {
                    const text = this.elements.patternEditor.value;
                    StateManager.updatePattern(text);

                    const result = Parser.parseMultiple(text);

                    if (result.errors.length > 0) {
                        this.showErrors(result.errors);
                    } else {
                        this.hideError();
                    }

                    DiagramRenderer.render(result.flows, this.elements.canvasContainer);

                    // Update flow analysis panel
                    this.updateFlowAnalysis(result.flows, text);
                },

                updateFlowAnalysis(flows, text) {
                    // Update stats
                    const flowCount = flows.length;
                    const uniqueNodes = new Set();
                    const protocolsUsed = new Map();

                    flows.forEach(flow => {
                        if (flow && flow.nodes) {
                            flow.nodes.forEach(node => {
                                uniqueNodes.add(node.label);
                            });
                        }
                        if (flow && flow.edges) {
                            flow.edges.forEach(edge => {
                                const protocol = edge.protocol;
                                if (protocol) {
                                    protocolsUsed.set(protocol, (protocolsUsed.get(protocol) || 0) + 1);
                                }
                            });
                        }
                    });

                    document.getElementById('statFlowCount').textContent = flowCount;
                    document.getElementById('statNodeCount').textContent = uniqueNodes.size;
                    document.getElementById('statProtocolCount').textContent = protocolsUsed.size;

                    // Update protocol tags
                    const protocolTags = document.getElementById('protocolTags');
                    if (protocolsUsed.size > 0) {
                        protocolTags.innerHTML = Array.from(protocolsUsed.entries())
                            .sort((a, b) => b[1] - a[1])
                            .map(([protocol, count]) =>
                                `<span class="protocol-tag" data-protocol="${protocol}">${protocol}<span class="tag-count">${count}</span></span>`
                            ).join('');

                        // Add click handlers for protocol tags
                        protocolTags.querySelectorAll('.protocol-tag').forEach(tag => {
                            tag.addEventListener('click', () => {
                                const protocol = tag.dataset.protocol;
                                this.highlightProtocolInEditor(protocol);
                            });
                        });
                    } else {
                        protocolTags.innerHTML = '<span style="color: var(--text-muted); font-size: 11px; font-style: italic;">No protocols detected</span>';
                    }

                    // Update flow navigation combobox
                    const flowNavSelect = document.getElementById('flowNavSelect');
                    const lines = text.split('\n');

                    if (flowCount > 0) {
                        let flowLineIndex = 0;
                        let optionsHtml = '<option value="">-- Select a flow --</option>';

                        flows.forEach((flow, index) => {
                            // Find the line for this flow
                            while (flowLineIndex < lines.length && lines[flowLineIndex].trim() === '') {
                                flowLineIndex++;
                            }
                            const lineNum = flowLineIndex + 1;
                            flowLineIndex++;

                            // Create preview from nodes
                            const preview = flow.nodes ? flow.nodes.map(n => n.label).join(' â†’ ') : 'Flow ' + (index + 1);
                            const isSelected = DiagramRenderer.selectedFlowIndex === index;

                            optionsHtml += `<option value="${index}" data-line="${lineNum}" ${isSelected ? 'selected' : ''}>L${lineNum}: ${preview}</option>`;
                        });

                        flowNavSelect.innerHTML = optionsHtml;

                        // Add change handler
                        flowNavSelect.onchange = () => {
                            const selectedOption = flowNavSelect.options[flowNavSelect.selectedIndex];
                            if (selectedOption.value !== '') {
                                const flowIndex = parseInt(selectedOption.value);
                                const lineNum = parseInt(selectedOption.dataset.line);
                                DiagramRenderer.selectFlow(flowIndex);
                                this.scrollToLine(lineNum);
                            }
                        };
                    } else {
                        flowNavSelect.innerHTML = '<option value="">-- No flows defined --</option>';
                    }
                },

                highlightProtocolInEditor(protocol) {
                    const editor = this.elements.patternEditor;
                    const text = editor.value;
                    const regex = new RegExp(protocol, 'gi');
                    const match = regex.exec(text);

                    if (match) {
                        editor.focus();
                        editor.setSelectionRange(match.index, match.index + match[0].length);

                        // Calculate approximate line and scroll
                        const textBefore = text.substring(0, match.index);
                        const lineNum = textBefore.split('\n').length;
                        this.scrollToLine(lineNum);
                    }
                },

                scrollToLine(lineNum) {
                    const editor = this.elements.patternEditor;
                    const lineHeight = 22.4; // matches CSS
                    const scrollTop = (lineNum - 1) * lineHeight;
                    editor.scrollTop = scrollTop;
                    this.elements.lineNumbers.scrollTop = scrollTop;
                },

                showErrors(errors) {
                    const errorHtml = errors.map(e =>
                        `<div class="error-line">Line ${e.line}: ${e.message}</div>`
                    ).join('');
                    this.elements.errorMessage.innerHTML = errorHtml;
                    this.elements.errorMessage.classList.add('visible');
                },

                hideError() {
                    this.elements.errorMessage.classList.remove('visible');
                },

                updateLineNumbers() {
                    const text = this.elements.patternEditor.value;
                    const lines = text.split('\n');
                    const lineCount = lines.length || 1;

                    // Generate line numbers HTML
                    let lineNumbersHtml = '';
                    for (let i = 1; i <= lineCount; i++) {
                        lineNumbersHtml += `<span>${i}</span>`;
                    }

                    this.elements.lineNumbers.innerHTML = lineNumbersHtml;
                },

                setSaveIndicator(status) {
                    const indicator = this.elements.saveIndicator;
                    indicator.classList.remove('saving', 'saved');
                    indicator.classList.add(status);
                    this.elements.saveText.textContent = status === 'saving' ? 'Saving...' : 'Saved';
                },

                async exportToPDF(workspace) {
                    // Show loading overlay
                    const loadingOverlay = document.getElementById('loadingOverlay');
                    loadingOverlay.classList.add('visible');

                    try {
                        await this._generatePDF(workspace);
                    } catch (error) {
                        console.error('PDF generation failed:', error);
                        alert('Failed to generate PDF. Please try again.');
                    } finally {
                        // Hide loading overlay
                        loadingOverlay.classList.remove('visible');
                    }
                },

                async _generatePDF(workspace) {
                    // Check if libraries are available
                    if (typeof html2canvas === 'undefined' || typeof window.jspdf === 'undefined') {
                        alert('PDF libraries not loaded. Please refresh the page and try again.');
                        return;
                    }

                    // Parse flows to get current state
                    const patternText = workspace.patternText || '';
                    const result = Parser.parseMultiple(patternText);
                    const flows = result.flows || [];

                    // Create a temporary container for PDF content
                    const pdfContainer = document.createElement('div');
                    pdfContainer.id = 'pdf-export-container';
                    // Position it absolutely off-screen but visible to html2canvas
                    pdfContainer.style.position = 'absolute';
                    pdfContainer.style.top = '0';
                    pdfContainer.style.left = '-2000px'; // Off-screen but not too far
                    pdfContainer.style.width = '794px'; // A4 width in pixels (210mm at 96 DPI)
                    pdfContainer.style.padding = '40px';
                    pdfContainer.style.backgroundColor = '#ffffff';
                    pdfContainer.style.fontFamily = 'Arial, sans-serif';
                    pdfContainer.style.color = '#333333';
                    pdfContainer.style.zIndex = '99999';
                    pdfContainer.style.boxSizing = 'border-box';
                    pdfContainer.style.overflow = 'visible';
                    pdfContainer.style.display = 'block';
                    document.body.appendChild(pdfContainer);

                    try {
                        // Cover page
                        const coverPage = document.createElement('div');
                        coverPage.className = 'pdf-cover-page';
                        coverPage.style.display = 'flex';
                        coverPage.style.flexDirection = 'column';
                        coverPage.style.alignItems = 'center';
                        coverPage.style.justifyContent = 'center';
                        coverPage.style.minHeight = '714px'; // A4 height minus padding in pixels (~270mm)
                        coverPage.style.height = '714px';
                        coverPage.style.textAlign = 'center';
                        coverPage.style.backgroundColor = '#ffffff';
                        coverPage.style.marginBottom = '20px';

                        // Logo (using SVG data URL for better PDF compatibility)
                        const logoContainer = document.createElement('div');
                        logoContainer.style.marginBottom = '40px';
                        const logoSvg = document.createElement('div');
                        logoSvg.innerHTML = `<svg width="200" height="68" viewBox="0 0 137 47" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M76.6496 46.9993L80.5925 37.9543L73.4876 22.7627H78.5529L83.0057 32.9377L87.1186 22.7627H91.9465L81.4423 46.9993H76.6496ZM69.4101 33.1143V32.3377L65.6372 32.9377C64.4811 33.1143 63.5639 33.7843 63.5639 35.1277C63.5639 36.1527 64.2774 37.1427 65.7382 37.1427C67.6431 37.1427 69.4101 36.1893 69.4101 33.1143ZM64.0401 30.1477L68.153 29.511C69.1038 29.3693 69.4101 28.8743 69.4101 28.2743C69.4101 27.0377 68.4929 26.0127 66.5896 26.0127C64.6174 26.0127 63.5286 27.3193 63.3923 28.8393L59.3805 27.956C59.6531 25.2343 62.0663 22.2327 66.5543 22.2327C71.8585 22.2327 73.8292 25.341 73.8292 28.8393V37.3893C73.8292 38.3077 73.9318 39.546 74.0328 40.146H69.8863C69.7853 39.686 69.7163 38.7327 69.7163 38.061C68.8665 39.4393 67.2679 40.641 64.7873 40.641C61.2181 40.641 59.0422 38.1327 59.0422 35.411C59.0422 32.3027 61.2517 30.571 64.0401 30.1477ZM48.2686 22.7627L51.8716 33.9627L54.9662 22.7627H59.4511L54.2174 40.146H49.6957L45.7865 28.2743L41.9446 40.146H37.3555L32.0193 22.7627H36.7783L39.8713 33.9277L43.5096 22.7627H48.2686ZM21.4157 31.4177L15.4653 22.7627H20.8368C21.4157 23.716 23.5899 26.966 24.1688 27.921L27.4655 22.7627H32.5981L26.7519 31.2777L32.8017 40.146H27.4991L23.9972 34.811C23.3863 35.7643 21.1431 39.1927 20.5642 40.146H15.4653L21.4157 31.4177ZM10.3679 33.1143V32.3377L6.59659 32.9377C5.4405 33.1143 4.52172 33.7843 4.52172 35.1277C4.52172 36.1527 5.23526 37.1427 6.696 37.1427C8.6009 37.1427 10.3679 36.1893 10.3679 33.1143ZM4.99635 30.1477L9.11079 29.511C10.0632 29.3693 10.3679 28.8743 10.3679 28.2743C10.3679 27.0377 9.45072 26.0127 7.54583 26.0127C5.57519 26.0127 4.48805 27.3193 4.35176 28.8393L0.339931 27.956C0.612517 25.2343 3.02571 22.2327 7.51376 22.2327C12.8148 22.2327 14.787 25.341 14.787 28.8393V37.3893C14.787 38.3077 14.888 39.546 14.9922 40.146H10.8441C10.7415 39.686 10.6742 38.7327 10.6742 38.061C9.82433 39.4393 8.22569 40.641 5.74516 40.641C2.17588 40.641 0 38.1327 0 35.411C0 32.3027 2.20955 30.571 4.99635 30.1477Z" fill="#4A4F54"/><path fill-rule="evenodd" clip-rule="evenodd" d="M132.708 26.3917L99.0455 10.7197V16.3933L125.843 28.8685L132.708 26.3917ZM103.04 21.0861V26.7581L109.161 29.5933L99.3136 39.7965H105.843L117.528 27.8269L103.04 21.0861ZM132.698 15.0525L132.71 23.5661L94.4803 5.75807V0.0844727L127.93 15.6749V7.15647L136.703 11.2413V16.9181L132.698 15.0525Z" fill="#E82C2A"/></svg>`;
                        logoContainer.appendChild(logoSvg);
                        coverPage.appendChild(logoContainer);

                        // Title
                        const title = document.createElement('h1');
                        title.textContent = 'MFT Flow Visualizer';
                        title.style.fontSize = '36px';
                        title.style.fontWeight = 'bold';
                        title.style.color = '#2c3e50';
                        title.style.marginBottom = '20px';
                        title.style.marginTop = '0';
                        coverPage.appendChild(title);

                        // Subtitle
                        const subtitle = document.createElement('h2');
                        subtitle.textContent = 'Flow Analysis Report';
                        subtitle.style.fontSize = '24px';
                        subtitle.style.fontWeight = 'normal';
                        subtitle.style.color = '#7f8c8d';
                        subtitle.style.marginBottom = '60px';
                        subtitle.style.marginTop = '0';
                        coverPage.appendChild(subtitle);

                        // Workspace name
                        const workspaceName = document.createElement('div');
                        workspaceName.style.fontSize = '28px';
                        workspaceName.style.fontWeight = '600';
                        workspaceName.style.color = '#34495e';
                        workspaceName.style.marginBottom = '40px';
                        workspaceName.textContent = workspace.name;
                        coverPage.appendChild(workspaceName);

                        // Date
                        const date = document.createElement('div');
                        date.style.fontSize = '14px';
                        date.style.color = '#95a5a6';
                        date.textContent = `Generated on ${new Date().toLocaleDateString('en-US', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        })}`;
                        coverPage.appendChild(date);

                        pdfContainer.appendChild(coverPage);

                        // Flow diagrams and notes
                        if (flows.length === 0) {
                            const noFlows = document.createElement('div');
                            noFlows.style.padding = '40px';
                            noFlows.style.textAlign = 'center';
                            noFlows.style.color = '#7f8c8d';
                            noFlows.textContent = 'No flows defined in this workspace.';
                            pdfContainer.appendChild(noFlows);
                        } else {
                            flows.forEach((flow, flowIndex) => {
                                const flowSection = document.createElement('div');
                                flowSection.className = 'pdf-flow-section';
                                flowSection.style.marginBottom = '40px';
                                flowSection.style.backgroundColor = '#ffffff';
                                flowSection.style.paddingBottom = '20px';

                                // Flow header
                                const flowHeader = document.createElement('h2');
                                flowHeader.textContent = `Flow ${flowIndex + 1}`;
                                flowHeader.style.fontSize = '20px';
                                flowHeader.style.fontWeight = 'bold';
                                flowHeader.style.color = '#2c3e50';
                                flowHeader.style.marginBottom = '15px';
                                flowHeader.style.borderBottom = '2px solid #3498db';
                                flowHeader.style.paddingBottom = '10px';
                                flowSection.appendChild(flowHeader);

                                // Flow diagram (clone the rendered flow - simplified version)
                                const canvasContainer = this.elements.canvasContainer;
                                const flowRow = canvasContainer.querySelector(`.flow-row:nth-child(${flowIndex + 1})`);
                                if (flowRow) {
                                    const diagramClone = flowRow.cloneNode(true);
                                    diagramClone.style.marginBottom = '20px';
                                    diagramClone.style.display = 'inline-flex';
                                    diagramClone.style.padding = '20px';
                                    diagramClone.style.backgroundColor = '#ffffff';
                                    diagramClone.style.transformOrigin = 'left top';

                                    // Remove all text fields - they are shown below as formatted text
                                    // Remove before source / after target description fields
                                    diagramClone.querySelectorAll('.flow-description-field').forEach(el => el.remove());
                                    // Remove annotation sections (pre/post processing inputs)
                                    diagramClone.querySelectorAll('.edge-annotations').forEach(el => el.remove());
                                    // Remove "Flow X" row number indicator (already shown as section title)
                                    diagramClone.querySelectorAll('.flow-row-number').forEach(el => el.remove());

                                    // Fix arrow lines - use solid dark color instead of CSS variable gradient
                                    // The gradient with CSS variables doesn't render well in html2canvas
                                    diagramClone.querySelectorAll('.edge-line').forEach(el => {
                                        el.style.backgroundImage = 'none';
                                        el.style.backgroundColor = '#2c3e50';
                                        el.style.animation = 'none';
                                    });

                                    // Fix arrow heads - use solid dark color
                                    diagramClone.querySelectorAll('.edge-arrow').forEach(el => {
                                        // Check if it's a reverse arrow
                                        if (el.classList.contains('reverse')) {
                                            el.style.borderRightColor = '#2c3e50';
                                        } else {
                                            el.style.borderLeftColor = '#2c3e50';
                                        }
                                    });

                                    // Replace select dropdowns with simple text
                                    diagramClone.querySelectorAll('select').forEach(el => {
                                        const text = document.createElement('span');
                                        text.textContent = el.value || el.options[0]?.textContent || '';
                                        text.style.fontStyle = 'italic';
                                        text.style.color = '#e74c3c';
                                        el.parentNode.replaceChild(text, el);
                                    });
                                    // Remove any remaining inputs and buttons
                                    diagramClone.querySelectorAll('input').forEach(el => el.remove());
                                    diagramClone.querySelectorAll('textarea').forEach(el => el.remove());
                                    diagramClone.querySelectorAll('button').forEach(el => el.remove());

                                    // Create a wrapper to handle scaling for wide diagrams
                                    const diagramWrapper = document.createElement('div');
                                    diagramWrapper.style.width = '100%';
                                    diagramWrapper.style.overflow = 'hidden';
                                    diagramWrapper.style.marginBottom = '20px';
                                    diagramWrapper.appendChild(diagramClone);
                                    flowSection.appendChild(diagramWrapper);

                                    // After adding to DOM, check if we need to scale down
                                    // We'll do this after all sections are added
                                    diagramWrapper.dataset.needsScaling = 'true';
                                }

                                // Flow descriptions (before source / after target)
                                const beforeSource = workspace.flowDescriptions?.[`${flowIndex}-beforeSource`];
                                const afterTarget = workspace.flowDescriptions?.[`${flowIndex}-afterTarget`];

                                if (beforeSource || afterTarget) {
                                    const descSection = document.createElement('div');
                                    descSection.style.marginTop = '20px';
                                    descSection.style.marginBottom = '20px';
                                    descSection.style.display = 'flex';
                                    descSection.style.gap = '20px';
                                    descSection.style.flexWrap = 'wrap';

                                    if (beforeSource) {
                                        const beforeDiv = document.createElement('div');
                                        beforeDiv.style.flex = '1';
                                        beforeDiv.style.minWidth = '200px';

                                        const beforeLabel = document.createElement('div');
                                        beforeLabel.textContent = 'Before Source:';
                                        beforeLabel.style.fontWeight = 'bold';
                                        beforeLabel.style.marginBottom = '8px';
                                        beforeLabel.style.color = '#27ae60';
                                        beforeDiv.appendChild(beforeLabel);

                                        const beforeContent = document.createElement('div');
                                        beforeContent.textContent = beforeSource;
                                        beforeContent.style.padding = '12px';
                                        beforeContent.style.backgroundColor = '#f0fff4';
                                        beforeContent.style.borderLeft = '4px solid #27ae60';
                                        beforeContent.style.whiteSpace = 'pre-wrap';
                                        beforeContent.style.lineHeight = '1.6';
                                        beforeDiv.appendChild(beforeContent);

                                        descSection.appendChild(beforeDiv);
                                    }

                                    if (afterTarget) {
                                        const afterDiv = document.createElement('div');
                                        afterDiv.style.flex = '1';
                                        afterDiv.style.minWidth = '200px';

                                        const afterLabel = document.createElement('div');
                                        afterLabel.textContent = 'After Target:';
                                        afterLabel.style.fontWeight = 'bold';
                                        afterLabel.style.marginBottom = '8px';
                                        afterLabel.style.color = '#e74c3c';
                                        afterDiv.appendChild(afterLabel);

                                        const afterContent = document.createElement('div');
                                        afterContent.textContent = afterTarget;
                                        afterContent.style.padding = '12px';
                                        afterContent.style.backgroundColor = '#fff5f5';
                                        afterContent.style.borderLeft = '4px solid #e74c3c';
                                        afterContent.style.whiteSpace = 'pre-wrap';
                                        afterContent.style.lineHeight = '1.6';
                                        afterDiv.appendChild(afterContent);

                                        descSection.appendChild(afterDiv);
                                    }

                                    flowSection.appendChild(descSection);
                                }

                                // Flow notes
                                const flowNotes = workspace.flowNotes?.[flowIndex];
                                if (flowNotes) {
                                    const notesSection = document.createElement('div');
                                    notesSection.style.marginTop = '20px';
                                    notesSection.style.marginBottom = '20px';

                                    const notesLabel = document.createElement('div');
                                    notesLabel.textContent = 'General Notes:';
                                    notesLabel.style.fontWeight = 'bold';
                                    notesLabel.style.marginBottom = '8px';
                                    notesLabel.style.color = '#34495e';
                                    notesSection.appendChild(notesLabel);

                                    const notesContent = document.createElement('div');
                                    notesContent.textContent = flowNotes || '';
                                    notesContent.style.padding = '12px';
                                    notesContent.style.backgroundColor = '#f8f9fa';
                                    notesContent.style.borderLeft = '4px solid #3498db';
                                    notesContent.style.whiteSpace = 'pre-wrap';
                                    notesContent.style.lineHeight = '1.6';
                                    notesContent.style.wordWrap = 'break-word';
                                    notesSection.appendChild(notesContent);

                                    flowSection.appendChild(notesSection);
                                }

                                // Annotations for each edge
                                if (flow.edges) {
                                    flow.edges.forEach((edge, edgeIndex) => {
                                        const preAnnotation = StateManager.getAnnotation(flowIndex, edgeIndex, 'pre');
                                        const postAnnotation = StateManager.getAnnotation(flowIndex, edgeIndex, 'post');

                                        if (preAnnotation || postAnnotation) {
                                            const annotationSection = document.createElement('div');
                                            annotationSection.style.marginTop = '15px';
                                            annotationSection.style.marginBottom = '15px';

                                            const annotationLabel = document.createElement('div');
                                            annotationLabel.textContent = `Edge ${edgeIndex + 1}: ${edge.protocol} ${edge.direction}`;
                                            annotationLabel.style.fontWeight = '600';
                                            annotationLabel.style.marginBottom = '8px';
                                            annotationLabel.style.color = '#34495e';
                                            annotationSection.appendChild(annotationLabel);

                                            if (preAnnotation) {
                                                const preDiv = document.createElement('div');
                                                preDiv.style.marginBottom = '8px';
                                                const preLabel = document.createElement('strong');
                                                preLabel.textContent = 'Pre-Processing: ';
                                                const preText = document.createElement('span');
                                                preText.style.color = '#555';
                                                preText.textContent = preAnnotation;
                                                preDiv.appendChild(preLabel);
                                                preDiv.appendChild(preText);
                                                annotationSection.appendChild(preDiv);
                                            }

                                            if (postAnnotation) {
                                                const postDiv = document.createElement('div');
                                                const postLabel = document.createElement('strong');
                                                postLabel.textContent = 'Post-Processing: ';
                                                const postText = document.createElement('span');
                                                postText.style.color = '#555';
                                                postText.textContent = postAnnotation;
                                                postDiv.appendChild(postLabel);
                                                postDiv.appendChild(postText);
                                                annotationSection.appendChild(postDiv);
                                            }

                                            flowSection.appendChild(annotationSection);
                                        }
                                    });
                                }

                                pdfContainer.appendChild(flowSection);
                            });
                        }

                        // Debug: Check if content was added
                        console.log('PDF container children:', pdfContainer.children.length);
                        console.log('PDF container HTML length:', pdfContainer.innerHTML.length);

                        // Force a reflow to ensure content is rendered
                        pdfContainer.style.display = 'block';

                        // Scale down wide diagrams to fit PDF page width (with more margin for safety)
                        const maxDiagramWidth = 700;
                        pdfContainer.querySelectorAll('[data-needs-scaling="true"]').forEach(wrapper => {
                            const diagram = wrapper.querySelector('.flow-row');
                            if (diagram) {
                                // Temporarily set to auto width to measure natural size
                                diagram.style.width = 'auto';
                                const naturalWidth = diagram.scrollWidth;

                                if (naturalWidth > maxDiagramWidth) {
                                    const scale = maxDiagramWidth / naturalWidth;
                                    diagram.style.transform = `scale(${scale})`;
                                    diagram.style.transformOrigin = 'left top';
                                    // Adjust wrapper height to account for scaled content
                                    wrapper.style.height = `${diagram.scrollHeight * scale}px`;
                                    console.log(`Scaled diagram from ${naturalWidth}px to fit ${maxDiagramWidth}px (scale: ${scale.toFixed(2)})`);
                                }
                            }
                        });

                        const height = pdfContainer.offsetHeight || pdfContainer.scrollHeight;
                        const width = pdfContainer.offsetWidth || pdfContainer.scrollWidth;
                        console.log('Container dimensions:', width, 'x', height);
                        console.log('First child:', pdfContainer.firstElementChild?.tagName, pdfContainer.firstElementChild?.textContent?.substring(0, 50));

                        // Ensure container has content
                        if (pdfContainer.children.length === 0) {
                            throw new Error('No content to export. PDF container is empty.');
                        }

                        if (height === 0) {
                            console.warn('Container height is 0, but content exists. Trying to fix...');
                            pdfContainer.style.height = 'auto';
                            pdfContainer.style.minHeight = '100px';
                        }

                        // Wait for rendering and images to load
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // Re-check dimensions after wait
                        const finalHeight = pdfContainer.offsetHeight || pdfContainer.scrollHeight;
                        const finalWidth = pdfContainer.offsetWidth || pdfContainer.scrollWidth;
                        console.log('Final container dimensions:', finalWidth, 'x', finalHeight);

                        // Generate PDF
                        // Calculate actual content dimensions after rendering
                        const contentHeight = Math.max(pdfContainer.scrollHeight, pdfContainer.offsetHeight);
                        const contentWidth = Math.max(pdfContainer.scrollWidth, pdfContainer.offsetWidth);

                        console.log('Content dimensions:', contentWidth, 'x', contentHeight);
                        console.log('Container innerHTML length:', pdfContainer.innerHTML.length);

                        // Verify content exists
                        if (contentHeight === 0) {
                            throw new Error('No content to export. Container height is 0.');
                        }

                        // Temporarily move container into viewport for html2canvas to capture it
                        // Store original position
                        const originalLeft = pdfContainer.style.left;
                        const originalTop = pdfContainer.style.top;
                        const originalZIndex = pdfContainer.style.zIndex;
                        const originalPosition = pdfContainer.style.position;

                        // Move to top-left of viewport - keep it visible but off to the side
                        pdfContainer.style.position = 'fixed';
                        pdfContainer.style.left = '0';
                        pdfContainer.style.top = '0';
                        pdfContainer.style.zIndex = '999999';
                        pdfContainer.style.opacity = '1';
                        pdfContainer.style.visibility = 'visible';
                        pdfContainer.style.display = 'block';
                        pdfContainer.style.pointerEvents = 'none';
                        pdfContainer.style.overflow = 'visible';
                        pdfContainer.style.maxHeight = 'none';
                        pdfContainer.style.height = 'auto';
                        pdfContainer.style.width = '794px';

                        // Ensure all text and elements are visible and have proper colors
                        const allElements = pdfContainer.querySelectorAll('*');
                        allElements.forEach(el => {
                            const computed = window.getComputedStyle(el);
                            // Force visibility
                            if (computed.display === 'none') {
                                el.style.display = 'block';
                            }
                            if (computed.visibility === 'hidden') {
                                el.style.visibility = 'visible';
                            }
                            if (computed.opacity === '0') {
                                el.style.opacity = '1';
                            }
                            // Ensure text is visible
                            if (el.tagName && ['H1', 'H2', 'H3', 'P', 'DIV', 'SPAN'].includes(el.tagName)) {
                                if (!el.style.color || el.style.color === 'transparent') {
                                    el.style.color = '#333333';
                                }
                            }
                        });

                        // Force multiple reflows to ensure rendering
                        pdfContainer.offsetHeight;
                        pdfContainer.scrollHeight;
                        pdfContainer.offsetWidth;
                        pdfContainer.scrollWidth;

                        // Wait longer for browser to fully render everything
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // Verify content is actually visible and rendered
                        const testElement = pdfContainer.querySelector('h1');
                        if (testElement) {
                            const rect = testElement.getBoundingClientRect();
                            const computed = window.getComputedStyle(testElement);
                            console.log('Test element rect:', rect.width, 'x', rect.height);
                            console.log('Test element computed color:', computed.color);
                            console.log('Test element computed display:', computed.display);
                            console.log('Test element computed visibility:', computed.visibility);
                            console.log('Test element text:', testElement.textContent?.substring(0, 50));

                            if (rect.width === 0 || rect.height === 0) {
                                console.error('Content elements have zero dimensions!');
                                throw new Error('Content is not rendering properly');
                            }
                        }

                        try {
                            console.log('Starting PDF generation with direct html2canvas + jsPDF...');
                            console.log('Container position:', pdfContainer.style.left, pdfContainer.style.top);
                            console.log('Container dimensions:', pdfContainer.offsetWidth, 'x', pdfContainer.offsetHeight);

                            // Create PDF using jsPDF
                            const { jsPDF } = window.jspdf;
                            const pdf = new jsPDF({
                                orientation: 'portrait',
                                unit: 'mm',
                                format: 'a4'
                            });

                            // A4 dimensions
                            const pageWidth = 210;
                            const pageHeight = 297;
                            const margin = 15;
                            const contentWidth = pageWidth - (margin * 2);

                            // Get all sections to render separately (cover page + flow sections)
                            const sections = pdfContainer.querySelectorAll('.pdf-cover-page, .pdf-flow-section');
                            console.log('Found sections to render:', sections.length);

                            if (sections.length === 0) {
                                // Fallback: render entire container but with scale limit
                                const maxHeight = 5000; // Limit height to avoid memory issues
                                const canvas = await html2canvas(pdfContainer, {
                                    scale: 1,
                                    useCORS: true,
                                    logging: false,
                                    backgroundColor: '#ffffff',
                                    height: Math.min(pdfContainer.scrollHeight, maxHeight)
                                });

                                const imgData = canvas.toDataURL('image/jpeg', 0.9);
                                const imgWidth = contentWidth;
                                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                                pdf.addImage(imgData, 'JPEG', margin, margin, imgWidth, imgHeight);
                            } else {
                                // Render each section separately
                                let isFirstPage = true;

                                for (let i = 0; i < sections.length; i++) {
                                    const section = sections[i];
                                    console.log(`Rendering section ${i + 1}/${sections.length}:`, section.className);

                                    // Capture this section
                                    const canvas = await html2canvas(section, {
                                        scale: 1.5,
                                        useCORS: true,
                                        logging: false,
                                        backgroundColor: '#ffffff'
                                    });

                                    console.log(`Section ${i + 1} canvas:`, canvas.width, 'x', canvas.height);

                                    if (canvas.width === 0 || canvas.height === 0) {
                                        console.warn(`Section ${i + 1} has zero dimensions, skipping`);
                                        continue;
                                    }

                                    const imgData = canvas.toDataURL('image/jpeg', 0.9);

                                    if (imgData.length < 100) {
                                        console.warn(`Section ${i + 1} image data too small, skipping`);
                                        continue;
                                    }

                                    // Calculate dimensions
                                    const imgWidth = contentWidth;
                                    const imgHeight = (canvas.height * imgWidth) / canvas.width;

                                    // Add new page if not first
                                    if (!isFirstPage) {
                                        pdf.addPage();
                                    }
                                    isFirstPage = false;

                                    // Add image, handling multi-page sections
                                    let yPosition = margin;
                                    let remainingHeight = imgHeight;
                                    const availableHeight = pageHeight - (margin * 2);

                                    if (imgHeight <= availableHeight) {
                                        // Fits on one page
                                        pdf.addImage(imgData, 'JPEG', margin, yPosition, imgWidth, imgHeight);
                                    } else {
                                        // Need to split across pages
                                        const ratio = canvas.width / imgWidth;
                                        let sourceY = 0;

                                        while (remainingHeight > 0) {
                                            const sliceHeight = Math.min(remainingHeight, availableHeight);
                                            const sourceSliceHeight = sliceHeight * ratio;

                                            // Create a slice canvas
                                            const sliceCanvas = document.createElement('canvas');
                                            sliceCanvas.width = canvas.width;
                                            sliceCanvas.height = sourceSliceHeight;
                                            const sliceCtx = sliceCanvas.getContext('2d');
                                            sliceCtx.fillStyle = '#ffffff';
                                            sliceCtx.fillRect(0, 0, sliceCanvas.width, sliceCanvas.height);
                                            sliceCtx.drawImage(canvas, 0, sourceY, canvas.width, sourceSliceHeight, 0, 0, canvas.width, sourceSliceHeight);

                                            const sliceImgData = sliceCanvas.toDataURL('image/jpeg', 0.9);
                                            pdf.addImage(sliceImgData, 'JPEG', margin, margin, imgWidth, sliceHeight);

                                            sourceY += sourceSliceHeight;
                                            remainingHeight -= sliceHeight;

                                            if (remainingHeight > 0) {
                                                pdf.addPage();
                                            }
                                        }
                                    }
                                }
                            }

                            // Save the PDF
                            const filename = `${workspace.name.replace(/[^a-z0-9]/gi, '_')}_report.pdf`;
                            pdf.save(filename);
                            console.log('PDF saved:', filename);

                        } catch (error) {
                            console.error('PDF generation error:', error);
                            console.error('Error stack:', error.stack);
                            alert('Failed to generate PDF: ' + error.message + '\n\nCheck browser console for details.');
                            throw error;
                        } finally {
                            // Restore original position
                            pdfContainer.style.left = originalLeft;
                            pdfContainer.style.top = originalTop;
                            pdfContainer.style.zIndex = originalZIndex;
                            pdfContainer.style.position = originalPosition;
                            pdfContainer.style.opacity = '1';
                            pdfContainer.style.pointerEvents = 'auto';
                        }
                    } finally {
                        // Clean up
                        setTimeout(() => {
                            const container = document.getElementById('pdf-export-container');
                            if (container && container.parentNode) {
                                document.body.removeChild(container);
                            }
                        }, 1000);
                    }
                },

                showModal(title, defaultValue, confirmText, onConfirm) {
                    this.elements.modalTitle.textContent = title;
                    this.elements.modalInput.value = defaultValue;
                    this.elements.modalConfirmBtn.textContent = confirmText;
                    this.elements.modalOverlay.classList.add('visible');
                    this.elements.modalInput.focus();
                    this.elements.modalInput.select();

                    const confirmHandler = () => {
                        const value = this.elements.modalInput.value.trim();
                        if (value) {
                            onConfirm(value);
                            this.hideModal();
                        }
                    };

                    this.elements.modalConfirmBtn.onclick = confirmHandler;
                },

                hideModal() {
                    this.elements.modalOverlay.classList.remove('visible');
                },

                showArchitectureDiagram() {
                    const modal = document.getElementById('architectureModal');
                    const canvas = document.getElementById('architectureCanvas');

                    // Get current flows
                    const text = this.elements.patternEditor.value;
                    const result = Parser.parseMultiple(text);
                    const flows = result.flows;

                    if (flows.length === 0) {
                        alert('No flows defined. Add some flow patterns first.');
                        return;
                    }

                    // Build unique nodes and connections
                    const uniqueNodes = new Map(); // label -> { type, connections }
                    const uniqueConnections = new Map(); // "from|to|protocol|direction" -> { from, to, protocol, direction, flowDirection }
                    const protocolsUsed = new Set();

                    flows.forEach(flow => {
                        if (!flow || !flow.nodes || !flow.edges) return;

                        // Track nodes with their types
                        flow.nodes.forEach(node => {
                            if (!uniqueNodes.has(node.label)) {
                                uniqueNodes.set(node.label, {
                                    label: node.label,
                                    type: node.type,
                                    connections: new Set()
                                });
                            }
                        });

                        // Track unique connections
                        flow.edges.forEach(edge => {
                            const connectionKey = `${edge.fromLabel}|${edge.toLabel}|${edge.protocol}|${edge.direction}|${edge.flowDirection}`;
                            if (!uniqueConnections.has(connectionKey)) {
                                uniqueConnections.set(connectionKey, {
                                    from: edge.fromLabel,
                                    to: edge.toLabel,
                                    protocol: edge.protocol,
                                    direction: edge.direction,
                                    flowDirection: edge.flowDirection
                                });

                                // Track connections for each node
                                uniqueNodes.get(edge.fromLabel).connections.add(edge.toLabel);
                                uniqueNodes.get(edge.toLabel).connections.add(edge.fromLabel);
                            }
                            protocolsUsed.add(edge.protocol);
                        });
                    });

                    // Update stats
                    document.getElementById('archStatNodes').textContent = uniqueNodes.size;
                    document.getElementById('archStatConnections').textContent = uniqueConnections.size;
                    document.getElementById('archStatProtocols').textContent = protocolsUsed.size;

                    // Generate the diagram
                    this.generateArchitectureSVG(canvas, uniqueNodes, uniqueConnections);

                    // Show modal
                    modal.classList.add('visible');

                    // Center the view
                    const container = document.getElementById('architectureCanvasContainer');
                    setTimeout(() => {
                        container.scrollLeft = (canvas.clientWidth - container.clientWidth) / 2;
                        container.scrollTop = (canvas.clientHeight - container.clientHeight) / 2;
                    }, 100);
                },

                hideArchitectureDiagram() {
                    document.getElementById('architectureModal').classList.remove('visible');
                },

                // Kroki diagram state
                currentKrokiCode: null,
                currentKrokiUrl: null,
                krokiZoomLevel: 4.5,
                krokiMinZoom: 0.5,
                krokiMaxZoom: 10,
                krokiBaseWidth: null,
                krokiBaseHeight: null,

                krokiZoom(delta) {
                    const newZoom = Math.max(this.krokiMinZoom, Math.min(this.krokiMaxZoom, this.krokiZoomLevel + delta));
                    if (newZoom !== this.krokiZoomLevel) {
                        this.krokiZoomLevel = newZoom;
                        this.applyKrokiZoom();
                    }
                },

                krokiZoomReset() {
                    this.krokiZoomLevel = 1;
                    this.applyKrokiZoom();
                    // Also reset scroll position to center
                    const container = document.getElementById('krokiCanvasContainer');
                    const wrapper = document.getElementById('krokiImageWrapper');
                    setTimeout(() => {
                        container.scrollLeft = (wrapper.scrollWidth - container.clientWidth) / 2;
                        container.scrollTop = (wrapper.scrollHeight - container.clientHeight) / 2;
                    }, 50);
                },

                applyKrokiZoom() {
                    const image = document.getElementById('krokiImage');
                    const zoomLabel = document.getElementById('krokiZoomLevel');
                    
                    if (this.krokiBaseWidth && this.krokiBaseHeight) {
                        image.style.width = `${this.krokiBaseWidth * this.krokiZoomLevel}px`;
                        image.style.height = `${this.krokiBaseHeight * this.krokiZoomLevel}px`;
                    }
                    zoomLabel.textContent = `${Math.round(this.krokiZoomLevel * 100)}%`;
                },

                async showKrokiDiagram() {
                    const modal = document.getElementById('krokiModal');
                    const loading = document.getElementById('krokiLoading');
                    const image = document.getElementById('krokiImage');

                    // Get current flows
                    const text = this.elements.patternEditor.value;
                    const result = Parser.parseMultiple(text);
                    const flows = result.flows;

                    if (flows.length === 0) {
                        alert('No flows defined. Add some flow patterns first.');
                        return;
                    }

                    // Show modal with loading state
                    modal.classList.add('visible');
                    loading.classList.remove('hidden');
                    image.classList.remove('visible');

                    // Build unique nodes and connections
                    const uniqueNodes = new Map();
                    const uniqueConnections = new Map();

                    flows.forEach(flow => {
                        if (!flow || !flow.nodes || !flow.edges) return;

                        flow.nodes.forEach(node => {
                            if (!uniqueNodes.has(node.label)) {
                                uniqueNodes.set(node.label, {
                                    label: node.label,
                                    type: node.type
                                });
                            }
                        });

                        flow.edges.forEach(edge => {
                            const connectionKey = `${edge.fromLabel}|${edge.toLabel}|${edge.protocol}|${edge.direction}`;
                            if (!uniqueConnections.has(connectionKey)) {
                                uniqueConnections.set(connectionKey, {
                                    from: edge.fromLabel,
                                    to: edge.toLabel,
                                    protocol: edge.protocol,
                                    direction: edge.direction,
                                    flowDirection: edge.flowDirection
                                });
                            }
                        });
                    });

                    // Update stats
                    document.getElementById('krokiStatNodes').textContent = uniqueNodes.size;
                    document.getElementById('krokiStatConnections').textContent = uniqueConnections.size;

                    // Generate D2 code
                    const d2Code = this.generateD2Code(uniqueNodes, uniqueConnections);
                    this.currentKrokiCode = d2Code;

                    try {
                        // Encode D2 code for Kroki API
                        const encoded = this.encodeKrokiDiagram(d2Code);
                        const krokiUrl = `https://kroki.io/d2/svg/${encoded}`;
                        this.currentKrokiUrl = krokiUrl;

                        // Fetch the diagram
                        const response = await fetch(krokiUrl);
                        if (!response.ok) {
                            throw new Error(`Kroki API error: ${response.status}`);
                        }

                        const svgText = await response.text();
                        
                        // Convert SVG to data URL for the image
                        const svgBlob = new Blob([svgText], { type: 'image/svg+xml' });
                        const svgUrl = URL.createObjectURL(svgBlob);

                        image.onload = () => {
                            // Store the natural dimensions as base for zoom
                            this.krokiBaseWidth = image.naturalWidth;
                            this.krokiBaseHeight = image.naturalHeight;
                            
                            // Set initial zoom to 450%
                            this.krokiZoomLevel = 4.5;
                            image.style.width = `${this.krokiBaseWidth * this.krokiZoomLevel}px`;
                            image.style.height = `${this.krokiBaseHeight * this.krokiZoomLevel}px`;
                            document.getElementById('krokiZoomLevel').textContent = '450%';
                            
                            loading.classList.add('hidden');
                            image.classList.add('visible');
                            URL.revokeObjectURL(svgUrl);
                            
                            // Center the view after image loads
                            const container = document.getElementById('krokiCanvasContainer');
                            const wrapper = document.getElementById('krokiImageWrapper');
                            setTimeout(() => {
                                container.scrollLeft = Math.max(0, (wrapper.scrollWidth - container.clientWidth) / 2);
                                container.scrollTop = Math.max(0, (wrapper.scrollHeight - container.clientHeight) / 2);
                            }, 50);
                        };

                        image.onerror = () => {
                            loading.innerHTML = `<div class="kroki-error"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg><span>Failed to load diagram</span></div>`;
                        };

                        image.src = svgUrl;
                    } catch (error) {
                        console.error('Kroki diagram error:', error);
                        loading.innerHTML = `<div class="kroki-error"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg><span>Failed to generate diagram: ${error.message}</span></div>`;
                    }
                },

                hideKrokiDiagram() {
                    const modal = document.getElementById('krokiModal');
                    const loading = document.getElementById('krokiLoading');
                    const image = document.getElementById('krokiImage');
                    
                    modal.classList.remove('visible');
                    
                    // Reset state for next time
                    loading.classList.remove('hidden');
                    loading.innerHTML = `<div class="kroki-spinner"></div><span>Generating diagram...</span>`;
                    image.classList.remove('visible');
                    image.src = '';
                    
                    // Reset zoom
                    this.krokiZoomLevel = 1;
                    this.krokiBaseWidth = null;
                    this.krokiBaseHeight = null;
                    image.style.width = '';
                    image.style.height = '';
                    document.getElementById('krokiZoomLevel').textContent = '100%';
                },

                generateD2Code(nodes, connections) {
                    const lines = [];
                    
                    // Add title
                    lines.push('# MFT Flow Architecture');
                    lines.push('');

                    // Define node styles based on type
                    const nodeStyles = {
                        source: 'style.fill: "#e8f5e9"\nstyle.stroke: "#2e7d32"\nstyle.font-color: "#1b5e20"',
                        intermediate: 'style.fill: "#e3f2fd"\nstyle.stroke: "#1565c0"\nstyle.font-color: "#0d47a1"',
                        target: 'style.fill: "#fce4ec"\nstyle.stroke: "#c2185b"\nstyle.font-color: "#880e4f"'
                    };

                    // Helper to create safe D2 identifiers
                    const safeId = (label) => {
                        return label.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
                    };

                    // Declare nodes with their styles
                    const nodeArray = Array.from(nodes.values());
                    nodeArray.forEach(node => {
                        const id = safeId(node.label);
                        const style = nodeStyles[node.type] || nodeStyles.intermediate;
                        lines.push(`${id}: "${node.label}" {`);
                        lines.push(`  shape: rectangle`);
                        style.split('\n').forEach(s => lines.push(`  ${s}`));
                        lines.push(`}`);
                        lines.push('');
                    });

                    // Add connections with protocol labels
                    const connectionArray = Array.from(connections.values());
                    connectionArray.forEach(conn => {
                        const fromId = safeId(conn.from);
                        const toId = safeId(conn.to);
                        const label = `${conn.protocol} (${conn.direction})`;
                        
                        // Use different arrow styles based on direction
                        const arrow = conn.direction === 'PUSH' ? '->' : '<-';
                        lines.push(`${fromId} ${arrow} ${toId}: "${label}" {`);
                        lines.push(`  style.stroke: "#546e7a"`);
                        lines.push(`  style.font-size: 12`);
                        lines.push(`}`);
                    });

                    // Add legend
                    lines.push('');
                    lines.push('legend: "Legend" {');
                    lines.push('  Source: "Source" {');
                    lines.push('    style.fill: "#e8f5e9"');
                    lines.push('    style.stroke: "#2e7d32"');
                    lines.push('  }');
                    lines.push('  Intermediate: "MFT Hub" {');
                    lines.push('    style.fill: "#e3f2fd"');
                    lines.push('    style.stroke: "#1565c0"');
                    lines.push('  }');
                    lines.push('  Target: "Target" {');
                    lines.push('    style.fill: "#fce4ec"');
                    lines.push('    style.stroke: "#c2185b"');
                    lines.push('  }');
                    lines.push('}');

                    return lines.join('\n');
                },

                encodeKrokiDiagram(source) {
                    // Kroki uses zlib deflate + base64url encoding
                    // pako.deflate (without raw:true) produces zlib format which is what Kroki expects
                    const data = new TextEncoder().encode(source);
                    const compressed = pako.deflate(data, { level: 9 });
                    return this.base64UrlEncode(compressed);
                },

                base64UrlEncode(data) {
                    // Convert Uint8Array to base64url
                    let binary = '';
                    for (let i = 0; i < data.length; i++) {
                        binary += String.fromCharCode(data[i]);
                    }
                    const base64 = btoa(binary);
                    // Convert to base64url
                    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                },

                generateArchitectureSVG(svg, nodes, connections) {
                    // Clear existing content
                    svg.innerHTML = '';

                    const nodeArray = Array.from(nodes.values());
                    const connectionArray = Array.from(connections.values());

                    // Layout configuration
                    const nodeWidth = 120;
                    const nodeHeight = 45;
                    const padding = 120;
                    const radialDistance = 280; // Distance from hub to connected nodes

                    // Build adjacency map to count connections per node
                    const adjacencyMap = new Map();
                    nodeArray.forEach(node => {
                        adjacencyMap.set(node.label, {
                            node: node,
                            connectedTo: new Set(),
                            connectionCount: 0
                        });
                    });

                    connectionArray.forEach(conn => {
                        if (adjacencyMap.has(conn.from) && adjacencyMap.has(conn.to)) {
                            adjacencyMap.get(conn.from).connectedTo.add(conn.to);
                            adjacencyMap.get(conn.to).connectedTo.add(conn.from);
                            adjacencyMap.get(conn.from).connectionCount++;
                            adjacencyMap.get(conn.to).connectionCount++;
                        }
                    });

                    // Sort nodes by connection count (hubs first)
                    const sortedNodes = Array.from(adjacencyMap.values())
                        .sort((a, b) => b.connectionCount - a.connectionCount);

                    const nodePositions = new Map();
                    const placedNodes = new Set();

                    // Helper function to check if a position overlaps with existing nodes
                    const checkOverlap = (x, y, minDist = 140) => {
                        for (const [label, pos] of nodePositions) {
                            const dx = pos.x + nodeWidth/2 - (x + nodeWidth/2);
                            const dy = pos.y + nodeHeight/2 - (y + nodeHeight/2);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) return true;
                        }
                        return false;
                    };

                    // Helper to find best position for a node
                    const findBestPosition = (node, preferredX, preferredY, connectedPositions) => {
                        let bestX = preferredX;
                        let bestY = preferredY;
                        
                        // Try the preferred position first
                        if (!checkOverlap(bestX, bestY)) {
                            return { x: bestX, y: bestY };
                        }
                        
                        // Try positions in a spiral pattern around preferred
                        for (let radius = 100; radius <= 500; radius += 80) {
                            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                const testX = preferredX + Math.cos(angle) * radius;
                                const testY = preferredY + Math.sin(angle) * radius;
                                if (testX >= padding && testY >= padding && !checkOverlap(testX, testY)) {
                                    return { x: testX, y: testY };
                                }
                            }
                        }
                        
                        return { x: bestX, y: bestY };
                    };

                    // Place nodes using a hub-centric radial layout
                    let centerX = padding + 350;
                    let centerY = padding + 280;

                    sortedNodes.forEach((nodeData, index) => {
                        if (placedNodes.has(nodeData.node.label)) return;

                        const node = nodeData.node;
                        const connectedNodes = Array.from(nodeData.connectedTo);
                        const unplacedConnected = connectedNodes.filter(n => !placedNodes.has(n));

                        // If this is a hub (has multiple connections) and not yet placed
                        if (nodeData.connectionCount >= 2 && unplacedConnected.length >= 2) {
                            // Place hub at center
                            const hubPos = findBestPosition(node, centerX, centerY, []);
                            nodePositions.set(node.label, { x: hubPos.x, y: hubPos.y, type: node.type });
                            placedNodes.add(node.label);

                            // Place connected nodes radially around the hub
                            const hubCenterX = hubPos.x + nodeWidth / 2;
                            const hubCenterY = hubPos.y + nodeHeight / 2;

                            // Separate connected nodes by type for better organization
                            const connectedSources = unplacedConnected.filter(n => adjacencyMap.get(n).node.type === 'source');
                            const connectedTargets = unplacedConnected.filter(n => adjacencyMap.get(n).node.type === 'target');
                            const connectedIntermediates = unplacedConnected.filter(n => adjacencyMap.get(n).node.type === 'intermediate');

                            // Place sources on the left (around -150 to -210 degrees, i.e., left side)
                            connectedSources.forEach((connLabel, i) => {
                                const angleStart = Math.PI * 0.65; // ~120 degrees
                                const angleRange = Math.PI * 0.7; // spread over 126 degrees
                                const angle = angleStart + (connectedSources.length > 1 ? (i / (connectedSources.length - 1)) * angleRange : angleRange / 2);
                                const x = hubCenterX + Math.cos(angle) * radialDistance - nodeWidth / 2;
                                const y = hubCenterY + Math.sin(angle) * radialDistance - nodeHeight / 2;
                                const pos = findBestPosition(adjacencyMap.get(connLabel).node, x, y, []);
                                nodePositions.set(connLabel, { x: pos.x, y: pos.y, type: adjacencyMap.get(connLabel).node.type });
                                placedNodes.add(connLabel);
                            });

                            // Place targets on the right (around -30 to 30 degrees)
                            connectedTargets.forEach((connLabel, i) => {
                                const angleStart = -Math.PI * 0.35; // -63 degrees
                                const angleRange = Math.PI * 0.7; // spread over 126 degrees
                                const angle = angleStart + (connectedTargets.length > 1 ? (i / (connectedTargets.length - 1)) * angleRange : angleRange / 2);
                                const x = hubCenterX + Math.cos(angle) * radialDistance - nodeWidth / 2;
                                const y = hubCenterY + Math.sin(angle) * radialDistance - nodeHeight / 2;
                                const pos = findBestPosition(adjacencyMap.get(connLabel).node, x, y, []);
                                nodePositions.set(connLabel, { x: pos.x, y: pos.y, type: adjacencyMap.get(connLabel).node.type });
                                placedNodes.add(connLabel);
                            });

                            // Place intermediates at top/bottom
                            connectedIntermediates.forEach((connLabel, i) => {
                                const angleStart = Math.PI * 0.35;
                                const angleRange = Math.PI * 0.3;
                                const angle = (i % 2 === 0 ? -1 : 1) * (angleStart + Math.floor(i/2) * 0.3);
                                const x = hubCenterX + Math.cos(angle) * radialDistance * 1.2 - nodeWidth / 2;
                                const y = hubCenterY + Math.sin(angle) * radialDistance * 1.2 - nodeHeight / 2;
                                const pos = findBestPosition(adjacencyMap.get(connLabel).node, x, y, []);
                                nodePositions.set(connLabel, { x: pos.x, y: pos.y, type: adjacencyMap.get(connLabel).node.type });
                                placedNodes.add(connLabel);
                            });

                            // Move center for next hub
                            centerX += 650;
                            if (centerX > 1600) {
                                centerX = padding + 400;
                                centerY += 500;
                            }
                        }
                    });

                    // Place any remaining unplaced nodes
                    sortedNodes.forEach(nodeData => {
                        if (placedNodes.has(nodeData.node.label)) return;

                        const node = nodeData.node;
                        const connectedNodes = Array.from(nodeData.connectedTo);
                        const placedConnected = connectedNodes.filter(n => placedNodes.has(n));

                        if (placedConnected.length > 0) {
                            // Place near an already-placed connected node
                            const connectedPos = nodePositions.get(placedConnected[0]);
                            let preferredX, preferredY;
                            
                            // Position based on node type
                            if (node.type === 'source') {
                                preferredX = connectedPos.x - radialDistance;
                                preferredY = connectedPos.y;
                            } else if (node.type === 'target') {
                                preferredX = connectedPos.x + radialDistance;
                                preferredY = connectedPos.y;
                            } else {
                                preferredX = connectedPos.x;
                                preferredY = connectedPos.y - radialDistance;
                            }
                            
                            const pos = findBestPosition(node, preferredX, preferredY, [connectedPos]);
                            nodePositions.set(node.label, { x: pos.x, y: pos.y, type: node.type });
                            placedNodes.add(node.label);
                        } else {
                            // No connections, place in a default area
                            const pos = findBestPosition(node, centerX, centerY, []);
                            nodePositions.set(node.label, { x: pos.x, y: pos.y, type: node.type });
                            placedNodes.add(node.label);
                            centerY += nodeHeight + 60;
                        }
                    });

                    // Calculate canvas size based on actual node positions
                    let maxX = 0, maxY = 0, minX = Infinity, minY = Infinity;
                    nodePositions.forEach(pos => {
                        maxX = Math.max(maxX, pos.x + nodeWidth);
                        maxY = Math.max(maxY, pos.y + nodeHeight);
                        minX = Math.min(minX, pos.x);
                        minY = Math.min(minY, pos.y);
                    });

                    // Normalize positions to start from padding
                    const offsetX = padding - minX;
                    const offsetY = padding - minY;
                    nodePositions.forEach((pos, label) => {
                        pos.x += offsetX;
                        pos.y += offsetY;
                    });

                    const canvasWidth = maxX - minX + padding * 2;
                    const canvasHeight = maxY - minY + padding * 2;

                    svg.setAttribute('width', Math.max(canvasWidth, 800));
                    svg.setAttribute('height', Math.max(canvasHeight, 500));
                    svg.setAttribute('viewBox', `0 0 ${Math.max(canvasWidth, 800)} ${Math.max(canvasHeight, 500)}`);

                    // Define arrow markers
                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    defs.innerHTML = `
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--edge-color)" />
                    </marker>
                `;
                    svg.appendChild(defs);

                    // Group connections by: visual arrow direction (fromâ†’to) + PUSH/PULL
                    // This consolidates multiple protocols into single arrows while keeping
                    // arrows in different directions separate
                    const consolidatedConnections = new Map();
                    
                    connectionArray.forEach(conn => {
                        // Determine the visual arrow direction (where the arrowhead points)
                        // For forward arrows (->): arrow goes from conn.from to conn.to
                        // For reverse arrows (<-): arrow goes from conn.to to conn.from
                        const visualFrom = conn.flowDirection === 'reverse' ? conn.to : conn.from;
                        const visualTo = conn.flowDirection === 'reverse' ? conn.from : conn.to;
                        
                        // Key combines: visual direction (fromâ†’to) + PUSH/PULL
                        // This ensures Aâ†’B PUSH and Bâ†’A PUSH are separate arrows
                        const directionKey = `${visualFrom}â†’${visualTo}|${conn.direction}`;
                        
                        if (!consolidatedConnections.has(directionKey)) {
                            consolidatedConnections.set(directionKey, {
                                from: visualFrom,      // Visual start of arrow
                                to: visualTo,          // Visual end of arrow (where arrowhead is)
                                direction: conn.direction,
                                protocols: new Set()
                            });
                        }
                        consolidatedConnections.get(directionKey).protocols.add(conn.protocol);
                    });

                    // Group consolidated connections by node pair for offset calculation
                    // This groups arrows between the same two nodes (regardless of direction)
                    const connectionsByPair = new Map();
                    consolidatedConnections.forEach((conn, key) => {
                        // Sort to get consistent pair key regardless of arrow direction
                        const pairKey = [conn.from, conn.to].sort().join('|');
                        if (!connectionsByPair.has(pairKey)) {
                            connectionsByPair.set(pairKey, []);
                        }
                        connectionsByPair.get(pairKey).push(conn);
                    });

                    // Draw consolidated connections
                    connectionsByPair.forEach((pairConnections, pairKey) => {
                        const [nodeA, nodeB] = pairKey.split('|');
                        
                        // Get positions for consistent reference direction
                        const posA = nodePositions.get(nodeA);
                        const posB = nodePositions.get(nodeB);
                        if (!posA || !posB) return;
                        
                        // Calculate a consistent reference angle from A to B (used for both directions)
                        const refCenterAX = posA.x + nodeWidth / 2;
                        const refCenterAY = posA.y + nodeHeight / 2;
                        const refCenterBX = posB.x + nodeWidth / 2;
                        const refCenterBY = posB.y + nodeHeight / 2;
                        const referenceAngle = Math.atan2(refCenterBY - refCenterAY, refCenterBX - refCenterAX);
                        
                        // Separate connections by direction: Aâ†’B vs Bâ†’A
                        const forwardConns = pairConnections.filter(c => c.from === nodeA && c.to === nodeB);
                        const reverseConns = pairConnections.filter(c => c.from === nodeB && c.to === nodeA);
                        
                        // Calculate base offset: if bidirectional, separate the two directions
                        const hasBidirectional = forwardConns.length > 0 && reverseConns.length > 0;
                        const baseOffset = hasBidirectional ? 20 : 0; // Base separation for bidirectional
                        const offsetStep = 18; // Additional offset for multiple arrows in same direction
                        
                        // Helper function to draw a group of connections
                        // curveSign: +1 for one direction, -1 for opposite (consistent regardless of arrow direction)
                        const drawConnectionGroup = (connections, curveSign, withinGroupStartIndex) => {
                            connections.forEach((conn, index) => {
                                const fromPos = nodePositions.get(conn.from);
                                const toPos = nodePositions.get(conn.to);

                                if (!fromPos || !toPos) return;

                                // Calculate node centers
                                const fromCenterX = fromPos.x + nodeWidth / 2;
                                const fromCenterY = fromPos.y + nodeHeight / 2;
                                const toCenterX = toPos.x + nodeWidth / 2;
                                const toCenterY = toPos.y + nodeHeight / 2;

                                // Calculate angle between nodes (from source to target)
                                const angle = Math.atan2(toCenterY - fromCenterY, toCenterX - fromCenterX);

                                // Calculate edge points - connect from the edge of the node closest to target
                                let x1, y1, x2, y2;
                                
                                // Determine connection points based on angle
                                const absAngle = Math.abs(angle);
                                const threshold = Math.atan2(nodeHeight, nodeWidth);

                                if (absAngle < threshold || absAngle > Math.PI - threshold) {
                                    // Connect horizontally (left/right sides)
                                    if (angle > -Math.PI / 2 && angle < Math.PI / 2) {
                                        x1 = fromPos.x + nodeWidth;
                                        x2 = toPos.x;
                                    } else {
                                        x1 = fromPos.x;
                                        x2 = toPos.x + nodeWidth;
                                    }
                                    y1 = fromCenterY;
                                    y2 = toCenterY;
                                } else {
                                    // Connect vertically (top/bottom sides)
                                    if (angle > 0) {
                                        y1 = fromPos.y + nodeHeight;
                                        y2 = toPos.y;
                                    } else {
                                        y1 = fromPos.y;
                                        y2 = toPos.y + nodeHeight;
                                    }
                                    x1 = fromCenterX;
                                    x2 = toCenterX;
                                }

                                // Create curved path
                                const midX = (x1 + x2) / 2;
                                const midY = (y1 + y2) / 2;
                                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                
                                // Calculate distance for curvature
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                // Use REFERENCE angle for perpendicular direction (consistent for both arrow directions)
                                const perpX = -Math.sin(referenceAngle);
                                const perpY = Math.cos(referenceAngle);
                                
                                // Calculate curvature: base + extra for multiple connections
                                const withinGroupOffset = index * offsetStep;
                                const totalCurve = baseOffset + withinGroupOffset + dist * 0.08;
                                
                                // Control point using consistent perpendicular direction
                                const ctrl1X = midX + perpX * totalCurve * curveSign;
                                const ctrl1Y = midY + perpY * totalCurve * curveSign;
                            
                                const d = `M ${x1} ${y1} Q ${ctrl1X} ${ctrl1Y}, ${x2} ${y2}`;
                                
                                path.setAttribute('d', d);
                                path.setAttribute('fill', 'none');
                                path.setAttribute('stroke', 'var(--edge-color)');
                                path.setAttribute('stroke-width', '2');

                                // Arrow always points to 'to' node (we normalized direction during consolidation)
                                path.setAttribute('marker-end', 'url(#arrowhead)');

                                svg.appendChild(path);

                                // Create consolidated label: "PUSH: FTP, SFTP, PeSIT" or "PULL: HTTP, HTTPS"
                                const protocolList = Array.from(conn.protocols).sort().join(', ');
                                const labelText = `${conn.direction}: ${protocolList}`;
                                
                                // Position label at the curve midpoint with offset
                                const labelX = ctrl1X;
                                const labelY = ctrl1Y;

                                // Calculate label width based on text length
                                const labelWidth = Math.max(labelText.length * 5.5 + 16, 80);
                                const labelHeight = 18;

                                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                labelBg.setAttribute('x', labelX - labelWidth / 2);
                                labelBg.setAttribute('y', labelY - labelHeight / 2);
                                labelBg.setAttribute('width', labelWidth);
                                labelBg.setAttribute('height', labelHeight);
                                labelBg.setAttribute('rx', '9');
                                labelBg.setAttribute('fill', 'var(--bg-secondary)');
                                labelBg.setAttribute('stroke', 'var(--border-color)');
                                labelBg.setAttribute('stroke-width', '1');
                                svg.appendChild(labelBg);

                                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                label.setAttribute('x', labelX);
                                label.setAttribute('y', labelY + 4);
                                label.setAttribute('text-anchor', 'middle');
                                label.setAttribute('font-size', '10');
                                label.setAttribute('font-weight', '500');
                                label.setAttribute('fill', 'var(--text-secondary)');
                                label.textContent = labelText;
                                svg.appendChild(label);
                            });
                        };
                        
                        // Draw forward connections (Aâ†’B) curving one way
                        if (forwardConns.length > 0) {
                            drawConnectionGroup(forwardConns, hasBidirectional ? 1 : 0, 0);
                        }
                        
                        // Draw reverse connections (Bâ†’A) curving the opposite way
                        if (reverseConns.length > 0) {
                            drawConnectionGroup(reverseConns, hasBidirectional ? -1 : 0, 0);
                        }
                    });

                    // Draw nodes
                    nodePositions.forEach((pos, label) => {
                        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                        // Node rectangle
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', pos.x);
                        rect.setAttribute('y', pos.y);
                        rect.setAttribute('width', nodeWidth);
                        rect.setAttribute('height', nodeHeight);
                        rect.setAttribute('rx', '8');

                        // Apply colors based on type
                        if (pos.type === 'source') {
                            rect.setAttribute('fill', 'var(--node-source)');
                            rect.setAttribute('stroke', 'var(--node-source-border)');
                        } else if (pos.type === 'target') {
                            rect.setAttribute('fill', 'var(--node-target)');
                            rect.setAttribute('stroke', 'var(--node-target-border)');
                        } else {
                            rect.setAttribute('fill', 'var(--node-intermediate)');
                            rect.setAttribute('stroke', 'var(--node-intermediate-border)');
                        }
                        rect.setAttribute('stroke-width', '2');
                        group.appendChild(rect);

                        // Node label
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', pos.x + nodeWidth / 2);
                        text.setAttribute('y', pos.y + nodeHeight / 2 + 4);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '13');
                        text.setAttribute('font-weight', '500');

                        if (pos.type === 'source') {
                            text.setAttribute('fill', 'var(--node-source-border)');
                        } else if (pos.type === 'target') {
                            text.setAttribute('fill', 'var(--node-target-border)');
                        } else {
                            text.setAttribute('fill', 'var(--text-primary)');
                        }
                        text.textContent = label;
                        group.appendChild(text);

                        svg.appendChild(group);
                    });
                },

                updateThemeIcon() {
                    const icon = document.getElementById('themeIcon');
                    if (StateManager.state.theme === 'dark') {
                        icon.innerHTML = `
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    `;
                    } else {
                        icon.innerHTML = `
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    `;
                    }
                }
            };

            // ============================================
            // ============================================
            // APPLICATION INITIALIZATION
            // ============================================
            function initApp() {
                // Initialize workspace manager (loads from storage or creates default)
                WorkspaceManager.initialize();

                // Apply saved theme
                document.body.setAttribute('data-theme', StateManager.state.theme);

                // Initialize UI
                UIController.init();
                UIController.updateWorkspaceSelect();
                UIController.loadActiveWorkspace();
                UIController.updateThemeIcon();
            }

            // Start the application when DOM is ready
            document.addEventListener('DOMContentLoaded', initApp);
        </script>
</body>

</html>